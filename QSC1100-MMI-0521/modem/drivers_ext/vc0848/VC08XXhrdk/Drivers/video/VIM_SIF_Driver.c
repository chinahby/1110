/*******************************************************************************
 *  All rights reserved, Copyright (C) vimicro LIMITED 2005                                                     
 * ------------------------------------------------------------------------------
 * [File Name]            : VIM_SIF_Driver.c
 * [Description]          : 5X 's LCDIF moudle sub driver:578b 
 * [Author]                 : WendyGuo	
 * [Date Of Creation]  : 2007-03-15 
 * [Platform]              : ARM7
 * [Note]                    : 
 *
 * Modification History : 
 * ------------------------------------------------------------------------------
 * Date        		Author     		Modifications
 * ------------------------------------------------------------------------------
 * 2005-11-16  	Liuhd			The first version
 * 2006-06-08  	Angela			Update for 528
 * 2006-03-15  	WendyGuo         	Created 578b
 *******************************************************************************/
/*******************************************************************************
 * This source code has been made available to you by VIMICRO on an
 * AS-IS basis. Anyone receiving this source code is licensed under VIMICRO
 * copyrights to use it in any way he or she deems fit, including copying it,
 * modifying it, compiling it, and redistributing it either with or without
 * modifications. Any person who transfers this source code or any derivative
 * work must include the VIMICRO copyright notice and this paragraph in
 * the transferred software.
 *******************************************************************************/


#include"VIM_COMMON.h"

#if VIM_SENSOR_HAVE_BAYER

static UINT8 gGainRange[VIM_SIF_ET_GAINRANGE_STEP];
static const TAeStep gAeStep[] = 
{
	{4, 4},			//slow
	{4, 3},			//normal
	{4, 2},			//fast
	{4, 1}			//fastest
};


/*******************************************************************
log table, generated by log generator
all data are recorded in 3.13 fix point format
For example:
log[13] = 2.5649493574615367360534874415653

then
2.5649493574615367360534874415653 * 2^13 = 21012 = 0x5214;

so:
gLogTable[13]= 0x5214;

Version 0.1
Creator: Sandman
*********************************************************************/
const UINT16 gLogTable[257] = {
	0x0, 0x0, 0x162e, 0x2327, 0x2c5c, 0x3380, 0x3956, 0x3e44, 0x428a, 0x464f, 0x49ae, 0x4cbb, 0x4f84, 0x5214, 0x5473, 0x56a8, 0x58b9,
	0x5aa9, 0x5c7d, 0x5e38, 0x5fdd, 0x616c, 0x62e9, 0x6455, 0x65b2, 0x6701, 0x6842, 0x6977, 0x6aa1, 0x6bc0, 0x6cd6, 0x6de3, 0x6ee7,
	0x6fe3, 0x70d7, 0x71c5, 0x72ac, 0x738c, 0x7467, 0x753b, 0x760b, 0x76d5, 0x779a, 0x785b, 0x7918, 0x79d0, 0x7a84, 0x7b34, 0x7be0,
	0x7c89, 0x7d2f, 0x7dd1, 0x7e70, 0x7f0c, 0x7fa5, 0x803c, 0x80cf, 0x8160, 0x81ef, 0x827b, 0x8304, 0x838c, 0x8411, 0x8494, 0x8515,
	0x8594, 0x8611, 0x868c, 0x8706, 0x877d, 0x87f3, 0x8867, 0x88da, 0x894b, 0x89ba, 0x8a28, 0x8a95, 0x8b00, 0x8b6a, 0x8bd2, 0x8c39,
	0x8c9f, 0x8d03, 0x8d67, 0x8dc9, 0x8e2a, 0x8e8a, 0x8ee8, 0x8f46, 0x8fa2, 0x8ffe, 0x9058, 0x90b2, 0x910b, 0x9162, 0x91b9, 0x920f,
	0x9264, 0x92b8, 0x930b, 0x935d, 0x93af, 0x93ff, 0x944f, 0x949e, 0x94ed, 0x953a, 0x9587, 0x95d4, 0x961f, 0x966a, 0x96b4, 0x96fd,
	0x9746, 0x978e, 0x97d6, 0x981d, 0x9863, 0x98a9, 0x98ee, 0x9933, 0x9977, 0x99ba, 0x99fd, 0x9a3f, 0x9a81, 0x9ac2, 0x9b03, 0x9b43,
	0x9b83, 0x9bc2, 0x9c01, 0x9c3f, 0x9c7d, 0x9cbb, 0x9cf8, 0x9d34, 0x9d70, 0x9dac, 0x9de7, 0x9e21, 0x9e5c, 0x9e96, 0x9ecf, 0x9f08,
	0x9f41, 0x9f79, 0x9fb1, 0x9fe9, 0xa020, 0xa057, 0xa08d, 0xa0c3, 0xa0f9, 0xa12e, 0xa163, 0xa198, 0xa1cc, 0xa200, 0xa234, 0xa267,
	0xa29a, 0xa2cd, 0xa300, 0xa332, 0xa363, 0xa395, 0xa3c6, 0xa3f7, 0xa428, 0xa458, 0xa488, 0xa4b8, 0xa4e7, 0xa516, 0xa545, 0xa574,
	0xa5a3, 0xa5d1, 0xa5ff, 0xa62c, 0xa65a, 0xa687, 0xa6b4, 0xa6e0, 0xa70d, 0xa739, 0xa765, 0xa790, 0xa7bc, 0xa7e7, 0xa812, 0xa83d,
	0xa867, 0xa892, 0xa8bc, 0xa8e6, 0xa910, 0xa939, 0xa962, 0xa98b, 0xa9b4, 0xa9dd, 0xaa05, 0xaa2e, 0xaa56, 0xaa7d, 0xaaa5, 0xaacd,
	0xaaf4, 0xab1b, 0xab42, 0xab69, 0xab8f, 0xabb6, 0xabdc, 0xac02, 0xac28, 0xac4d, 0xac73, 0xac98, 0xacbd, 0xace2, 0xad07, 0xad2c,
	0xad50, 0xad75, 0xad99, 0xadbd, 0xade1, 0xae04, 0xae28, 0xae4b, 0xae6e, 0xae91, 0xaeb4, 0xaed7, 0xaefa, 0xaf1c, 0xaf3f, 0xaf61,
	0xaf83, 0xafa5, 0xafc7, 0xafe8, 0xb00a, 0xb02b, 0xb04c, 0xb06e, 0xb08e, 0xb0af, 0xb0d0, 0xb0f1, 0xb111, 0xb131, 0xb152, 0xb172
};



static	void VIM_SIF_IspToolComputeGainThreshold(UINT8 byGain, UINT8 byGainRange);
static	void VIM_SIF_IspToolCalculateNewGammaCurve(const UINT8 * OriginalGammaCurve, 
									SINT16 DeltaContrast, 
									UINT8 * NewGammaCurve	 );
static 	UINT8 V5B_IspGetGlbgainStep(void);
static 	UINT8 V5B_IspToolComputeEt(VIM_ISP_PTAEADJUST ae);
static 	BOOL V5B_IspToolAeIsGainOnly(VIM_ISP_PTAEADJUST ae);
static 	UINT32 V5B_IspToolComputeGain(UINT8 gain, UINT8 preY, UINT8 newY);
static 	void V5B_IspToolAeFomula(VIM_ISP_PTAEADJUST ae, UINT8 flag);
static 	void V5B_IspToolOneStepMore(VIM_ISP_PTAEADJUST ae);
static 	void V5B_IspToolEtRangeAdjust(VIM_ISP_PTAEADJUST ae);
static 	UINT8 V5B_IspToolGetGainRange(UINT8 byStep);
static 	void V5B_IspToolOneStepLess(VIM_ISP_PTAEADJUST ae);
static void VIM_SIF_IspSetExposeTime(const TSnrInfo *pSensorInfo,VIM_ISP_PTAEADJUST ae,UINT8 byResolution);
	void VIM_SIF_IspSetYMeanTarget(UINT8 byYMeanTarget);
void VIM_SIF_IspSetYMeanThreshold(UINT8 byYMeanThreshold);
void VIM_SIF_IspSetGlbgainDelay(UINT8 byVal);
void VIM_SIF_IspSetGlbgain(UINT8 byGlbGain);
#endif //VIM_SENSOR_HAVE_BAYER
#if (BOARD_TYPE==VC0820_FPGA)
#else	
static void VIM_ISP_SetIntEnable(UINT8 val);
#endif
/********************************************************************************
* Description:
*	Init i2c
*	The pSensorInfo is gotton from sensor.c.
* Parameters:
*	pSensorInfo: The pointer to TSensorInfo structure.
	UINT32 MCLK: mclk for 578
* Return:
*	VIM_SUCCEED: init i2c VIM_SUCCEED
*	
* Note:
*	
**********************************************************************************/
VIM_RESULT VIM_SIF_SifInitI2c(
	const TSnrInfo *pSensorInfo,			/*(IN)	The pointer to TSensorInfo structure	*/
	UINT32 dwMclk						/*(IN)	MCLK of 578b	*/
)
{
	UINT32 bMode;
	UINT16 div;
	
//#if(BOARD_TYPE==VC0820_FPGA)
	//fbz add for sif pin
	VIM_HIF_SetReg32(0x60170808,0x11);
//#endif
	bMode=VIM_HIF_GetReg32(V5_REG_SIF_SNROP_MODE);
	bMode&=(~BIT5);				//b5=0, selected I2C bus *
	bMode&=(~BIT2);				//b2=0, I2c type normal
	if(pSensorInfo->bustype==1)	//serial bus
	{
		bMode|=BIT5;			//b5=1, selected serial bus
	}
	else							//I2C bus
	{
		if(pSensorInfo->i2ctype==1)//ov
			bMode|=BIT2;		//b2=1, ov sensor used in I2C *
		div = (UINT16)(((dwMclk / (UINT32)pSensorInfo->i2crate) + 3) >> 2) << 2;	//inorder to cut low 2bit, because the I2C_clkcnt should be multiple of 4
		if(div < 0x40)				//Why +3???????
			div = 0x40;
#if(BOARD_TYPE==VC0820_FPGA)		
		VIM_HIF_SetReg16(V5_REG_SIF_I2C_CLKCNT, div);	//set I2C clock
#else
		VIM_HIF_SetReg32(V5_REG_SIF_I2C_CLKCNT, div);	//set I2C clock
#endif
#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
#if(BOARD_TYPE==VC0820_FPGA)		
		div=VIM_HIF_GetReg16(V5_REG_SIF_I2C_CLKCNT);	//set I2C clock
#else
		div=VIM_HIF_GetReg32(V5_REG_SIF_I2C_CLKCNT);	//set I2C clock
#endif
		VIM_USER_PrintDec("[VC0578B][SIF]:V5_REG_SIF_I2C_CLKCNT=",div);
#endif	
		//set i2c address
		VIM_SIF_SetI2cDevAddr(pSensorInfo->i2caddress);	//set I2C device address
	}
	VIM_HIF_SetReg32(V5_REG_SIF_SNROP_MODE,bMode);
	return VIM_SUCCEED;

}


/********************************************************************************
* Description:
*	Init SIF according to the pSensorInfo information.
*	The pSensorInfo is gotton from sensor.c.
* Parameters:
*	pSensorInfo: The pointer to TSensorInfo structure.
* Return:
*	TRUE: init SIF+ISP success.
*	FALSE: pSensorInfo is NULL.
* Note:
*	Init public SIF parameters, they are the same for different sensor resolution.
**********************************************************************************/
VIM_RESULT VIM_SIF_SifSensorInit(
	const TSnrInfo *pSensorInfo,				/*(IN)	The pointer to TSensorInfo structure*/
	VIM_ISP_TAEADJUST *paeadjust
)
{
	UINT8 i = 0;
	UINT32 byMode = 0;
	#if VIM_SENSOR_HAVE_BAYER
	UINT8 NTableDefault[17] = { 0x04, 0x04, 0x04, 0x04, 0x04, 0x06, 0x06, 0x06, 0x06, 0x08, 0x08, 0x0a, 0x0a, 0x0a, 0x0a, 0x08, 0x04 };
	#endif
	if (NULL == pSensorInfo)
	{
		return VIM_ERROR_SENSOR_NOINFO;
	}
	byMode=VIM_HIF_GetReg8(V5_REG_SIF_SNR_MODE);
	byMode&=(~BIT7);
	byMode&=(~BIT6);
	byMode&=(~BIT5);
	byMode|= (SIF_SYNC_MODE & 0x1) <<7;//Sensor output data sync mode:0--normal,1--CCIR656      BIT7     
	byMode|=(pSensorInfo->snrtype & 0x1) << 6 ;// Sensor type, YUV or BAYER
	byMode|=(0x1 << 5);	// Enable sync generate to sensor.
	VIM_HIF_SetReg8(V5_REG_SIF_SNR_MODE, byMode);
	VIM_USER_DelayMs(1);

	// set 0x085c edge chos
	byMode=0;//VIM_HIF_GetReg8(V5_REG_SIF_EDGE_CHOS);
	//byMode=VIM_HIF_GetReg8(V5_REG_SIF_EDGE_CHOS);//angela 0314
 	if(pSensorInfo->pclk)
	{
		//byMode|=BIT1;	//use clock
		byMode|=(BIT1|BIT0);
		byMode|=((pSensorInfo->clkcfg&7)<<2);
	}
	VIM_HIF_SetReg32(V5_REG_SIF_EDGE_CHOS, byMode);
	
	// Set sif register according to the table.
	for(i = 0; i < pSensorInfo->dsif[0].len ; i++)
	{
		VIM_HIF_SetReg16((UINT32)(pSensorInfo->dsif[0].regval[i].adr | V5_REG_SIF_BASE), (UINT16)pSensorInfo->dsif[0].regval[i].val);
		VIM_USER_DelayMs(pSensorInfo->dsif[0].regval[i].wait);
	}

#if (BOARD_TYPE==VC0820_FPGA)
#else	
	if(SENSOR_TYPE_YUV == pSensorInfo->snrtype)		//YUV
	{
		// Some sensor has 2 IIC addresses. Sensor's ISP has its own IIC address.
		// But generally, they are the same.
		//VIM_SIF_SetI2cDevAddr(pSensorInfo->i2cispaddress);	//set i2c address to isp

		// angela remove it 2006-1-13
		/*VIM_SIF_SetI2cDevAddr(pSensorInfo->i2caddress);	//set i2c address to isp		
		// Init Sensor's ISP registers.
		for(i = 0; i < pSensorInfo->snrisp.len; i++)
		{
			pSensorInfo->snrSetRegCall((UINT8)pSensorInfo->snrisp.regval[i].adr, (UINT16)pSensorInfo->snrisp.regval[i].val);
			VIM_USER_DelayMs(pSensorInfo->snrisp.regval[i].wait);
		}
		VIM_SIF_SetI2cDevAddr(pSensorInfo->i2caddress);	//set i2c address back*/
		VIM_HIF_SetReg8(V5_REG_ISP_CTRL, (VIM_HIF_GetReg8(V5_REG_ISP_CTRL) | 0x40));
		
	}
	else// RGB Type
	{
		#if VIM_SENSOR_HAVE_BAYER
		VIM_SIF_IspSetYMeanTarget(pSensorInfo->aeparm.ytarget);
		VIM_SIF_IspSetYMeanThreshold(pSensorInfo->aeparm.ythreshold);
		VIM_SIF_IspSetGlbgainDelay(pSensorInfo->aeparm.gdelay);
		VIM_SIF_IspSetGlbgain(pSensorInfo->aeparm.gain);
		
		VIM_SIF_IspToolComputeGainThreshold(pSensorInfo->aeparm.gtarget, pSensorInfo->aeparm.gthreshold);



		paeadjust->et = ET_ONE_STEP*3;
		paeadjust->ytop = pSensorInfo->aeparm.ytop;
		paeadjust->gain = pSensorInfo->aeparm.gain;
		paeadjust->gtarget = pSensorInfo->aeparm.gtarget;
		paeadjust->gthd = pSensorInfo->aeparm.gthreshold;
		paeadjust->minet = pSensorInfo->aeparm.minet;
		paeadjust->maxgain = pSensorInfo->aeparm.maxgain;
		paeadjust->mingain = pSensorInfo->aeparm.mingain;
		paeadjust->ytarget = pSensorInfo->aeparm.ytarget;
		paeadjust->ythd = pSensorInfo->aeparm.ythreshold;
		paeadjust->speed = (pSensorInfo->aeparm.speed&0x03);
		if (VIM_EXP_50HZ == VIM_SENSOR_INIT_FREQ)
			paeadjust->env = VIM_SIF_FREQ_50HZ;
		else if (VIM_EXP_60HZ == VIM_SENSOR_INIT_FREQ)
			paeadjust->env = VIM_SIF_FREQ_60HZ;
		else if (VIM_EXP_AUTO== VIM_SENSOR_INIT_FREQ)
			paeadjust->env = VIM_SIF_FREQ_NONE;
		paeadjust->freq = (VIM_SIF_FREQ_60HZ == paeadjust->env) ? EPFREQ_60HZ : EPFREQ_50HZ;
		//



		if(pSensorInfo->brightness > VIM_USER_MAX_STEP/2)
			paeadjust->brightness=32 + (pSensorInfo->brightness-VIM_USER_MAX_STEP/2)*BRIGHTNESS_STEP;
		else
			paeadjust->brightness=32 - (VIM_USER_MAX_STEP/2 - pSensorInfo->brightness)*BRIGHTNESS_STEP;			


		if(pSensorInfo->contrast > VIM_USER_MAX_STEP/2)
			paeadjust->contrast=32 + (pSensorInfo->contrast-VIM_USER_MAX_STEP/2)*CONTRAST_STEP;
		else
			paeadjust->contrast=32 - (VIM_USER_MAX_STEP/2-pSensorInfo->contrast)*CONTRAST_STEP;

		paeadjust->saturation = pSensorInfo->saturation;
		
		VIM_SIF_IspSetBrightness(paeadjust,pSensorInfo,paeadjust->brightness);
		VIM_SIF_IspSetContrast(paeadjust,pSensorInfo,paeadjust->contrast);
		
		VIM_SIF_IspSetSaturation(paeadjust,pSensorInfo->saturation);//angela 2006-3-7
		//Set NoiseTable
		for(i = 0; i < 17; i++)
			VIM_HIF_SetReg8((V5_REG_ISP_NT0_3+ i), NTableDefault[i]);


		#if VIM_SENSOR_AUTO_FOCUS
		//VIM_USER_AutoFocusInit();
		//VIM_SIF_IspSelEMMarix(1);
		#endif

		#endif
	}

	// Init ISP registers
	for(i=0; i<pSensorInfo->disp.len; i++)
	{
		VIM_HIF_SetReg8((UINT32)(V5_REG_ISP_BASE | pSensorInfo->disp.regval[i].adr), (UINT8)pSensorInfo->disp.regval[i].val);
		VIM_USER_DelayMs(pSensorInfo->disp.regval[i].wait);
	}
	VIM_SIF_IspCtrlUpate(0xff);//update all	
#endif	
	return VIM_SUCCEED;

}

/********************************************************************************
* Description:
*	get sensor type
*	
* Parameters:
*		void
* Return:
*	VIM_SIF_SENSOR_TYPE_YUV=1,
*	VIM_SIF_SENSOR_TYPE_RGB=0
* Note:
*	
**********************************************************************************/

VIM_SIF_SENSOR_TYPE VIM_SIF_GetSensorType(void)
{
UINT8 byMode;
	byMode=VIM_HIF_GetReg32(V5_REG_SIF_SNR_MODE);
	byMode>>=6;
	byMode&=0x1;
	return (VIM_SIF_SENSOR_TYPE)byMode;
}

/********************************************************************************
* Description:
*	Adjust SIF's setting when adjust sensor's resolution.
*	
* Parameters:
*	pSensorInfo: The pointer to TSnrInfo structure.
*	byResolution: Sensor Resolution: VGA or SXGA or QXGA....			
* Return:
*	TRUE: 	Set SIF success.
*	FALSE:	 pSensorInfo is NULL 
* Note:
*	
**********************************************************************************/
VIM_RESULT VIM_SIF_SetSensorResolution(
	const TSnrInfo *pSensorInfo, 				/*(IN)	The pointer to TSensorInfo structure*/
	VIM_ISP_TAEADJUST *taeadjust,
	VIM_SIF_RESOLUTION byResolution	,		/*(IN)	the sensor resolution is VIM_SIF_MAXPIXEL or VIM_SIF_HALFPIXEL*/
	VIM_SIF_FRAMERATE frmrate
)
{
	//UINT8 uReg;
	TSize SensorOutputSize; 
	UINT16 wVStart;
	int  i = 0;

	if (NULL == pSensorInfo)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_SIF_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_NoInformation[ERROR]");
		#endif
		return VIM_ERROR_SENSOR_NOINFO;
	}
	
	
	if((byResolution>=pSensorInfo->snrSizeCfg.len))		//WHY?? how to compare ?????
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_Resolution larger than sensor size[ERROR]");
		#endif
		return VIM_ERROR_SENSOR_RESOLUTION;	
	}
	
	
	/* set sif */
	SensorOutputSize.cx = pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].size.cx;
	SensorOutputSize.cy = pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].size.cy;
	
	/*SIF module will output Href sync signal to ISP and IPP module*/
#if(BOARD_TYPE==VC0820_FPGA)	
	VIM_HIF_SetReg16(V5_REG_SIF_HREF_LENGTH, (UINT16)(SensorOutputSize.cx - 1));		//wendy guo 3/29/2007
#else
	VIM_HIF_SetReg32(V5_REG_SIF_HREF_LENGTH, (UINT32)(SensorOutputSize.cx - 1));		//wendy guo 3/29/2007
#endif
	/*get SIF module  Vref sync signal to ISP and IPP module*/
#if(BOARD_TYPE==VC0820_FPGA)	
	wVStart = (UINT16)VIM_HIF_GetReg16(V5_REG_SIF_VREF_START);						//wendy guo 3/29/2007
#else
	wVStart = (UINT16)VIM_HIF_GetReg32(V5_REG_SIF_VREF_START);						//wendy guo 3/29/2007
#endif
	/*set SIF module will output Vref sync signal to ISP and IPP module*/
	//VIM_HIF_SetReg16(V5_REG_SIF_VREF_STOPH, SensorOutputSize.cy + wVStart);
#if(BOARD_TYPE==VC0820_FPGA)
	VIM_HIF_SetReg16(V5_REG_SIF_VREF_STOP, (UINT16)(SensorOutputSize.cy + wVStart));	//wendy guo 3/29/2007
#else
	VIM_HIF_SetReg32(V5_REG_SIF_VREF_STOP, (UINT32)(SensorOutputSize.cy + wVStart));	//wendy guo 3/29/2007
#endif

#if(BOARD_TYPE==VC0820_FPGA)
#else
	VIM_HIF_SetReg32(V5_REG_ISP_IMG_WIDTH, (UINT32)SensorOutputSize.cx);
	VIM_HIF_SetReg32(V5_REG_ISP_IMG_HEIGHT, (UINT32)SensorOutputSize.cy);
#if VIM_SENSOR_HAVE_BAYER

	VIM_HIF_SetReg8(V5_REG_ISP_AEAWB_WIN_HPOS_0_3,0);	
	VIM_HIF_SetReg8(V5_REG_ISP_AEAWB_WIN_VPOS_0_3,0);		
	for(i=1;i<5;i++)
	{
		VIM_HIF_SetReg8(V5_REG_ISP_AEAWB_WIN_HPOS_0_3+i,(UINT8) (SensorOutputSize.cx/64));	
		VIM_HIF_SetReg8(V5_REG_ISP_AEAWB_WIN_VPOS_0_3+i,(UINT8) (SensorOutputSize.cy/64));	
	}
	
#endif
#endif



	/*config sensor's mclk ratio sensor's clk = SIF's clk / (sel+1)*/
#if(BOARD_TYPE==VC0820_FPGA)
	VIM_HIF_SetReg8(V5_REG_SIF_SNRCLK_CNT, (UINT8)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrclkratio);//wendy guo 3/29/2007
//#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
		VIM_USER_PrintDec("[VC0578B][SIF]:V5_REG_SIF_SNRCLK_CNT =",VIM_HIF_GetReg8(V5_REG_SIF_SNRCLK_CNT));
//#endif
	/*config sensor's output pixel clk ratio  pixel's clk = SIF's clk / (sel+1)*/
	VIM_HIF_SetReg8(V5_REG_SIF_PIXRATE_SEL, (UINT8)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrpixelratio);//wendy guo 3/29/2007
#else
	VIM_HIF_SetReg8(V5_REG_SIF_SNRCLK_CNT, (UINT32)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrclkratio);//wendy guo 3/29/2007
//#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
		VIM_USER_PrintDec("[VC0578B][SIF]:V5_REG_SIF_SNRCLK_CNT =",VIM_HIF_GetReg32(V5_REG_SIF_SNRCLK_CNT));
//#endif
	/*config sensor's output pixel clk ratio  pixel's clk = SIF's clk / (sel+1)*/
	VIM_HIF_SetReg32(V5_REG_SIF_PIXRATE_SEL, (UINT32)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrpixelratio);//wendy guo 3/29/2007

#endif
#if (BOARD_TYPE==VC0820_FPGA)
#else	
	//isp  init parameters
	for(i = 0; i < pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].visp.len; i++)
	{
		VIM_HIF_SetReg32((UINT32)(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].visp.regval[i].adr), 
			(UINT32)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].visp.regval[i].val);//wendy guo 3/29/2007
		VIM_USER_DelayMs(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].visp.regval[i].wait);
	}
#endif
	taeadjust->maxet=pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].maxet;

	if(pSensorInfo->snrrst)
   		VIM_SIF_SensorReset();
	if(frmrate==VIM_SIF_SNSOR_FRAMERATE_FORCAPIMAGE)
	{
        for(i = 0; i < pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snr.len ; i++)
        {
        	pSensorInfo->snrSetRegCall((UINT32)(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snr.regval[i].adr), 
        		(UINT16)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snr.regval[i].val);
        	VIM_USER_DelayMs(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snr.regval[i].wait);
        }
	}
	else
	{
		for(i = 0; i < pSensorInfo->snrSizeCfgforVideoRecorder.pSizeCfg[0].snr.len ; i++)
		{
			pSensorInfo->snrSetRegCall((UINT32)(pSensorInfo->snrSizeCfgforVideoRecorder.pSizeCfg[0].snr.regval[i].adr), 
				(UINT16)pSensorInfo->snrSizeCfgforVideoRecorder.pSizeCfg[0].snr.regval[i].val);
			VIM_USER_DelayMs(pSensorInfo->snrSizeCfgforVideoRecorder.pSizeCfg[0].snr.regval[i].wait);
		}

	}
	

	if(SENSOR_TYPE_RGB == pSensorInfo->snrtype)	
	{
#if VIM_SENSOR_HAVE_BAYER
		VIM_SIF_IspSetExposeTime(pSensorInfo,taeadjust,byResolution);
#endif
	}
	
	return VIM_SUCCEED;
}

/********************************************************************************
* Description:
*	Adjust SIF's setting when adjust sensor's resolution.
*	
* Parameters:
*	pSensorInfo: The pointer to TSnrInfo structure.
*	byResolution: Sensor Resolution: VGA or SXGA or QXGA....			
* Return:
*	TRUE: 	Set SIF success.
*	FALSE:	 pSensorInfo is NULL 
* Note:
*	
**********************************************************************************/
VIM_RESULT VIM_SIF_SetSensorResolutionForVideo(
	const TSnrInfo *pSensorInfo, 				/*(IN)	The pointer to TSensorInfo structure*/
	VIM_ISP_TAEADJUST *taeadjust,
	VIM_SIF_RESOLUTION byResolution			/*(IN)	the sensor resolution is VIM_SIF_MAXPIXEL or VIM_SIF_HALFPIXEL*/
)
{
	//UINT8 uReg;
	TSize SensorOutputSize; 
	UINT16 wVStart;
	int  i = 0;

	if (NULL == pSensorInfo)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_SIF_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_NoInformation[ERROR]");
		#endif
		return VIM_ERROR_SENSOR_NOINFO;
	}
	
	
	if((byResolution>=pSensorInfo->snrSizeCfg.len))		//WHY?? how to compare ?????
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_Resolution larger than sensor size[ERROR]");
		#endif
		return VIM_ERROR_SENSOR_RESOLUTION;	
	}
	
	
	/* set sif */
	SensorOutputSize.cx = pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].size.cx;
	SensorOutputSize.cy = pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].size.cy;
	
	/*SIF module will output Href sync signal to ISP and IPP module*/
#if(BOARD_TYPE==VC0820_FPGA)	
	VIM_HIF_SetReg16(V5_REG_SIF_HREF_LENGTH, (UINT16)(SensorOutputSize.cx - 1));		//wendy guo 3/29/2007
#else
	VIM_HIF_SetReg32(V5_REG_SIF_HREF_LENGTH, (UINT32)(SensorOutputSize.cx - 1));		//wendy guo 3/29/2007
#endif
	/*get SIF module  Vref sync signal to ISP and IPP module*/
#if(BOARD_TYPE==VC0820_FPGA)	
	wVStart = (UINT16)VIM_HIF_GetReg16(V5_REG_SIF_VREF_START);						//wendy guo 3/29/2007
#else
	wVStart = (UINT16)VIM_HIF_GetReg32(V5_REG_SIF_VREF_START);						//wendy guo 3/29/2007
#endif
	/*set SIF module will output Vref sync signal to ISP and IPP module*/
	//VIM_HIF_SetReg16(V5_REG_SIF_VREF_STOPH, SensorOutputSize.cy + wVStart);
#if(BOARD_TYPE==VC0820_FPGA)
	VIM_HIF_SetReg16(V5_REG_SIF_VREF_STOP, (UINT16)(SensorOutputSize.cy + wVStart));	//wendy guo 3/29/2007
#else
	VIM_HIF_SetReg32(V5_REG_SIF_VREF_STOP, (UINT32)(SensorOutputSize.cy + wVStart));	//wendy guo 3/29/2007
#endif

#if(BOARD_TYPE==VC0820_FPGA)
#else
	VIM_HIF_SetReg32(V5_REG_ISP_IMG_WIDTH, (UINT32)SensorOutputSize.cx);
	VIM_HIF_SetReg32(V5_REG_ISP_IMG_HEIGHT, (UINT32)SensorOutputSize.cy);
#if VIM_SENSOR_HAVE_BAYER

	VIM_HIF_SetReg8(V5_REG_ISP_AEAWB_WIN_HPOS_0_3,0);	
	VIM_HIF_SetReg8(V5_REG_ISP_AEAWB_WIN_VPOS_0_3,0);		
	for(i=1;i<5;i++)
	{
		VIM_HIF_SetReg8(V5_REG_ISP_AEAWB_WIN_HPOS_0_3+i,(UINT8) (SensorOutputSize.cx/64));	
		VIM_HIF_SetReg8(V5_REG_ISP_AEAWB_WIN_VPOS_0_3+i,(UINT8) (SensorOutputSize.cy/64));	
	}
	
#endif
#endif



	/*config sensor's mclk ratio sensor's clk = SIF's clk / (sel+1)*/
#if(BOARD_TYPE==VC0820_FPGA)
	VIM_HIF_SetReg8(V5_REG_SIF_SNRCLK_CNT, (UINT8)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrclkratio);//wendy guo 3/29/2007
//#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
		VIM_USER_PrintDec("[VC0578B][SIF]:V5_REG_SIF_SNRCLK_CNT =",VIM_HIF_GetReg8(V5_REG_SIF_SNRCLK_CNT));
//#endif
	/*config sensor's output pixel clk ratio  pixel's clk = SIF's clk / (sel+1)*/
	VIM_HIF_SetReg8(V5_REG_SIF_PIXRATE_SEL, (UINT8)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrpixelratio);//wendy guo 3/29/2007
#else
	VIM_HIF_SetReg8(V5_REG_SIF_SNRCLK_CNT, (UINT32)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrclkratio);//wendy guo 3/29/2007
//#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
		VIM_USER_PrintDec("[VC0578B][SIF]:V5_REG_SIF_SNRCLK_CNT =",VIM_HIF_GetReg32(V5_REG_SIF_SNRCLK_CNT));
//#endif
	/*config sensor's output pixel clk ratio  pixel's clk = SIF's clk / (sel+1)*/
	VIM_HIF_SetReg32(V5_REG_SIF_PIXRATE_SEL, (UINT32)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrpixelratio);//wendy guo 3/29/2007

#endif
#if (BOARD_TYPE==VC0820_FPGA)
#else	
	//isp  init parameters
	for(i = 0; i < pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].visp.len; i++)
	{
		VIM_HIF_SetReg32((UINT32)(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].visp.regval[i].adr), 
			(UINT32)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].visp.regval[i].val);//wendy guo 3/29/2007
		VIM_USER_DelayMs(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].visp.regval[i].wait);
	}
#endif
	taeadjust->maxet=pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].maxet;

	if(pSensorInfo->snrrst)
   		VIM_SIF_SensorReset();
	/*for(i = 0; i < pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snr.len ; i++)
	{
		pSensorInfo->snrSetRegCall((UINT32)(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snr.regval[i].adr), 
			(UINT16)pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snr.regval[i].val);
		VIM_USER_DelayMs(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snr.regval[i].wait);
	}*/

	for(i = 0; i < pSensorInfo->snrSizeCfgforVideoRecorder.pSizeCfg[byResolution].snr.len ; i++)
	{
		pSensorInfo->snrSetRegCall((UINT32)(pSensorInfo->snrSizeCfgforVideoRecorder.pSizeCfg[byResolution].snr.regval[i].adr), 
			(UINT16)pSensorInfo->snrSizeCfgforVideoRecorder.pSizeCfg[byResolution].snr.regval[i].val);
		VIM_USER_DelayMs(pSensorInfo->snrSizeCfgforVideoRecorder.pSizeCfg[byResolution].snr.regval[i].wait);
	}
	

	if(SENSOR_TYPE_RGB == pSensorInfo->snrtype)	
	{
#if VIM_SENSOR_HAVE_BAYER
		VIM_SIF_IspSetExposeTime(pSensorInfo,taeadjust,byResolution);
#endif
	}
	
	return VIM_SUCCEED;
}

#if (BOARD_TYPE==VC0820_FPGA)
VIM_RESULT VIM_SIF_SetSensorReg(const TSnrInfo *pSensorInfo,UINT32 regaddr,UINT16 regvalue)	
{
	if (NULL == pSensorInfo)
	{
#if((VIM_5XRDK_ERROR)&&(VIM_SIF_DEBUG))
		VIM_USER_PrintString("[VC0578B][SIF]:Sensor_NoInformation[ERROR]");
#endif
		return VIM_ERROR_SENSOR_NOINFO;
	}
	//VIM_HIF_ResetSubModule(VIM_HIF_RESET_SIF);				//Reset the SIF module by software 
	/*VIM_SIF_SifInitI2c(gVc0578b_Info.pSensorInfo,
#if (BOARD_TYPE==FPGA)
			6000);
#else
			VIM_HIF_GetMclock()); // Init i2c
#endif*/
		
	pSensorInfo->snrSetRegCall(regaddr,regvalue);
	VIM_USER_DelayMs(5);

	return VIM_SUCCEED;
}

VIM_RESULT VIM_SIF_GetSensorReg(const TSnrInfo *pSensorInfo,UINT32 regaddr,UINT16 *regvalue)	
{
	
	if (NULL == pSensorInfo)
	{
#if((VIM_5XRDK_ERROR)&&(VIM_SIF_DEBUG))
		VIM_USER_PrintString("[VC0578B][SIF]:Sensor_NoInformation[ERROR]");
#endif
		return VIM_ERROR_SENSOR_NOINFO;
	}
	//VIM_HIF_ResetSubModule(VIM_HIF_RESET_SIF);				//Reset the SIF module by software 
	VIM_SIF_SifInitI2c(gVc0578b_Info.pSensorInfo,
#if (BOARD_TYPE==FPGA)
			6000);
#else
			VIM_HIF_GetMclock()); // Init i2c
#endif	
	pSensorInfo->snrGetRegCall(regaddr,regvalue);
	//VIM_USER_DelayMs(5);

	return VIM_SUCCEED;
}
#endif

VIM_RESULT VIM_SIF_GetSensorResolution(
	const TSnrInfo *pSensorInfo, 				/*(IN)	The pointer to TSensorInfo structure*/
	VIM_SIF_RESOLUTION bySensorResolution, 	/*(IN)	The sensor's resolution:VIM_SIF_MAXPIXEL or VIM_SIF_HALFPIXEL*/
	TSize *InputSize							/*(IN)(OUT)	output the sensor resolution*/
)
{
	if (NULL == pSensorInfo)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
		VIM_USER_PrintString("[VC0578B][SIF]:Sensor_No information[ERROR]");
		#endif
		return VIM_ERROR_SENSOR_NOINFO;
	}

	
	
	if ((bySensorResolution > VIM_SIF_HALFHALFPIXEL))
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_Resolution larger than sensor size[ERROR]");
		#endif
		return VIM_ERROR_SENSOR_RESOLUTION;
	}

	
	

	if (NULL == InputSize)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_Input size is NULL[ERROR]");
		#endif
		return VIM_ERROR_SENSOR_INPUTSIZE;
	}

	
	*InputSize = pSensorInfo->snrSizeCfg.pSizeCfg[bySensorResolution].size;	//Why input *InputSize, and then output *InputSize????

	return VIM_SUCCEED;
}

/*void VIM_SIF_SetTailBlank(UINT32 x)
{
	VIM_HIF_SetReg8(V5_REG_ISP_TAIL_BLANK_L, (UINT8)(x & 0xff));
	VIM_HIF_SetReg8(V5_REG_ISP_TAIL_BLANK_M, (UINT8)((x >> 8) & 0xffff));
}*/
/********************************************************************************
* Description:
*	change clock
*	
* Parameters:
*	const TSnrInfo *pSensorInf: The pointer to TSnrInfo  structure.
*	Type: Sensor CLK type is VIM_SIF_SENSOR_CLKNORMAL or VIM_SIF_SENSOR_HALF	
		
*				
* Return:
*	TRUE: 	Set SIF success.
*	FALSE:	 pSensorInfo is NULL 
* Note:
*	
**********************************************************************************/
VIM_RESULT VIM_SIF_SetSensorClk(
	const TSnrInfo *pSensorInfo,			/*(IN)	The pointer to TSensorInfo structure*/
	VIM_SIF_CLKTYPE Type				/*(IN)	The sensor's CLK type*/
)
{
	UINT8 byResolution,bCratio,bPratio,div=1;//default rgb;
	UINT16 wWidth,wHeigth;
	//wWidth=VIM_HIF_GetReg16(V5_REG_ISP_IMG_W);
	VIM_IPP_GetImageSize(&wWidth,&wHeigth);
	for(byResolution=0;byResolution<pSensorInfo->snrSizeCfg.len;byResolution++)
	{
		if(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].size.cx==wWidth)
			break;
	}
	if(byResolution==pSensorInfo->snrSizeCfg.len)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_Resolution larger than sensor size[ERROR]");
		#endif
		return VIM_ERROR_SENSOR_NOROSELUTION;
	}
	
	
	bCratio=pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrclkratio;
	bPratio=pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrpixelratio;
	//if(pSensorInfo->snrtype)	//pSensorInfo->snrtype=1, means YUV type  //angela 2007-6-21 remove it
		div=2;
	div*=Type;
	bCratio = ((bCratio + 1) << div) - 1;
	bPratio = ((bPratio + 1) << div) - 1;	
#if (BOARD_TYPE==VC0820_FPGA)	
	if(VIM_HIF_GetReg8(V5_REG_SIF_SNRCLK_CNT)!=(UINT8)bCratio)			//wendy guo 3/29/2007
		VIM_HIF_SetReg8(V5_REG_SIF_SNRCLK_CNT, (UINT8)bCratio);
	if(VIM_HIF_GetReg8(V5_REG_SIF_PIXRATE_SEL)!=(UINT8)bPratio)
		VIM_HIF_SetReg8(V5_REG_SIF_PIXRATE_SEL, (UINT8)bPratio);
#else
	if(VIM_HIF_GetReg32(V5_REG_SIF_SNRCLK_CNT)!=(UINT32)bCratio)			//wendy guo 3/29/2007
		VIM_HIF_SetReg32(V5_REG_SIF_SNRCLK_CNT, (UINT32)bCratio);
	if(VIM_HIF_GetReg32(V5_REG_SIF_PIXRATE_SEL)!=(UINT32)bPratio)
		VIM_HIF_SetReg32(V5_REG_SIF_PIXRATE_SEL, (UINT32)bPratio);
#endif
#if (BOARD_TYPE==VC0820_FPGA)
#else
	if(div)
		VIM_HIF_SetReg32(V5_REG_ISP_TAILBLANK,(UINT32)(wWidth << (div)));
	else
		VIM_HIF_SetReg32(V5_REG_ISP_TAILBLANK,0x20);
#endif		
	return VIM_SUCCEED;
}


/********************************************************************************
* Description:
*	 SIF config  sequence  when sensor is power on
*	
* Parameters:
*	const TSnrInfo *pSensorInf: 
		The pointer to TSnrInfo  structure.
*				
* Return:
*	TRUE: 	Set SIF success.
*	FALSE:	 pSensorInfo is NULL 
* Note:
*	
**********************************************************************************/
VIM_RESULT VIM_SIF_SetSensorPowerOn(
	const TSnrInfo *pSensorInfo			/*(IN)	The pointer to TSensorInfo structure*/
)
{
	//UINT8 byMode;
	int  i = 0;
	if (NULL == pSensorInfo)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_No information[ERROR]");
		#endif
	
		return VIM_ERROR_SENSOR_NOINFO;
	}

	
	
	for(i = 0; i < pSensorInfo->sifpwronseq.len;i++)
	{
		VIM_HIF_SetReg32((UINT32)(pSensorInfo->sifpwronseq.regval[i].adr | V5_REG_SIF_BASE), (UINT32)pSensorInfo->sifpwronseq.regval[i].val);//wendy guo 3/29/2007
		VIM_USER_DelayMs(pSensorInfo->sifpwronseq.regval[i].wait);
	}
	return VIM_SUCCEED;
}



/********************************************************************************
* Description:
*	 SIF config  sequence  when sensor is standby
*	
* Parameters:
*	const TSnrInfo *pSensorInfo *: 
		The pointer to TSensorInfo  structure.
*				
* Return:
*	TRUE: 	Set SIF success.
*	FALSE:	 pSensorInfo is NULL or byResolution is not (VGA or SXGA  QXGA...).
* Note:
*	
**********************************************************************************/
static VIM_RESULT VIM_SIF_SetSensorStandby(
	const TSnrInfo *pSensorInfo			/*(IN)	The pointer to TSensorInfo structure*/
)
{
	int  i = 0;
	if (NULL == pSensorInfo)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_No information[ERROR]");
		#endif
	
		return VIM_ERROR_SENSOR_NOINFO;
	}

	
	
	for(i = 0; i < pSensorInfo->sifstdbyseq.len ; i++)
	{
		VIM_HIF_SetReg32((UINT32)(pSensorInfo->sifstdbyseq.regval[i].adr | V5_REG_SIF_BASE), (UINT32)pSensorInfo->sifstdbyseq.regval[i].val);//wendy guo 3/29/2007
		VIM_USER_DelayMs(pSensorInfo->sifstdbyseq.regval[i].wait);
	}
	return VIM_SUCCEED;
}
/********************************************************************************
* Description:
*	Set sensor state (power on, power off, standby and sleep)
* Parameters:
*	pSensorInfo: 	The pointer to TSensorInfo structure.
*	bySensorState:
*		SENSOR_POWERON,
*		SENSOR_POWEROFF,
*		SENSOR_STANDBY,
*		SENSOR_SLEEP
*	byResolution: Sensor Resolution: VGA or SXGA, used only on 	SENSOR_POWERON state.
* Return:
*	TRUE:	Set sensor state success
*	FALSE:	 pSensorInfo is NULL or bySensorState is unknown or byResolution is not VGA or SXGA
* Note:
*	
**********************************************************************************/
VIM_RESULT VIM_SIF_SetSensorState(
	const TSnrInfo *pSensorInfo, 			/*(IN)	The pointer to TSensorInfo structure*/
	VIM_SIF_SENSORSTATE bySensorState	/*(IN)	The sensor state parmeter*/
)
{
	int i = 0;	
	TRegGroup RegGroup;

	if (NULL == pSensorInfo)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_No information[ERROR]");
		#endif
	
		return VIM_ERROR_SENSOR_NOINFO;
	}
	
	
	
		
	switch(bySensorState)
	{
		case VIM_SIF_SENSOR_POWERON:
			VIM_SIF_SetSensorPowerOn(pSensorInfo);

			if (pSensorInfo->snrrst) // When switch resolution, whether need to reset sensor.
			{
				VIM_SIF_SensorReset();
			}
			RegGroup = pSensorInfo->Initpoweron;//pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snr;
			break;
		case VIM_SIF_SENSOR_STANDBY:
			RegGroup = pSensorInfo->standby;
			break;
		/*case VIM_SIF_SENSOR_SLEEP:
			RegGroup = pSensorInfo->sleep;
			break;
		case VIM_SIF_SENSOR_POWEROFF:
			RegGroup = pSensorInfo->poweroff;
			break;*/
		default:
			break;
	}

	if (	pSensorInfo->snrIdChkCall() != SUCCEED)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:I2C [ERROR]");
		#endif
		return VIM_ERROR_SENSOR_STATE;
	}

	for(i = 0; i < RegGroup.len; i++)
	{
		pSensorInfo->snrSetRegCall((UINT32)RegGroup.regval[i].adr, (UINT16)RegGroup.regval[i].val);
		VIM_USER_DelayMs(RegGroup.regval[i].wait);
	}

	//if ((VIM_SIF_SENSOR_POWEROFF == bySensorState)|(VIM_SIF_SENSOR_STANDBY == bySensorState)|
		//(VIM_SIF_SENSOR_SLEEP == bySensorState))
	if (VIM_SIF_SENSOR_STANDBY == bySensorState)
	{
		VIM_SIF_SetSensorStandby(pSensorInfo);
	}

	return VIM_SUCCEED;
}


/********************************************************************************
* Description:
*	Reset sensor 
* Parameters:
*	None
* Return:
*	None
* Note:
*	Sensor reset when V5_REG_SIF_SNR_MODE bit0 changes from 1 to 0 or 0 to 1.
**********************************************************************************/
void VIM_SIF_SensorReset(void)
{
	UINT32 byMode;				//wendy guo 3/29/2007
	
	byMode = VIM_HIF_GetReg32(V5_REG_SIF_SNR_MODE);//wendy guo 3/29/2007
	if(byMode & BIT0)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_MODE, byMode & (~BIT0));
	}
	else
	{
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_MODE, byMode | BIT0);
	}

	VIM_USER_DelayMs(20);
	VIM_HIF_SetReg32(V5_REG_SIF_SNR_MODE, byMode);
	VIM_USER_DelayMs(20);
}



/********************************************************************************
* Description:
*	 Enable/Disable sync signal to ISP and IPP.
* Parameters:
*	bEnable: 
*		TRUE: Enable
*		FALSE: Disable
* Return:
*	void
* Note:
*	1. Set V5_REG_SIF_SNROP_MODE bit6
*	2. When disable sync generate, ISP and IPP will not work.
**********************************************************************************/
void VIM_SIF_EnableSyncGen(
	UINT8 bEnable			/*(IN)	 enable output sync signals to ISP */
)
{
	UINT32 byMode;			//wendy guo 3/29/2007
	UINT8 byEn=0;		//angela added it
	byMode = VIM_HIF_GetReg32(V5_REG_SIF_SNROP_MODE);	//wendy guo 3/29/2007
	byEn=(byMode>>6)&1;
	if(bEnable)
	{
		byMode |= BIT6;
	}
	else
	{
		byMode &= ~BIT6;
	}

	VIM_HIF_SetReg32(V5_REG_SIF_SNROP_MODE, byMode);
	if(byEn&&(bEnable==DISABLE))
		VIM_USER_DelayMs(200);    //ANGELA 2007-5-15 because of display problem
}


void VIM_SIF_StartCaptureEnable(
	UINT8 bEnable			/*(IN)	stare the capture*/
)
{
	UINT32 byMode;			//wendy guo 3/29/2007
	
	byMode = VIM_HIF_GetReg32(V5_REG_SIF_SNROP_MODE);
	if(bEnable)
	{
		byMode |= BIT6|BIT7;
	}
	else
	{
		byMode &=~BIT7;
	}

	VIM_HIF_SetReg32(V5_REG_SIF_SNROP_MODE, byMode);

}

/********************************************************************************
  Description:
    	设置PWM
  Parameters:
  	Enable
  Returns:
  	void
  Remarks: 
*********************************************************************************/
void VIM_SIF_SetPwmInit(VIM_SIF_PWM_NUM Num,VIM_SIF_PWM_POL Pro)
{
	UINT32 temp;
	temp=VIM_HIF_GetReg32(V5_REG_PAD_SIFFLASH_CTRL);
	temp&=(~(BIT0|BIT1));
	temp|=Num;
	VIM_HIF_SetReg32(V5_REG_PAD_SIFFLASH_CTRL,temp);
#if(BOARD_TYPE==VC0820_FPGA)	
	{
		UINT32 tmp;
		tmp = VIM_HIF_GetReg32(V5_REG_SIF_FL_PWM_REG);
		tmp &=~(0x3<<4);
		tmp |=((0x2|Pro)<<4);
		VIM_HIF_SetReg32(V5_REG_SIF_FL_PWM_REG,0x2|Pro);
	}	
#else
	VIM_HIF_SetReg32(V5_REG_SIF_FL_POLARITY,0x2|Pro);
#endif
}

/********************************************************************************
  Description:
    	设置PWM
  Parameters:
  	Enable
  Returns:
  	void
  Remarks: 
*********************************************************************************/
void VIM_SIF_SetPwmEn(BOOL Enable)
{
	UINT32 temp;
#if(BOARD_TYPE==VC0820_FPGA)	
	temp=VIM_HIF_GetReg32(V5_REG_SIF_FL_PWM_REG);
	if (Enable==ENABLE)
		temp|=(BIT0|BIT1);
	else
		temp&=(~BIT0);
	VIM_HIF_SetReg32(V5_REG_SIF_FL_PWM_REG,temp);
#else
	temp=VIM_HIF_GetReg32(V5_REG_SIF_FL_PWM_EN);
	if (Enable==ENABLE)
		temp|=(BIT0|BIT1);
	else
		temp&=(~BIT0);
	VIM_HIF_SetReg32(V5_REG_SIF_FL_PWM_EN,temp);
#endif

}

/********************************************************************************
  Description:
    	设置PWM duty
  Parameters:
	Duty:MIN is 2 max is 99
  Returns:
  	void
  Remarks: 
*********************************************************************************/
void VIM_SIF_SetPwmDuty(UINT8 Duty,UINT8 Max)
{
	UINT32 temp;
#if (BOARD_TYPE==VC0820_FPGA)
	temp=VIM_HIF_GetReg16(V5_REG_SIF_FL_PWM_CNT_TGT);
	temp/=Max;
	temp*=Duty;
	VIM_HIF_SetReg16(V5_REG_SIF_FL_PWM_CNT_TGT+2,(UINT16)temp);
#else
	temp=VIM_HIF_GetReg32(V5_REG_SIF_FL_PWM_CNT_TGT);
	temp/=Max;
	temp*=Duty;
	
	VIM_HIF_SetReg32(V5_REG_SIF_FL_PWM_CNT_DUTY,(UINT32)temp);
	//VIM_HIF_SetReg32(V5_REG_SIF_FL_DUTY,(UINT32)Duty);
#endif
}

/********************************************************************************
  Description:
    	设置PWM clock
  Parameters:
	khz
  Returns:
  	void
  Remarks: 
*********************************************************************************/
void VIM_SIF_SetPwmClock(UINT32 Clock)
{
UINT32 Mlock;
	Mlock=VIM_HIF_GetMclock();
	Mlock/=Clock;
	VIM_HIF_SetReg32(V5_REG_SIF_FL_PWM_CNT_TGT,Mlock);
}


/********************************************************************************
		I2C bus operation
*********************************************************************************/

/********************************************************************************
  Description:
	config I2C bus device address
  Parameters:
	adr: I2C bus device address
  Return:
  	SUCCEED/FAILED
  Remarks:
*********************************************************************************/
void VIM_SIF_SetI2cDevAddr(
	UINT16 addr			/*(IN)	the address of I2C slave device's register*/
)
{
	UINT32 state;
	if(addr>>15)
	{
		state = VIM_HIF_GetReg32(V5_REG_SIF_IIC_DADDRTEN_FLAG);
		state |= BIT2;//Set 设置Flag
		state = state>>2;
		state = state<<2;
		state |= BIT1;//设备地址是2个字节
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_DADDRTEN_FLAG, state);
#if(BOARD_TYPE==VC0820_FPGA)
		{
			UINT32 temp;
			temp = VIM_HIF_GetReg32(V5_REG_SIF_IIC_DADDRTEN_FLAG);	
			temp &= ~0x3ff;
			temp |= (addr&0x3ff);
			VIM_HIF_SetReg32(V5_REG_SIF_IIC_DADDRTEN_FLAG, temp);
		}	
#else
		VIM_HIF_SetReg32(V5_REG_SIF_DADDR_TEN, (UINT32)(addr&0x7FFF));		//wendy guo 3/29/2007		
#endif
	}
	else
	{
#if(BOARD_TYPE==VC0820_FPGA)	
		state = VIM_HIF_GetReg32(V5_REG_SIF_IIC_CFG);
		//state &= (~BIT2);//Clear 清楚Flag
		state = state>>2;
		state = state<<2;
		state |= (BIT0|BIT2);//设备地址是1个字节
		VIM_HIF_SetReg8(V5_REG_SIF_IIC_CFG, state);
#else
		state = VIM_HIF_GetReg8(V5_REG_SIF_IIC_DADDRTEN_FLAG);
		state &= (~BIT2);//Clear 清楚Flag
		state = state>>2;
		state = state<<2;
		state |= BIT0;//设备地址是1个字节
		VIM_HIF_SetReg8(V5_REG_SIF_IIC_DADDRTEN_FLAG, state);
#endif

#if(BOARD_TYPE==VC0820_FPGA)
		{
			UINT32 temp;
			temp = VIM_HIF_GetReg32(V5_REG_SIF_IIC_CFG);	
			temp &= ~(0x7f<<8);
			temp |= ((addr&0x7f)<<8);
			VIM_HIF_SetReg32(V5_REG_SIF_IIC_CFG, temp);
		}	
#else
		addr >>= 1;
		addr |= 0x80;					//b7=1, means check ACK bit,if the sensor have no ACK,must stop conmunication of I2C at once 
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_DEVADDR, (UINT32)addr);		//wendy guo 3/29/2007
#endif		
	}
	
}


/********************************************************************************
  Description:
	I2C write function 
  Parameters:
	byAddr: the address of I2C slave device's register
	byVal: value
  Return:
  	SUCCEED/FAILED
  Remarks:
*********************************************************************************/
UINT16 VIM_SIF_I2cWriteByte(
	UINT32 byAddr, 
	UINT8 byVal,						////wendy guo 3/29/2007
	UINT8 num
)
{
	UINT32 uState = 0;				//wendy guo 3/29/2007
	UINT32	count = I2C_WRDELAY;
	
	while(count--)
	{
		uState = VIM_HIF_GetReg32(V5_REG_SIF_BUS_STATE);		//wendy guo 3/29/2007
		if((uState&0x12==0x2))		//angela change it 
		{
			break;
		}
	}
	
	if(!count)
		return FAILED;
	if(num==1)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x01);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)byAddr);
	}
	else if(num==2)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x02);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)((byAddr&0xff00)>>8));
		uState = (byAddr&0xFF);
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_ADDR_LH, uState);
#else
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR_L, uState);
#endif
	}
	else if(num==3)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x03);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)((byAddr&0xff00)>>8));
		
		uState =( (byAddr&0xFF) | ((byAddr>>8)&0xFF00) );
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_ADDR_LH, uState);
#else
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR_L, uState);
#endif
	}
	else
	{
		return 0;
	}



	VIM_HIF_SetReg32(V5_REG_SIF_SNRWRDATA, (UINT32)byVal<<16);			// V5_REG_SIF_SNRWRDATA reg have 3 Bytes to store the data value
#if (BOARD_TYPE==VC0820_FPGA)
{
	UINT32 temp;
	temp = VIM_HIF_GetReg32(V5_REG_SIF_IIC_CFG);
	temp &=~(0x3);
	temp |=1;
	VIM_HIF_SetReg32(V5_REG_SIF_IIC_CFG, temp);
}
#else
	VIM_HIF_SetReg32(V5_REG_SIF_IIC_BYTE, 1);
#endif
	VIM_HIF_SetReg32(V5_REG_SIF_SNRACSCTR, 0x1);

	return SUCCEED;
}

/********************************************************************************
  Description:
	I2C write function
  Parameters:
	uAddr: the address of I2C slave device's register 
	uVal: value
  Return:
  	SUCCEED/FAILED
  Remarks:
*********************************************************************************/
UINT16 VIM_SIF_I2cWriteWord(
	UINT32 uAddr, 			/*(IN)	the address of I2C slave device's register*/
	UINT16 uVal,				/*(IN)	the value of I2C slave device's register*/	//wendy guo 3/29/2007 changed from UINT16 to UINT32
	UINT8 num
)
{
	UINT32 uState = 0;		//wendy guo 3/29/2007
	UINT32	count = I2C_WRDELAY;
	

	while(count--)
	{
		uState = VIM_HIF_GetReg32(V5_REG_SIF_BUS_STATE);
		if((uState&0x12==0x2))		//angela change it 
		{
			break;
		}
	}

	if(!count)
		return FAILED;
	
	if(num==1)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x01);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)uAddr);
	}
	else if(num==2)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x02);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)((uAddr&0xff00)>>8));
		uState = (uAddr&0xFF);
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_ADDR_LH, uState);
#else
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR_L, uState);
#endif
	}
	else if(num==3)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x03);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)((uAddr&0xff00)>>8));
		
		uState =( (uAddr&0xFF) | ((uAddr>>8)&0xFF00) );
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_ADDR_LH, uState);
#else
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR_L, uState);
#endif
	}
	else
	{
		return 0;
	}
	
	VIM_HIF_SetReg32(V5_REG_SIF_SNRWRDATA, (UINT32)(uVal<<8));			//wendy guo 3/29/2007//data bit =24bit
#if (BOARD_TYPE==VC0820_FPGA)
{
	UINT32 temp;
	temp = VIM_HIF_GetReg32(V5_REG_SIF_IIC_CFG);
	temp &=~(0x3);
	temp |=2;
	VIM_HIF_SetReg32(V5_REG_SIF_IIC_CFG, temp);
}
#else
	VIM_HIF_SetReg32(V5_REG_SIF_IIC_BYTE, 2);
#endif
	VIM_HIF_SetReg32(V5_REG_SIF_SNRACSCTR, 0x1);


	return SUCCEED;
}



/********************************************************************************
  Description:
	I2C read function
  Parameters:
	byAddr:		the address of I2C slave device's register 
	pbyVal:		return the value of this register
  Returen:
 	SUCCEED/FAILED and pbyVal
  Remarks:
*********************************************************************************/
UINT16 VIM_SIF_I2cReadByte(
	UINT32 byAddr, 			/*(IN)	the address of I2C slave device's register*/
	UINT8 *pbyVal,			/*(IN)(OUT)	the value of I2C slave device's register*/
	UINT8 num
)
{
	UINT32 uState = 0;		//wendy guo 3/29/2007
	UINT32	count = I2C_WRDELAY;
	
	while(count--)
	{
		uState = VIM_HIF_GetReg32(V5_REG_SIF_BUS_STATE);
		if((uState&0x12==0x2))		//angela change it 
		{
			break;
		}
	}
	if(!count)
		return FAILED;

	if(num==1)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x01);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)byAddr);
	}
	else if(num==2)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x02);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)((byAddr&0xff00)>>8));
		uState = (byAddr&0xFF);
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_ADDR_LH, uState);
#else
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR_L, uState);
#endif
	}
	else if(num==3)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x03);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)((byAddr&0xff00)>>8));
		
		uState =( (byAddr&0xFF) | ((byAddr>>8)&0xFF00) );
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_ADDR_LH, uState);
#else
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR_L, uState);
#endif
	}
	else
	{
		return 0;
	}

	
#if (BOARD_TYPE==VC0820_FPGA)
{
	UINT32 temp;
	temp = VIM_HIF_GetReg32(V5_REG_SIF_IIC_CFG);
	temp &=~(0x3);
	temp |=1;
	VIM_HIF_SetReg32(V5_REG_SIF_IIC_CFG, temp);
}
#else
	VIM_HIF_SetReg32(V5_REG_SIF_IIC_BYTE, 1);
#endif
	VIM_HIF_SetReg32(V5_REG_SIF_SNRACSCTR, 0x2);


	count = I2C_WRDELAY;
	while(count--)
	{
		uState = VIM_HIF_GetReg32(V5_REG_SIF_BUS_STATE);
		if((uState&0x12==0x2))		//angela change it 
		{	
			break;
		}
	}
	if(!count)
		return FAILED;
	

//	*pbyVal = (UINT8)(VIM_HIF_GetReg32(V5_REG_SIF_SNRRDDATA));			////angela

	uState = VIM_HIF_GetReg32(V5_REG_SIF_SNRRDDATA);			////angela
	*pbyVal = (UINT8)(uState>>16);
	
	return SUCCEED;
}

/********************************************************************************
  Description:
	I2C read function
  Parameters:
	uAddr:		the address of I2C slave device's register 
	uVal:		return the value of this register
  Returen: 
  	SUCCEED/FAILED and uVal
  Remarks:
*********************************************************************************/
UINT16 VIM_SIF_I2cReadWord(
	UINT32 uAddr, 			/*(IN)	the address of I2C salve device's register*/
	UINT16 *uVal,				/*(IN)(OUT)	the device's register value*/		//wendy guo 3/29/2007	
	UINT8 num
)
{
	UINT32 uState = 0;		//wendy guo 3/29/2007

	UINT32	count = I2C_WRDELAY;
	
	count = I2C_WRDELAY;
	while(count--)
	{
		uState = VIM_HIF_GetReg32(V5_REG_SIF_BUS_STATE);
		if((uState&0x12==0x2))
		{
			break;
		}
	}

	if(!count)
		return FAILED;

	if(num==1)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x01);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)uAddr);
	}
	else if(num==2)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x02);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)((uAddr&0xff00)>>8));
		uState = (uAddr&0xFF);
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_ADDR_LH, uState);
#else
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR_L, uState);
#endif
	}
	else if(num==3)
	{
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE, (UINT32)0x03);
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR, (UINT32)((uAddr&0xff00)>>8));
		
		uState =( (uAddr&0xFF) | ((uAddr>>8)&0xFF00) );
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetReg32(V5_REG_SIF_SNR_ADDR_LH, uState);
#else
		VIM_HIF_SetReg32(V5_REG_SIF_SNRADDR_L, uState);
#endif
	}
	else
	{
		return 0;
	}

#if (BOARD_TYPE==VC0820_FPGA)
{
	UINT32 temp;
	temp = VIM_HIF_GetReg32(V5_REG_SIF_IIC_CFG);
	temp &=~(0x3);
	temp |=2;
	VIM_HIF_SetReg32(V5_REG_SIF_IIC_CFG, temp);
}
#endif
	VIM_HIF_SetReg32(V5_REG_SIF_SNRACSCTR, (UINT32)0x2);
	count = I2C_WRDELAY;
	while(count--)
	{
		uState = VIM_HIF_GetReg32(V5_REG_SIF_BUS_STATE);
		if((uState&0x12==0x2))		//angela change it 
		{
			break;
		}
	}

	if(!count)
		return FAILED;
	*uVal = (UINT16)(VIM_HIF_GetReg32(V5_REG_SIF_SNRRDDATA)>>8);			////angela change to >>8
	return SUCCEED;
}




/********************************************************************************
  Description:
	I2C bus batch write 
  Parameters:
	uNum: AeData length, must in [0, 7]
	AeData: data
  Return:
  	void
  Note:
	The write data number must same at every register's address
	The update time is according to Ae Window's setting
  Remarks:
*********************************************************************************/
void VIM_SIF_I2cAeBatch(
	UINT8 uNum, 			/*(IN)	the number of write data*/
	TI2cBatch *AeData,		/*(IN)	the structure of AE data,include reg bytes, reg addr, reg value*/
	UINT8 addrbyte
)
{
	UINT8	i, j, reg_B_ctrl = 0;
	UINT8	uRegAeCount = 0;
	UINT16	regCnt, reg_B_cnt = 0;


	
	if((uNum > 0) && (uNum < 8))
	{
		for(i = 0; i < uNum; i++)
		{
			regCnt = AeData[i].RegBytes & 0x3;
			regCnt <<= i*2;
			reg_B_cnt |= regCnt;

			if(addrbyte==1)
			{
				VIM_HIF_SetReg8(V5_REG_SIF_AE0_DATA_0_3+uRegAeCount, (UINT8)(AeData[i].RegAddr));
				uRegAeCount++;
			
				if(uRegAeCount%4==0)
					uRegAeCount+=12;
			}

			else if(addrbyte==2)
			{
				VIM_HIF_SetReg8(V5_REG_SIF_AE0_DATA_0_3+uRegAeCount, (UINT8)(AeData[i].RegAddr>>8));
				uRegAeCount++;
				
				if(uRegAeCount%4==0)
					uRegAeCount+=12;

				VIM_HIF_SetReg8(V5_REG_SIF_AE0_DATA_0_3+uRegAeCount, (UINT8)(AeData[i].RegAddr));
				uRegAeCount++;
			
				if(uRegAeCount%4==0)
					uRegAeCount+=12;
				
			}
			
			else if(addrbyte==3)
			{
				VIM_HIF_SetReg8(V5_REG_SIF_AE0_DATA_0_3+uRegAeCount, (UINT8)(AeData[i].RegAddr>>16));
				uRegAeCount++;
				
				if(uRegAeCount%4==0)
					uRegAeCount+=12;


				VIM_HIF_SetReg8(V5_REG_SIF_AE0_DATA_0_3+uRegAeCount, (UINT8)(AeData[i].RegAddr>>8));
				uRegAeCount++;
				
				if(uRegAeCount%4==0)
					uRegAeCount+=12;

				VIM_HIF_SetReg8(V5_REG_SIF_AE0_DATA_0_3+uRegAeCount, (UINT8)(AeData[i].RegAddr));
				uRegAeCount++;
			
				if(uRegAeCount%4==0)
					uRegAeCount+=12;				
			}
			else
			{
				;
			}

			
			for(j = 0; j < AeData[i].RegBytes; j++)
			{
				VIM_HIF_SetReg8(V5_REG_SIF_AE0_DATA_0_3+uRegAeCount, AeData[i].RegVal[j]);				
				uRegAeCount++;
				
				if(uRegAeCount%4==0)
					uRegAeCount+=12;				
			}

		}

		
		VIM_HIF_SetReg32(V5_REG_SIF_IIC_SADDR_BYTE,(UINT32)addrbyte);


		/////?????????????????????????? no use?
		//VIM_HIF_SetReg32(V5_REG_SIF_IIC_BYTE, (UINT32)AeData[0].RegBytes & 0x3);	//wendy guo 3/29/2007



		
		VIM_HIF_SetReg32(V5_REG_SIF_B_CNT, (UINT32)reg_B_cnt);
		
		reg_B_ctrl = uNum;	//The number of register addresses
		reg_B_ctrl |= 0x8;		//AE data update done bit.

		VIM_HIF_SetReg32(V5_REG_SIF_AEBUS_CTRL, (UINT32)reg_B_ctrl);	//wendy guo 3/29/2007
	}
}

/********************************************************************************
  Description:
	Sensor auto focus function
  Parameters:
	const TSnrInfo *pSensorInfo
  Returen:
  	void
  Note:
  	pSensorInfo->flashparm.FlashClockNum=MCLK/charge freqence;
  	pSensorInfo->flashparm.DutyCount=(MCLK/charge)*(1-charge duty);

  	There are 8 array of charge frq and charge duty:
  	charge frq=9khz, charge duty=1/10;
  	charge frq=10khz, chareg duty=1/9;
  	charge frq=11.25khz, chareg duty=1/8;
  	charge frq=12.85khz, chareg duty=1/7;
  	charge frq=15khz, chareg duty=1/6;
  	charge frq=18khz, chareg duty=1/5;
  	charge frq=22khz, chareg duty=1/4;
  	charge frq=30khz, chareg duty=1/3;

  Remarks:
*********************************************************************************/
void	VIM_SIF_AutoFocus(
	const TSnrInfo *pSensorInfo	/*(IN)	The sensore information structure*/
)	
{
#if(BOARD_TYPE!=VC0820_FPGA)
	UINT8 val;

	#if 0
	if (NULL == pSensorInfo)
	{
		#if((VIM_5XRDK_ERROR)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintString("[VC0578B][SIF]:Sensor_No information[ERROR]");
		#endif
	
		return VIM_ERROR_SENSOR_NOINFO;
	}
	#endif
	
	VIM_HIF_SetReg32(V5_REG_SIF_FL_PWM_CNT_TGT, (UINT32)pSensorInfo->flashparm.FlashClockNum);
	VIM_HIF_SetReg32(V5_REG_SIF_FL_PWM_CNT_DUTY, (UINT32)pSensorInfo->flashparm.DutyCount);

	val=BIT0|BIT1;			//bit0=1:Flash power charge enable;;;bit1=1:auto focus enable.
	VIM_HIF_SetReg32(V5_REG_SIF_FL_PWM_EN, (UINT32)val);
	
#endif	
}

/********************************************************************************
  Description:
  	interrupt of SIF
  Parameters:
  Returns:
  	void
  Remarks:
*********************************************************************************/


static 	const UINT8 gSifSifIntPriority[VIM_SIF_SIF_INT_NUM] = 
{ 
	VIM_INT_SIF_VSYNC_INT, VIM_INT_SIF_FRAMEEND
};

void _ISR_SifSifIntHandle(UINT8 wIntFlag)
{
	UINT8 i = 0;
	UINT8 bySecondLevelInt = 0;

	for(i=0; i<VIM_SIF_SIF_INT_NUM; i++)
	{
		bySecondLevelInt = gSifSifIntPriority[i];
		if(TSTINT(wIntFlag, bySecondLevelInt))
		{
			if(gVc0578b_Isr.Sifisr[bySecondLevelInt])
			{
				gVc0578b_Isr.Sifisr[bySecondLevelInt]();
			}
		}
	}
}

/********************************************************************************
  Description:
  	register isr 
  Parameters:
  	bySecondLevelInt:
	VIM_INT_SIF_VSYNC_INT		= 0,
	VIM_INT_SIF_FRAMEEND		= 1,
	VIM_INT_SIF_YMEAN		=2,
	VIM_INT_SIF_ANTIF		=3,
	VIM_INT_SIF_AUTOFOC	=4,
  Returns:
  	void
  Remarks:
*********************************************************************************/

void VIM_SIF_ISP_RegisterISR(VIM_SIF_INT_TYPE bySecondLevelInt, PVIM_Isr  Isr)
{
UINT8 i;
	if(bySecondLevelInt>=VIM_SIF_INT_ALL)
	{
		for(i=0;i<VIM_SIF_INT_ALL;i++)
			gVc0578b_Isr.Sifisr[i] = Isr;
		return;
	}
	gVc0578b_Isr.Sifisr[bySecondLevelInt] = Isr;
}
#if (BOARD_TYPE==VC0820_FPGA)
/********************************************************************************
  Description:
  	enable jpeg interrupt
  Parameters:
  	bySecondLevelInt:
	VIM_INT_SIF_VSYNC_INT		= 0,
	VIM_INT_SIF_FRAMEEND		= 1,
	VIM_INT_SIF_YMEAN		=2,
	VIM_INT_SIF_ANTIF		=3,
	VIM_INT_SIF_AUTOFOC	=4,
  Returns:
  	void
  Remarks:
*********************************************************************************/
void VIM_SIF_ISP_SetIntEnable(VIM_SIF_INT_TYPE bySecondLevelInt,BOOL Eanble)
{
	UINT8 bInten;
	if(bySecondLevelInt<VIM_SIF_INT_ALL)
	{
		bInten=VIM_HIF_GetIntEnableSec(VM_HIF_INT_SIF);
		if(Eanble==ENABLE)
			bInten |= (0x1<<bySecondLevelInt);
		else
			bInten &= (~(0x1<<bySecondLevelInt));	
		VIM_HIF_SetIntEnableSec(VM_HIF_INT_SIF,bInten);
		if(bInten)
			VIM_HIF_SetIntModuleEn(VM_HIF_INT_SIF,ENABLE);
		else
			VIM_HIF_SetIntModuleEn(VM_HIF_INT_SIF,DISABLE);
	}
	else
	{
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetIntEnableSec(VM_HIF_INT_SIF,0x3);
		VIM_HIF_SetIntModuleEn(VM_HIF_INT_SIF,ENABLE);
#else
		VIM_HIF_SetIntEnableSec(VM_HIF_INT_SIF,0xff);
		VIM_HIF_SetIntEnableSec(VM_HIF_INT_ISP,0xff);
		VIM_HIF_SetIntModuleEn(VM_HIF_INT_SIF,ENABLE);
		VIM_HIF_SetIntModuleEn(VM_HIF_INT_ISP,ENABLE);
#endif		
	}


	
}

#else
/********************************************************************************
  Description:
  	enable jpeg interrupt
  Parameters:
  	bySecondLevelInt:
	VIM_INT_SIF_VSYNC_INT		= 0,
	VIM_INT_SIF_FRAMEEND		= 1,
	VIM_INT_SIF_YMEAN		=2,
	VIM_INT_SIF_ANTIF		=3,
	VIM_INT_SIF_AUTOFOC	=4,
  Returns:
  	void
  Remarks:
*********************************************************************************/
void VIM_SIF_ISP_SetIntEnable(VIM_SIF_INT_TYPE bySecondLevelInt,BOOL Eanble)
{
	UINT8 bInten;
	if(bySecondLevelInt<VIM_INT_SIF_YMEAN)
	{
		bInten=VIM_HIF_GetIntEnableSec(VM_HIF_INT_SIF);
		if(Eanble==ENABLE)
			bInten |= (0x1<<bySecondLevelInt);
		else
			bInten &= (~(0x1<<bySecondLevelInt));	
		VIM_HIF_SetIntEnableSec(VM_HIF_INT_SIF,bInten);
		if(bInten)
			VIM_HIF_SetIntModuleEn(VM_HIF_INT_SIF,ENABLE);
		else
			VIM_HIF_SetIntModuleEn(VM_HIF_INT_SIF,DISABLE);
	}
	else if(bySecondLevelInt<VIM_SIF_INT_ALL)
	{
#if (BOARD_TYPE==VC0820_FPGA)
;
#else
		bInten=VIM_HIF_GetIntEnableSec(VM_HIF_INT_ISP);
		if(Eanble==ENABLE)
			bInten |= (0x1<<(bySecondLevelInt-VIM_SIF_SIF_INT_NUM));
		else
			bInten &= (~(0x1<<(bySecondLevelInt-VIM_SIF_SIF_INT_NUM)));	
		VIM_HIF_SetIntEnableSec(VM_HIF_INT_ISP,bInten);
		if(bInten)
			VIM_HIF_SetIntModuleEn(VM_HIF_INT_ISP,ENABLE);
		else
			VIM_HIF_SetIntModuleEn(VM_HIF_INT_ISP,DISABLE);



//added by jiangkeqiang
		VIM_ISP_SetIntEnable(1<<(4-bySecondLevelInt));
#endif		
	}
	else
	{
#if (BOARD_TYPE==VC0820_FPGA)
		VIM_HIF_SetIntEnableSec(VM_HIF_INT_SIF,0x3);
		VIM_HIF_SetIntModuleEn(VM_HIF_INT_SIF,ENABLE);
#else
		VIM_HIF_SetIntEnableSec(VM_HIF_INT_SIF,0xff);
		VIM_HIF_SetIntEnableSec(VM_HIF_INT_ISP,0xff);
		VIM_HIF_SetIntModuleEn(VM_HIF_INT_SIF,ENABLE);
		VIM_HIF_SetIntModuleEn(VM_HIF_INT_ISP,ENABLE);
#endif		
	}


	
}
#endif




/********************************************************************************
  Description:
  	interrupt of lenbuf
  Parameters:
  Returns:
  	void
  Remarks:
*********************************************************************************/
	
#if (BOARD_TYPE==VC0820_FPGA)
#else	

static const UINT8 gSifIspIntPriority[VIM_SIF_ISP_INT_NUM] = { VIM_INT_SIF_YMEAN,
		VIM_INT_SIF_ANTIF,VIM_INT_SIF_AUTOFOC};

 void _ISR_SifIspIntHandle(UINT8 wIntFlag)
{
	UINT8 i = 0;
	UINT8 bySecondLevelInt = 0;

	for(i=0; i<VIM_SIF_ISP_INT_NUM; i++)
	{
		bySecondLevelInt = gSifIspIntPriority[i];
		if(TSTINT(wIntFlag, bySecondLevelInt-VIM_SIF_SIF_INT_NUM))
		{
			if(gVc0578b_Isr.Sifisr[bySecondLevelInt])
			{
				gVc0578b_Isr.Sifisr[bySecondLevelInt]();
			}
		}
	}	
}











static void VIM_ISP_SetIntEnable(UINT8 val)
/*	val:
	bit0=1 auto_foc_int enable
	bit1=1 antif_int enable
	bit2=1 y_mean_int enable;
*/
{
	VIM_HIF_SetReg32(V5_REG_ISP_INTERRUPT,val);
}

#endif

#if (BOARD_TYPE==VC0820_FPGA)
#else	
 static void VIM_SIF_IspToolCalculateNewGammaCurve(const UINT8 * OriginalGammaCurve, 
									SINT16 DeltaContrast, 
									UINT8 * NewGammaCurve	 )
{
	SINT16 deltaGma[17] ;
	SINT16 steps = DeltaContrast ;
	SINT16 i, temp ;

	// step 1: Calculate deltaGma[] based on DeltaContrast
	// for simplicity, all the division is based on 64(can be done by >>8 )
	deltaGma[0] = 0 ;
	deltaGma[1] = - 96 * steps / 64 ;
	deltaGma[3] = - 72 * steps / 64 ;
	deltaGma[6] = 0 ;
	deltaGma[11] = 146 * steps / 64 ;
	deltaGma[16] = 166 * steps / 64 ;
	
	deltaGma[2] = ( deltaGma[1] + deltaGma[3] ) / 2 ;
	
	deltaGma[4] = - 72 * (6-4) * steps / (6-3) / 64 ;
	deltaGma[5] = - 72 * (6-5) * steps / (6-3) / 64 ;
	
	deltaGma[7] =  146 * (7-6) * steps / (11-6) / 64 ;
	deltaGma[8] =  146 * (8-6) * steps / (11-6) / 64 ;
	deltaGma[9] =  146 * (9-6) * steps / (11-6) / 64 ;
	deltaGma[10] = 146 * (10-6) * steps / (11-6) / 64 ;
	
	deltaGma[12] = deltaGma[11] + (deltaGma[16]-deltaGma[11]) * (12-11) / (16-11) ;
	deltaGma[13] = deltaGma[11] + (deltaGma[16]-deltaGma[11]) * (13-11) / (16-11) ;
	deltaGma[14] = deltaGma[11] + (deltaGma[16]-deltaGma[11]) * (14-11) / (16-11) ;
	deltaGma[15] = deltaGma[11] + (deltaGma[16]-deltaGma[11]) * (15-11) / (16-11) ;
	
	// step 2: update deltaGma[] based on DeltaBrightness
/*	for ( i = 0 ; i < 17; i ++ )
		deltaGma[i] += DeltaBrightness * 5 ;
	*/
	// step 3: Calculate NewGammaCurve
	for ( i = 0 ; i < 17; i ++ )
	{
		temp = OriginalGammaCurve[i] + deltaGma[i] ;
		if ( temp < 0 ) 
			temp = 0 ;
		else 
			if ( temp > 255 )
				temp = 255 ;  
			NewGammaCurve[i] = (UINT8)temp ;
	}
}

/********************************************************************************
  Description:
	Set isp brightness and contrast(may be add saturation and chroma
  Parameters:
	byValue:	brightness range [V5_ISP_MIN_BRIGHT_CONTRAST, V5_ISP_MAX_BRIGHT_CONTRAST]
  Returns:
  Note:
  Remarks:
*********************************************************************************/
void VIM_SIF_IspSetContrast(VIM_ISP_TAEADJUST *paeadjust,const TSnrInfo *pSensorInfo,UINT8 byValue)
{
	SINT16 sBrightness;
	SINT16 sContrast;
	UINT8 RegGamma[17],i;
	
	if(byValue > VIM_ISP_MAX_BRIGHT_CONTRAST)
	{
		byValue = VIM_ISP_MAX_BRIGHT_CONTRAST;
	}
	if(byValue < VIM_ISP_MIN_BRIGHT_CONTRAST)
	{
		byValue =VIM_ISP_MIN_BRIGHT_CONTRAST;
	}

	paeadjust->contrast = byValue;

	sBrightness = (SINT16)(paeadjust->brightness) - 32;
	sContrast = (SINT16)(paeadjust->contrast) - 32;

	VIM_SIF_IspToolCalculateNewGammaCurve((const UINT8 *)pSensorInfo->gammaRGB, sContrast, RegGamma);


	for(i=0;i<17;i++)
	{
		VIM_HIF_SetReg8(V5_REG_ISP_RGMAS0_3+i,RegGamma[i]);
		VIM_HIF_SetReg8(V5_REG_ISP_GGMAS0_3+i,RegGamma[i]);
		VIM_HIF_SetReg8(V5_REG_ISP_BGMAS0_3+i,RegGamma[i]);		
	}

	
	VIM_SIF_IspCtrlUpate(0xff);//update all
}

/********************************************************************************
  Description:
	Saturation[7:0]: 8-bit unsigned registers with 8'h40 indicating 1.00. 
	Therefore the saturation is in the range [0,2].

  Parameters:
	byValue:	directly write to the register
  Returns:
  Note:
  Remarks:
*********************************************************************************/
void VIM_SIF_IspSetSaturation(VIM_ISP_TAEADJUST *paeadjust,UINT8 byValue)
{
/*

	if(byValue > VIM_ISP_MAX_BRIGHT_CONTRAST)
	{
		byValue = VIM_ISP_MAX_BRIGHT_CONTRAST;
	}
	if(byValue < VIM_ISP_MIN_BRIGHT_CONTRAST)
	{
		byValue =VIM_ISP_MIN_BRIGHT_CONTRAST;
	}
	paeadjust->saturation= byValue;
	//算法是否VIM_SIF_IspSetBrightness一样?????
*/	
	VIM_HIF_SetReg8(V5_REG_ISP_SATURATION,byValue);
}
/********************************************************************************
  Description:
	Set isp brightness and contrast(may be add saturation and chroma
  Parameters:
	byValue:	brightness range [V5_ISP_MIN_BRIGHT_CONTRAST, V5_ISP_MAX_BRIGHT_CONTRAST]
  Returns:
  Note:
  Remarks:
*********************************************************************************/
void VIM_SIF_IspSetBrightness(VIM_ISP_TAEADJUST *paeadjust,const TSnrInfo *pSensorInfo,UINT8 byValue)
{

/*
	SINT16 sBrightness;
	SINT16 sContrast;
	UINT8 RegGamma[17],i;
	
	if(byValue > VIM_ISP_MAX_BRIGHT_CONTRAST)
	{
		byValue = VIM_ISP_MAX_BRIGHT_CONTRAST;
	}
	if(byValue < VIM_ISP_MIN_BRIGHT_CONTRAST)
	{
		byValue =VIM_ISP_MIN_BRIGHT_CONTRAST;
	}

	paeadjust->brightness = byValue;

	sBrightness = (SINT16)(paeadjust->brightness) - 32;
	sContrast = (SINT16)(paeadjust->contrast) - 32;

	VIM_SIF_IspToolCalculateNewGammaCurve((const UINT8 *)pSensorInfo->gammaRGB, sContrast, sBrightness, RegGamma);

	for(i=0;i<17;i++)
	{
		VIM_HIF_SetReg8(V5_REG_ISP_RGMAS0_3+i,RegGamma[i]);
		VIM_HIF_SetReg8(V5_REG_ISP_GGMAS0_3+i,RegGamma[i]);
		VIM_HIF_SetReg8(V5_REG_ISP_BGMAS0_3+i,RegGamma[i]);		
	}

	VIM_SIF_IspCtrlUpate(0xff);//update all	
*/
	UINT16 brightness;
	UINT8 step;

	if(byValue > VIM_ISP_MAX_BRIGHT_CONTRAST)
	{
		byValue = VIM_ISP_MAX_BRIGHT_CONTRAST;
	}
	if(byValue < VIM_ISP_MIN_BRIGHT_CONTRAST)
	{
		byValue =VIM_ISP_MIN_BRIGHT_CONTRAST;
	}
	paeadjust->brightness= byValue;

	brightness=0;
	if(byValue < VIM_ISP_MAX_BRIGHT_CONTRAST/2)
	{
		step = VIM_ISP_MAX_BRIGHT_CONTRAST/2 - byValue;	
		brightness = 512/VIM_ISP_MAX_BRIGHT_CONTRAST*step;

		if(brightness>0xFF)
			brightness = 0xFF;

		brightness |= 0x100;
	}
	else
	{
		step = byValue - VIM_ISP_MAX_BRIGHT_CONTRAST/2;
		brightness = 512/VIM_ISP_MAX_BRIGHT_CONTRAST*step;

		if(brightness>0xFF)
			brightness = 0xFF;		
	}

	VIM_HIF_SetReg16(V5_REG_ISP_HUE_YOFF,brightness);
	}
#endif
#if (BOARD_TYPE==VC0820_FPGA)
#else	
#if VIM_SENSOR_HAVE_BAYER
/**********************************************************************************
	Description:
		Set Expose time to judge environment
	Parameters:
	Return:
	Remarks:
*********************************************************************************/
 //PVIM_CLK ClkInfo;//globe vari??????????
static void VIM_SIF_IspSetExposeTime(const TSnrInfo *pSensorInfo,VIM_ISP_PTAEADJUST ae,UINT8 byResolution)
{
	TSize size;
	UINT32 et,temp;

	temp = VIM_HIF_GetMclock();
	ae->snrclock = temp /(pSensorInfo->snrSizeCfg.pSizeCfg[byResolution].snrpixelratio+1);
	ae->snrclock *= CLOCK_MUL;

	et = (UINT32)(ae->snrclock/ae->freq)*ae->et;
	VIM_SIF_GetSensorResolution(pSensorInfo,(VIM_SIF_RESOLUTION) byResolution, &size);				
	if(pSensorInfo->snrSetETCall)
	{
		pSensorInfo->snrSetETCall(ae->env, et, size, ae->snrclock);
	}
}

/**********************************************************************************
	Description:
		Set Expose time or gain
	Parameters:
	Return:
		GAIN_ET -- change et and gain		GAIN_ONLY -- just change gain
	Remarks:
*********************************************************************************/
#else
UINT8 VIM_SIF_IspAutoExpose(VIM_ISP_PTAEADJUST ae,TSnrInfo *pSensorInfo)
{
	TSize size;
	UINT32 et;
	UINT8 ret,x;
	UINT8 gstep;

	//ae->snrclock =  g_UserInfo.WorkMClk.Clkout /(gVc0578_Info.pSensorInfo->snrSizeCfg.pSizeCfg[VIM_SENSOR_OUTPUT_SIZE].snrpixelratio+1);
	//ae->snrclock *= CLOCK_MUL;angela removed it ,have been set this value
	//ae->ymean = V5B_IspGetYMean();
	ae->ymean=VIM_HIF_GetReg8(V5_REG_ISP_YMEAN);


	if(ae->ymean>ae->ytarget && (ae->ymean-ae->ytarget)<ae->ythd )
		return TRUE;
	if(ae->ymean<ae->ytarget && (ae->ytarget-ae->ymean)<ae->ythd )
		return TRUE;



#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintHex("[VC0578B][SIF]:<AE> ymean ",ae->ymean);
#endif	
	

	
	
	ae->gtarget = pSensorInfo->aeparm.gtarget;	//hx:to be define,according to the speed value?? adjust speed by speed value??
	gstep = V5B_IspGetGlbgainStep();

	ret = V5B_IspToolComputeEt(ae);

	if(ret == GAIN_ONLY)
	{
		//V5B_IspSetGlbgainDelay(0);
		x = VIM_HIF_GetReg8(V5_REG_ISP_GLBGAINCTRL);
		VIM_HIF_SetReg32(V5_REG_ISP_GLBGAINCTRL, (UINT32)(x&0x23));
		
		//V5B_IspSetGlbgain(ae->gtarget);
		VIM_HIF_SetReg32(V5_REG_ISP_GLBGAIN,(UINT32) ae->gtarget);
		ae->gain = ae->gtarget;
	}
	else
	{
		//V5B_IspSetGlbgainDelay(gVc0568HS.SensorStatus.pSensorInfo->aeparm.gdelay);
		x = VIM_HIF_GetReg8(V5_REG_ISP_GLBGAINCTRL);
		VIM_HIF_SetReg32(V5_REG_ISP_GLBGAINCTRL,(UINT32)( (x &0x23) | ((pSensorInfo->aeparm.gdelay & 0x7) << 2)) );
		
		et = (UINT32)(ae->snrclock/ae->freq)*ae->newet;
		VIM_IPP_GetImageSize(&size.cx,&size.cy);//angela changed it 03-09 because removed the  VIM_SENSOR_OUTPUT_SIZE
		//VIM_SIF_GetSensorResolution(gVc0578_Info.pSensorInfo, VIM_SENSOR_OUTPUT_SIZE, &size);				
		if(pSensorInfo->snrSetETCall)
		{
#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
			VIM_USER_PrintHex("The New et is ",et);
#endif	
			pSensorInfo->snrSetETCall(ae->freq, et, size, ae->snrclock);
		}
		//V5B_IspSetGlbgain(ae->gtarget);
		VIM_HIF_SetReg8(V5_REG_ISP_GLBGAIN, ae->gtarget);

		ae->et = ae->newet;
		ae->gain = ae->gtarget; 
	}
	VIM_SIF_IspCtrlUpate(0xff);//update all
	
	return FALSE;
}

#endif
#endif
#if (BOARD_TYPE==VC0820_FPGA)
#else	
/********************************************************************************
  Description:
	get digital global gain effect fraction setting
  Returns:
		  00		if step is 0x40
		  01		if step is 0x20
		  10		if step is 0x10
		  11		if step is 0x8
  Note:
	This is the real digita gain.
  Remarks:
*********************************************************************************/
static UINT8 V5B_IspGetGlbgainStep(void)
{
	UINT8 byValue;
	
	byValue = (UINT8)VIM_HIF_GetReg32(V5_REG_ISP_GLBGAINCTRL);

	switch(byValue & 3)
	{
		case 0:
			return 0x40;
			break;
		case 1:
			return 0x20;
			break;
		case 2:
			return 0x10;
			break;
		case 3:
			return 0x8;
			break;
		default: // Impossible here.
			break;
	 }
	
	return 0x0;
}

/*************************************************************************************************
	Descriptin:	Compute exposure time 
	Return: 
			GAIN_ONLY -- just change gain value
			GAIN_ET -- change gain and et
			UN_ET_GAIN	-- don't change gain and et
	Remarks:new gain is set to ae->gtarget, new et is set to ae->et
*************************************************************************************************/


static UINT8 V5B_IspToolComputeEt(VIM_ISP_PTAEADJUST ae)
{
	if (V5B_IspToolAeIsGainOnly(ae))
	{
		return GAIN_ONLY;
	}
	
	V5B_IspToolAeFomula(ae, AE_GET_ET);
	
	if(ae->newet >= ET_ONE_STEP)
		V5B_IspToolOneStepMore(ae);
	else			//new et < one_step
		V5B_IspToolOneStepLess(ae);

	V5B_IspToolEtRangeAdjust(ae);

	ae->gthd = V5B_IspToolGetGainRange((UINT8)(ae->newet/ET_ONE_STEP));
	V5B_IspToolAeFomula(ae, AE_GET_GAIN);
	
	return GAIN_ET;
}



static	void VIM_SIF_IspToolComputeGainThreshold(UINT8 byGain, UINT8 byGainRange)
{
	UINT8 i = 0;

	VIM_USER_MemSet(gGainRange, 0, sizeof(gGainRange));

	gGainRange[0] = byGainRange;

	for(i=1; i<VIM_SIF_ET_GAINRANGE_STEP; i++)
	{
		gGainRange[i] = byGain - ((gGainRange[i-1]+byGain)*i)/(i+1) + VIM_SIF_ET_GAINRANGE_OVERLAY;
	}
}


static BOOL V5B_IspToolAeIsGainOnly(VIM_ISP_PTAEADJUST ae)
{
	UINT8 gainUp, gainDown;
	UINT32 tempGain;

	gainUp = ae->gtarget + ae->gthd;
	gainDown = ae->gtarget - ae->gthd;
	if(ae->et == ET_ONE_STEP)
	{
		gainDown = (ae->mingain < gainDown) ? ae->mingain : gainDown;
	}
	if(ae->et == (UINT32)(ae->maxet * ET_ONE_STEP))
	{
		gainUp = (ae->maxgain > gainUp) ? ae->maxgain : gainUp;
	}
	
	tempGain = V5B_IspToolComputeGain(ae->gain, ae->ymean, ae->ytarget);
	
	if(tempGain > (UINT32)gainUp)
	{
		tempGain = V5B_IspToolComputeGain(ae->gain, ae->ymean, ae->ytarget-ae->ythd);
		if(tempGain > (UINT32)gainUp)
		{
			return FALSE;
		}
	}
	else if(tempGain < (UINT32)gainDown)
	{
		tempGain = V5B_IspToolComputeGain(ae->gain, ae->ymean, ae->ytarget+ae->ythd);
		if(tempGain < (UINT32)gainDown)
		{
			return FALSE;
		}
	}

	ae->gtarget = (UINT8)tempGain;
	return TRUE;
}


static UINT32 V5B_IspToolComputeGain(UINT8 gain, UINT8 preY, UINT8 newY)
{
	UINT32 temp;

	newY = (newY + preY)/2;
	temp = (UINT32)(gLogTable[AE_M] - gLogTable[AE_M-newY]);
	temp = temp << 10;
	if(preY == 0)
		temp = (UINT32)(temp / (gLogTable[AE_M] - gLogTable[AE_M-1]));
	else
		temp = (UINT32)(temp / (gLogTable[AE_M] - gLogTable[AE_M-preY]));
	temp = (temp * gain)>>10;
	
	return temp;
}


/*************************************************************************************************
	Descriptin:	AE Compute Fomula
	Para:		ae:		structure of ae 
				flag:	AE_GET_ET
						AE_GET_GAIN
	Remarks:new gain is set to ae->gtarget
*************************************************************************************************/
static void V5B_IspToolAeFomula(VIM_ISP_PTAEADJUST ae, UINT8 flag)
{
	UINT32 temp;
	UINT32 preet, newet;
	UINT8 pregain, newgain;

	if(ae == NULL)
		return;

	preet = (ae->snrclock / ae->freq) * ae->et;
	newet = (ae->snrclock / ae->freq) * ae->newet;
	pregain = ae->gain;
	newgain = ae->gtarget;

	if(ae->ymean == 0)
		temp = (UINT32)(gLogTable[AE_M] - gLogTable[AE_M-1]);
	else
		temp = (UINT32)(gLogTable[AE_M] - gLogTable[AE_M-ae->ymean]);
	temp = temp << 10;
	temp = (UINT32)(temp / (gLogTable[AE_M] - gLogTable[AE_M-ae->ytarget]));
	
	if(flag == AE_GET_GAIN)
	{
		newgain = (UINT8)((preet * pregain) / ((temp * newet) >> 10));
		if(newgain < ae->gtarget - ae->gthd)
			ae->gtarget = ae->gtarget - ae->gthd;
		else if(newgain > ae->gtarget + ae->gthd)
			ae->gtarget = ae->gtarget + ae->gthd;
		else
			ae->gtarget = newgain;

		if((ae->newet == ((UINT32)ae->maxet * ET_ONE_STEP)) && (ae->ymean < ae->ytarget))
			ae->gtarget = ae->maxgain;
	}
	else if(flag == AE_GET_ET)
	{
		newet = ((UINT32)(preet * pregain) / (temp * newgain)) << 10;
		ae->newet = newet/(ae->snrclock/ae->freq);
	}
}


static void V5B_IspToolOneStepMore(VIM_ISP_PTAEADJUST ae)
{
	UINT32 etjump;

	if(ae->newet > ae->et)
	{
		etjump = ae->newet-ae->et;
		if(etjump < (UINT32)(gAeStep[ae->speed].step * ET_ONE_STEP))
			ae->newet = ae->et + ET_ONE_STEP;
		else
			ae->newet = ae->et + (etjump / gAeStep[ae->speed].div) - 
						((etjump / gAeStep[ae->speed].div) % ET_ONE_STEP);
	}
	else
	{
		etjump = ae->et - ae->newet;
		if((etjump != 0) && ((ae->et) > ET_ONE_STEP))
		{
			if(etjump < (UINT32)(gAeStep[ae->speed].step * ET_ONE_STEP))
				ae->newet = ae->et - ET_ONE_STEP;
			else if(etjump > ((UINT32)ae->maxet * ET_ONE_STEP / 3))			//hx: 3 should be define
				ae->newet = ae->newet + (gAeStep[ae->speed].step * ET_ONE_STEP);
			else
				ae->newet = (ae->et) - (etjump / (gAeStep[ae->speed].div)) +
							((etjump / (gAeStep[ae->speed].div)) % ET_ONE_STEP);
		}
	}
}

static void V5B_IspToolOneStepLess(VIM_ISP_PTAEADJUST ae)
{
	UINT32 etjump;

	if((ae->et) > ET_ONE_STEP)
	{
		etjump = ae->et - ET_ONE_STEP;
		if(etjump < (UINT32)(gAeStep[ae->speed].step * ET_ONE_STEP))
			ae->newet = ae->et - ET_ONE_STEP;
		else if(etjump > ((UINT32)ae->maxet * ET_ONE_STEP / 3))			//hx: 3 should be define
			ae->newet = ae->newet + (gAeStep[ae->speed].step * ET_ONE_STEP);
		else
			ae->newet = (ae->et) - (etjump / (gAeStep[ae->speed].div)) +
						((etjump / (gAeStep[ae->speed].div)) % ET_ONE_STEP);
	}
	else if((ae->et == ET_ONE_STEP) && (ae->ymean <= ae->ytop))
	{
		ae->newet = ae->et;
		ae->gtarget = ae->gain;
	}
}

static void V5B_IspToolEtRangeAdjust(VIM_ISP_PTAEADJUST ae)
{
	UINT32 tempDec = 0;

	if(ae->newet > ET_ONE_STEP)	//indoor
	{
		tempDec = ((ae->newet) % ET_ONE_STEP);
		if(tempDec <= (ET_ONE_STEP >> 1))
			ae->newet = ae->newet - tempDec;
		else
			ae->newet = ae->newet + ET_ONE_STEP - tempDec;
	}

	if((ae->newet) > ((UINT32)ae->maxet * ET_ONE_STEP))
		ae->newet = (ae->maxet * ET_ONE_STEP);
	if((ae->newet) < ((UINT32)ae->minet * ET_ONE_STEP))
		ae->newet = ae->minet * ET_ONE_STEP;
	if(ae->newet == 0)
		ae->newet = 1;
}

static UINT8 V5B_IspToolGetGainRange(UINT8 byStep)
{
	UINT8 byGainRange;

	if(byStep > VIM_SIF_ET_GAINRANGE_STEP)
	{
		byGainRange = gGainRange[VIM_SIF_ET_GAINRANGE_STEP-1];
	}
	else if(byStep == 0)
	{
		byGainRange = 0;
	}
	else
	{
		byGainRange = gGainRange[byStep-1];
	}

	return byGainRange;
}



/********************************************************************************
  Description:
	Y mean target
  Parameters:
	sel:	setting value
  Note:
  Remarks:
*********************************************************************************/
void VIM_SIF_IspSetYMeanTarget(UINT8 byYMeanTarget)
{
	VIM_HIF_SetReg32(V5_REG_ISP_Y_MEAN_TGT, (UINT32)byYMeanTarget);
}
/********************************************************************************
  Description:
	Y mean threshold
  Parameters:
	sel:	setting value
  Note:
  Remarks:
*********************************************************************************/
void VIM_SIF_IspSetYMeanThreshold(UINT8 byYMeanThreshold)
{
	VIM_HIF_SetReg32(V5_REG_ISP_Y_MEAN_THD,(UINT32) byYMeanThreshold);
}


/********************************************************************************
  Description:
	config digital global gain effect delay
  Parameters:
	val:	setting value
  Note:
	after val frames, the affect will active then
  Remarks:
*********************************************************************************/
void VIM_SIF_IspSetGlbgainDelay(UINT8 byVal)
{
	UINT8 x;
	
	x = VIM_HIF_GetReg8(V5_REG_ISP_GLBGAINCTRL);
	x =( ( x&0x23)|(byVal<<2) );
	VIM_HIF_SetReg32(V5_REG_ISP_GLBGAINCTRL,(UINT32)x);
}


/********************************************************************************
  Description:
	config digital global gain
  Parameters:
	byGlbGain:	setting value
  Remarks:
*********************************************************************************/
void VIM_SIF_IspSetGlbgain(UINT8 byGlbGain)
{
	VIM_HIF_SetReg32(V5_REG_ISP_GLBGAIN, (UINT32)byGlbGain);
}


/********************************************************************************
	Description:
		CTRL_UPDATE Register
	param:
	sel:
	VIM_SIF_ISP_GLBGAIN_UPDATE	=BIT0, 	
	VIM_SIF_ISP_DGAIN_UPDATE	=BIT1, 	
	VIM_SIF_ISP_BGAM_UPDATE	 	=BIT2, 	
	VIM_SIF_ISP_RGAM_UPDATE	  	=BIT4, 	
	VIM_SIF_ISP_COLMAT_UPDATE	=BIT5, 	
	VIM_SIF_ISP_GRAY_UPDATE	  	=BIT6, 	
	VIM_SIF_ISP_FEM_UPDATE	  	=BIT7, 		
	Note:
		[7] fem_update : After update  fem_m fem_p, fem_x1, fem_x2, fem_max, fem_min[0aH]~[0fH],  you must enable this bit.
		[6] gray_update: After update [26H]~[27H] CbCrOfs,  you must enable this bit.
		[5] colmat_update: After update [28H]~[37H] Color matrix registers,  you must enable this bit.
		[4] rgma_update: After update [4aH]~[5aH] Rgma registers,  you must enable this bit.
		[3] ggma_update: After update [5bH]~[6bH] Ggma registers,  you must enable this bit.
		[2] bgma_update: After update [6cH]~[7cH] Bgma registers,  you must enable this bit.
		[1] dgain_update: After update [1eH]~[20H] Digital RGBgain register,  you must enable this bit.
		[0] glbgain_update: After update [22H]~[23H] Global gain register,  you must enable this bit.

	Remarks:
*********************************************************************************/

void VIM_SIF_IspCtrlUpate(UINT8  sel)
{
	VIM_HIF_SetReg32(V5_REG_ISP_UPDATECTRL,(UINT32)sel);
	
}

/********************************************************************************
  Description:
	Set Af,Ae,int frequence
  Parameters:
	000 interrupt per 1 frame
	001 interrupt per 3 frame
	010 interrupt per 5 frame
	011 interrupt per 9 frame
	100 interrupt per 17 frame
	101 interrupt per 33 frame
	110 interrupt per 65 frame
	111 interrupt per 129 frame
  Remarks:
*********************************************************************************/

void VIM_ISP_SetAutoIntFreq(UINT8 val)
{
	UINT32 temp;
	temp = VIM_HIF_GetReg32(V5_REG_ISP_AUTOCTRL);

	temp &= 0xfffffff1;
	temp |= ((val&7)<<1);

	VIM_HIF_SetReg32(V5_REG_ISP_AUTOCTRL,temp);
}

#endif

#if VIM_SENSOR_AUTO_FOCUS
/*
if af not finished return 0
else return the right step(>=1)
idx 1 粗调
idx 2 细调
先粗调，后细调，并不断改变方向。
*/

//<<<<<<<<<<<
//UINT8 VIM_SIF_IspAutoFocus(void)

//>>>>>>>>>>>
#if 1
UINT8 VIM_SIF_IspAutoFocus(UINT8 *position)
{
 static UINT8 idx=0;
 static SINT8 dir=0;
 static UINT8 idx0_counter=0;
 static SINT8 rightstep=VIM_SENSOR_AF_MAXSTEP/4;
 
 static UINT32 sm0=0;
 static UINT32 sm1=0;
 
 UINT8 one_step;

 
 sm1 = sm0;
 sm0 = VIM_HIF_GetReg32(V5_REG_ISP_EDGE_SUM);

 
#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
                            VIM_USER_PrintHex("",rightstep);
                            VIM_USER_PrintHex("[VC0578B][SIF]:<AF> EdgeSum  ",sm0);
#endif       
 
 switch(idx)
 {
 case 0://粗调
  one_step = 3;
  if(idx0_counter==0)
  {
   if(rightstep < (VIM_SENSOR_AF_MAXSTEP/2) )
    dir = 1;
   else
    dir = -1;
 
   idx0_counter++;
  }
  else if(idx0_counter==1)
  {
   if(sm0 < sm1)
    dir *= -1;
 
   idx0_counter++;
  }
  else
  {
   if(sm0<sm1
    || rightstep == VIM_SENSOR_AF_MAXSTEP
    || rightstep == 1
    )//拐点
   {
    idx=1;
    dir *= -1;
    idx0_counter=0;
 
    one_step = 1;
    //one_step = 2;
   }
  }
  break;
 case 1://细调
  one_step = 1;
  //one_step = 2;

  
  if(sm0<sm1)//拐点
  {
   //上一次的step有最大的edge_sum
   rightstep = rightstep - dir*one_step;
   VIM_USER_SetAutoFocusStep(rightstep);

//>>>>>>>>>   
   *position = rightstep;
   idx = 0;
   idx0_counter = 0;
 #if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
   VIM_USER_PrintHex("[VC0578B][SIF]:<AFEND>>>",rightstep);
#endif       
   return rightstep;
  }
  else if(rightstep == VIM_SENSOR_AF_MAXSTEP
   || rightstep == 1
   )
  {
   idx = 0;
   idx0_counter = 0;
#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
   VIM_USER_PrintHex("[VC0578B][SIF]:<AFEND>>>",rightstep);
#endif       
//>>>>>>>>>>>>
   *position = rightstep;

   return rightstep;
  }
  break;
 }
 

 rightstep = rightstep + dir*one_step;
 if(rightstep < 1)
  rightstep = 1;
 if(rightstep > VIM_SENSOR_AF_MAXSTEP)
  rightstep = VIM_SENSOR_AF_MAXSTEP;
 
    VIM_USER_SetAutoFocusStep(rightstep);
#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
 VIM_USER_PrintHex("-->",rightstep);
#endif       

//>>>>>>>>>>>
*position = rightstep;

 return 0;
}
#else
UINT8 VIM_SIF_IspAutoFocus(UINT8 *position)
{
	 static UINT8 idx=0;
	 static SINT8 dir=0;
	 static UINT8 idx0_counter=0;
	 static SINT8 rightstep=VIM_SENSOR_AF_MAXSTEP/4;
	 
	 static UINT32 sm0=0;
	 static UINT32 sm1=0;
	 
	 UINT8 one_step;

	 
	 sm1 = sm0;
	 sm0 = VIM_HIF_GetReg32(V5_REG_ISP_EDGE_SUM);

	 
	#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
	                            VIM_USER_PrintHex("",rightstep);
	                            VIM_USER_PrintHex("[VC0578B][SIF]:<AF> EdgeSum  ",sm0);
	#endif       
	 
	 switch(idx)
	 {
	 case 0://粗调
	  one_step = 3;
	  if(idx0_counter==0)
	  {
	   if(rightstep < (VIM_SENSOR_AF_MAXSTEP/2) )
	    dir = 1;
	   else
	    dir = -1;
	 
	   idx0_counter++;
	  }
	  else if(idx0_counter==1)
	  {
	   if(sm0 < sm1)
	    dir *= -1;
	 
	   idx0_counter++;
	  }
	  else
	  {
	   if(sm0<sm1
	    || rightstep == VIM_SENSOR_AF_MAXSTEP
	    || rightstep == 1
	    )//拐点
	   {
	    idx=1;
	    dir *= -1;
	    idx0_counter=0;
	 
	    //one_step = 1;
	    one_step = 2;
	   }
	  }
	  break;
	 case 1://细调
	  //one_step = 1;
	  one_step = 2;

	  
	  if(sm0<sm1)//拐点
	  {
	   //上一次的step有最大的edge_sum
	   rightstep = rightstep - dir*one_step;
	   VIM_USER_SetAutoFocusStep(rightstep);

	//>>>>>>>>>   
	   *position = rightstep;
	   idx = 0;
	   idx0_counter = 0;
	 #if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
	   VIM_USER_PrintHex("[VC0578B][SIF]:<AFEND>>>",rightstep);
	#endif       
	   return rightstep;
	  }
	  else if(rightstep == VIM_SENSOR_AF_MAXSTEP
	   || rightstep == 1
	   )
	  {
	   idx = 0;
	   idx0_counter = 0;
	#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
	   VIM_USER_PrintHex("[VC0578B][SIF]:<AFEND>>>",rightstep);
	#endif       
	//>>>>>>>>>>>>
	   *position = rightstep;

	   return rightstep;
	  }
	  break;
	 }
	 

	 rightstep = rightstep + dir*one_step;
	 if(rightstep < 1)
	  rightstep = 1;
	 if(rightstep > VIM_SENSOR_AF_MAXSTEP)
	  rightstep = VIM_SENSOR_AF_MAXSTEP;
	 
	    VIM_USER_SetAutoFocusStep(rightstep);
	#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
	 VIM_USER_PrintHex("-->",rightstep);
	#endif       

	//>>>>>>>>>>>
	*position = rightstep;

	 return 0;
}
#endif
/********************************************************************************
  Description:
	adjust focus before capture
  Parameters:
	NULL
  Remarks:
	this fun will not return except af finished or timeout
*********************************************************************************/
void VIM_SIF_IspDoAFAtOnetime(void)
{
	UINT32 Waittme=0x1000;
	UINT8 temp;
	gVc0578b_Info.aeaf.Bafover = FALSE;

	//过程：开AF中断，关AE中断
	VIM_ISP_SetAutoIntFreq(0);//计算公式为2^n+1;
	VIM_SIF_ISP_RegisterISR(VIM_INT_SIF_YMEAN,VIM_SIF_IspAutoExposeISR);
	VIM_SIF_ISP_SetIntEnable(VIM_INT_SIF_YMEAN,DISABLE);

	//enable auto focus.
	temp=VIM_HIF_GetReg8(V5_REG_ISP_AUTOCTRL+1);
	VIM_HIF_SetReg8(V5_REG_ISP_AUTOCTRL+1, temp|(1<<5));

//	VIM_USER_SetAutoFocusStep(1);
	VIM_MAPI_Delay_Frame(4);
	
	VIM_SIF_ISP_RegisterISR(VIM_INT_SIF_AUTOFOC,VIM_MAPI_AutoFocusISR);
	VIM_SIF_ISP_SetIntEnable(VIM_INT_SIF_AUTOFOC,ENABLE);

	
	//等AF做完
	while(Waittme--)
	{
		if(gVc0578b_Info.aeaf.Bafover == TRUE)
			break;
		VIM_USER_DelayMs(2);
			
	}	
	//关AF,开AE
	//VIM_ISP_SetAutoIntFreq(0);//计算公式为2^n+1;
	VIM_SIF_ISP_SetIntEnable(VIM_INT_SIF_AUTOFOC,DISABLE);

	//enable ae.
	//temp=VIM_HIF_GetReg8(V5_REG_ISP_AUTOCTRL+1);
	//VIM_HIF_SetReg8(V5_REG_ISP_AUTOCTRL+1, temp&(~(1<<5)));

	//VIM_SIF_ISP_RegisterISR(VIM_INT_SIF_YMEAN,VIM_SIF_IspAutoExposeISR);		
	//VIM_SIF_ISP_SetIntEnable(VIM_INT_SIF_YMEAN,ENABLE);
	VIM_MAPI_Delay_Frame(3);
	return;
}



/********************************************************************************
  Description:
	select the marix when get the edge map
  Parameters:
	index:0    use the 3*3 marix
	index:1 	use the 5*5 marix
  Remarks:
	
*********************************************************************************/
void VIM_SIF_IspSelEMMarix(UINT8 index)
{
	UINT8 temp;
	temp=VIM_HIF_GetReg8(V5_REG_ISP_AUTOCTRL+1);
	if(index == 0)
		temp &= (~BIT6); //use 3*3
	else
		temp |= BIT6;
	
	VIM_HIF_SetReg8(V5_REG_ISP_AUTOCTRL+1, temp);
	
}

#endif //VIM_SENSOR_AUTO_FOCUS






/********************************************************************************
  Description:
	ae,af enable switch
  Parameters:
	enable: ENABLE,DISABLE
  Remarks:
  	ENABLE: enable af,disable ae
  	DISABLE: enable ae, disable af
*********************************************************************************/
void VIM_SIF_IspEnableFocus(BOOL enable)
{
#if (BOARD_TYPE==VC0820_FPGA)
#else
	UINT8 temp;
	if(enable==ENABLE)
	{
		//enable auto focus.
		temp=VIM_HIF_GetReg8(V5_REG_ISP_AUTOCTRL+1);
		VIM_HIF_SetReg8(V5_REG_ISP_AUTOCTRL+1, temp|(1<<5));
	}
	else
	{
		//disable auto focus
		temp=VIM_HIF_GetReg8(V5_REG_ISP_AUTOCTRL+1);
		VIM_HIF_SetReg8(V5_REG_ISP_AUTOCTRL+1, temp&(~(1<<5)));
	}
#endif	
}



/********************************************************************************
* Description:
*	Init i2c
*	
* Parameters:
*	pSensorInfo: The pointer to TSensorInfo structure.
	UINT32 MCLK: mclk for 578
* Return:
*	VIM_SUCCEED: init i2c VIM_SUCCEED
*	
* Note:
*	
**********************************************************************************/
VIM_RESULT VIM_SIF_InitI2c(
	UINT32 i2caddress,			/*(IN)	The pointer to TSensorInfo structure	*/
	UINT32 Clk						/*(IN)	MCLK of 578b	*/
)
{
	UINT32 bMode;
	UINT16 div;
	bMode=VIM_HIF_GetReg32(V5_REG_SIF_SNROP_MODE);
	bMode&=(~BIT5);				//b5=0, selected I2C bus *
	bMode&=(~BIT2);				//b2=0, I2c type normal
		
	div = (UINT16)(((VIM_HIF_GetMclock() / (UINT32)Clk) + 3) >> 2) << 2;	//inorder to cut low 2bit, because the I2C_clkcnt should be multiple of 4
	if(div < 0x40)				//Why +3???????
		div = 0x40;
#if(BOARD_TYPE==VC0820_FPGA)	
	VIM_HIF_SetReg16(V5_REG_SIF_I2C_CLKCNT, div);	//set I2C clock
#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
	div=VIM_HIF_GetReg16(V5_REG_SIF_I2C_CLKCNT);	//set I2C clock
	VIM_USER_PrintDec("[VC0578B][SIF]:V5_REG_SIF_I2C_CLKCNT=",div);
#endif	
#else
	VIM_HIF_SetReg32(V5_REG_SIF_I2C_CLKCNT, div);	//set I2C clock
#if((VIM_SIF_DEBUG)&&(VIM_5XRDK_DEBUG))
	div=VIM_HIF_GetReg32(V5_REG_SIF_I2C_CLKCNT);	//set I2C clock
	VIM_USER_PrintDec("[VC0578B][SIF]:V5_REG_SIF_I2C_CLKCNT=",div);
#endif	
#endif
	//set i2c address
	VIM_SIF_SetI2cDevAddr(i2caddress);	//set I2C device address
		
	VIM_HIF_SetReg32(V5_REG_SIF_SNROP_MODE,bMode);

	return VIM_SUCCEED;

}
