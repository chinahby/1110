/* linesize(132)
** pagesize(60)
** title("Dual Mode Subscriber Station")
** subtitle("QDSP2 Device Driver")
*/
/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

                  Q D S P   D E V I C E   D R I V E R
                   P A C K E T    E X C H A N G E    A N D
         C O M M A N D   I N T E R F A C E   F U N C T I O N S

GENERAL DESCRIPTION
  This module contains packet exchange and command interface functions for
  the QDSP vocoder.

EXTERNALIZED FUNCTIONS
  qdsp_cmd_init
    Initialization of the QDSP command layer driver.
  qdsp_cmd_sleep
    Request the DSP to go to low power mode.
  qdsp_cmd_idle
    Request the DSP to go to idle mode.
  qdsp_cmd_loopback_test
    Send a Loopback Test Command to the DSP.
  qdsp_cmd_get_diags
    Reads the QDSP2 Diagnostic Data.
  qdsp_cmd_get_state
    Reads the QDSP2 State.
  qdsp_cmd_voc_config
    Send a command to the DSP to configure the vocoder.
  qdsp_cmd_voc_timing
    Send a command to the DSP to start encoding and decoding.
  qdsp_cmd_voc_frame_reference
    Request the DSP behave as if a vocoder frame reference strobe is received.
  qdsp_cmd_enc_ctrl
    Send encoder rate control parameters to the vocoder.
  qdsp_cmd_dfm_config
    Send DFM configuration data to the DSP.
  qdsp_cmd_dfm_go
    Send a command to the DSP to start DFM processing.
  qdsp_cmd_rx_frame
    Send a frame of data to the vocoder's decoder.
  qdsp_cmd_tx_frame
    Get a frame of data from the vocoders encoder.
  qdsp_cmd_codec_config
    Send a Codec Configuration Command to the DSP.
  qdsp_cmd_sample_slip_mode
    Enable or disable automatic sample slipping.
  qdsp_cmd_sample_slip_ctrl
    Manually advance or retard PCM clock by one cycle.
  qdsp_cmd_dtmf
    Send a DTMF Tone Request to the DSP.
  qdsp_cmd_dtmf_register
    Register the QDSP DTMF Sat Message report function.
  qdsp_cmd_set_dtmf_path
    Select the audio path for DTMF generation.
  qdsp_cmd_vol_ctrl
    Control the rx and tx volume and muting.
  qdsp_cmd_codec_gain_ctrl
    Control the QDSP2 internal codec gain.
  qdsp_cmd_agc_config
    Set the AGC configuration.
  qdsp_cmd_agc_param
    Set the AGC parameters.
  qdsp_cmd_ec_ctrl
    Set the echo cancellation mode.
  qdsp_cmd_ns_ctrl
    Enable or disable the noise suppressor.
  qdsp_cmd_hpf_ctrl (DMA Type Writable Information)
    Enable or disable the HPF override flag.
  qdsp_cmd_nes_ctrl
    Enable or disable the NES.
  qdsp_cmd_get_pcmpad
    Read the PCM pad value.
  qdsp_cmd_set_pcmpad
    Set the PCM pad value.
  qdsp_cmd_get_sat_dcc
    Read the DFM SAT Detected Color Code value.
  qdsp_cmd_clear_sat_dcc
    Clear the DFM SAT Detected Color Code value.
  qdsp_cmd_sw_reset
    Send a command to the DSP to perform a software reset.
  qdsp_cmd_set_rx_pcm_filter
    Load a new set of RX PCM filter coefficients.
  qdsp_cmd_set_tx_pcm_filter
    Load a new set of TX PCM filter coefficients.
  qdsp_cmd_up_packet_loopback
    Enable microprocessor packet loopback interrupt service routine.
  qdsp_cmd_vr_codec_config
    Send a command to the DSP to configure the codec for VR Mode B/C.
  qdsp_cmd_vr_prompt
    Send a command to transition the DSP to VR PROMPT state for VR Mode B/C.
  qdsp_cmd_capture_start
    Capture an utterance for Mode B/C VR.
  qdsp_cmd_capture_cont
    Send a capture continue command to the DSP.
  qdsp_cmd_capture_stop
    Stop an utterance capture operation for Mode B/C VR.
  qdsp_cmd_match_start
    Start a match operation for Mode B/C VR.
  qdsp_cmd_match_result
    Return match result message data.
  qdsp_cmd_pattern_load
    Send patterns to the DSP for a matching operation for Mode B/C VR.
  qdsp_cmd_set_narrowb
    Configure the DSP for narrowband capture before a capture command is sent.
  qdsp_cmd_set_qsynth_pcm_filter
    Configure the FIR PCM filter at the output of the MIDI synthesizer.
  qdsp_cmd_set_qsynth_adrc_ctl
    Configure the audio dynamic range compressor for QSynth.
  qdsp_cmd_adec_config_cmd
    Configure adec configuration command for Windows Media Audio decoder.
  qdsp_cmd_do_memswap
    Swap the conjacent two bytes in a byte array.
  qdsp_cmd_adec_dme_write
    DME audio data to qdsp for Windows Media Audio decoding.
  qdsp_cmd_mm_encoder_config
    Sends a command to the DSP to configure the audio encoder.
  qdsp_cmd_mm_rec_audio_config
    Sends a command to the DSP to configure the audio.
  qdsp_cmd_mm_rec_update_read_count
    Used to update the read index to DSP during MultiMedia recording.
  qdsp_cmd_mm_rec_get_data
    Retrieve encoded multimedia data frame from dsp
  qdsp_cmd_adec_data_consumed
    This function detects decoder has finished consuming data.
  qdsp_cmd_3d_pos_set_lsnr_vel
    Sets the 3D positional listener position.
  qdsp_cmd_3d_reverb_check
    Enables/Disables the 3D reverb on DSP when loaded.
  qdsp_cmd_3d_reverb_disable
    Enables/Disables the 3D reverb.
  qdsp_cmd_3d_reverb_set
    Sets the 3D reverb parameters.
  qdsp_cmd_3d_reverb_set_src_vol
    Sets the reverb source volume.
  qdsp_cmd_3d_pos_set_src_vel
    Sets the 3D positional source velocity.
  qdsp_cmd_3d_pos_query_lsnr_vel
    Queries the 3D positional listener velocity.
  qdsp_cmd_3d_pos_query_reverb_enabled
    Queries if reverb is currently enabled or not.
  qdsp_cmd_3d_pos_query_reverb_setting
    Queries current reverb setting
  qdsp_cmd_3d_pos_query_src_vel
    Queries the 3D positional source velocity.
  qdsp_cmd_3d_pos_query_src_revol
    Queries the 3D positional source reverb volume.
  qdsp_cmd_3d_pos_reverb_reset
    This function clears reverb preset and set the reverb enable flag to
    FALSE.
  qdsp_cmd_3d_pos_enable
    This function enable/disable 3D environment.
  qdsp_cmd_3d_pos_assign_query_buffs
    Assign 3D query buffers
  qdsp_cmd_3d_pos_reset_env
    Resets 3D environment.
  qdsp_cmd_3d_pos_src_enable
    This function enable/disable 3D effect on given sound source.
  qdsp_cmd_3d_pos_reset_src
    resets the 3D positional source.
  qdsp_cmd_3d_pos_query_env_enabled
    queries if 3D environment is currently enabled or not.
  qdsp_cmd_3d_pos_query_src_enabled
    queries if source 3D effect is currently enabled or not.
  qdsp_cmd_qsynth_voc_adec_start
    Configure & start AMR or QCP decoder on qsynth firmware.
  qdsp_cmd_qsynth_change_adec_state
    Changes the State of qdsp_cmd_qsynth_adpcm_data[channel].adec_state.
INITIALIZATION AND SEQUENCING REQUIREMENTS
  voc_task() must be started up before calling any of the vocoder API functions.

Copyright(c) 1999 - 2009 by QUALCOMM, Incorporated.
All Rights Reserved. Qualcomm Proprietary and Confidential.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

/* <EJECT> */
/*===========================================================================

                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$Header: //source/qcom/qct/multimedia/audio/6k/ver1/avs/main/latest/src/qdspcmd.c#83 $ $DateTime: 2009/10/26 08:18:28 $ $Author: sudhirk $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
10/26/09   sud     Removed dependency on feature FEATURE_VOC_AMR_WB for feature
                   .AWB file playback.
10/08/09   knm     Integrated new marimba codec driver for SCMM
10/01/09   rm      Support for removing assertion in voc_fl_packet_processor.
10/06/09   sj      Added SCMM specific changes
09/22/09   nr      Fixed compilation issue for Thin UI build.
09/07/09   vsud    Changes for resampler image imeplementation.
08/18/09   kkm     VOC_ADPCM module has only adpcmcodecRxGain instead of codecRxGain and
                   rxVolume. adpcmcodecRxGain is updated with the gain according to the
                   current volume level instead of constant codecRxGain.
07/21/09   kk      Fixed compillation issue for thin UI build.
07/13/09   rm      Adding support for 4GV_WB_VoIP.
07/09/09   kkm     During device switch ecodec clock turning off in isr is removed, as rex dont
                   support critical sections in it.
07/07/09   rm      Added changes for QCamCorder Turbo image
07/06/09   kk      Fixed CR 186889 Audio stopped during .mp4 file playback
                   with QCELP 13K audio due to Av sync issues.
06/30/09   kk      Added F3 messages to print AAC config information.
25/06/09    nr     Fixed ADPCM file playback issue after 4GV-NB voice call.
                   Updated copyright.
10/06/09   kkm     Fixing CR 171941. When BT headset is powered off and on in pause
                   state to call the function qdsp_cmd_pp_arm_read_done the pause
                   state variable is not correctly checked. Added to check correctly
06/01/09    av     Fix for compiler warnings.
05/30/09    sj     Update ezHearStaticParamsUpdated to -1 when fresh voice
                   call is made if even if slowtalk is disabled.
05/21/09    kk     Added support for H264 QCIF playback support
                   for low power mode(TURBO).
05/11/09    rm     QCamCorder FW's Vocoder State Paths has changed
                   to Voc Combo's state path. The SW chnages are done
                   to adapt to those changes.
05/08/09    vm     Added Support for Device switch from external to internal.
04/28/08    rm     CR 180378 - Slow Talk doesn't work when enabling it the 2nd time in the same call
04/22/09    av     Fixed compiler warnings due to previous check-in.
04/06/09    av     Adding VP3 Feature.
03/13/09   knm     Added code to increase the codec gain non-logarithamically
                   to reduce the pop noise.
03/10/09    sj      Added slowtalk feature support
21/02/09    sj     Fixed this issue: For Qcamcorder Image vocoder interface
                   changed from legacy to combo vocoder interface, so DMTF
                   was not working while Qcamcorder recording. Fixed CR 171955.
02/19/09    sj     Fixed CR 172775 - AUX PCM interface for
                   QDSP_IMAGE_QVP_H263P3_EVRC didn't work
02/16/09   skr     Added support for DTMF while JPEG Decoding.
02/06/09    bk     Featurized for removing Lint and MM warnings.
01/21/09   skr     added support for SPA and AV sync for In call Audio for CDMA
                   targets.
01/19/09    bk     Featurized the definitions of functions
                   qdsp_cmd_adec_chan_*  (). Fixed the linking errors arised
                   while featurizing for FEATURE_STD_MIDI.
01/09/09   laks    Fixing CR-166704, when ACC image is loaded for playing ADPCM
                   WAVE file the volume settings are written to QDSP_rxVolume
12/30/08    rm     Adding fluence parameters
12/30/08    sj     Added support for .awb file format
12/30/08    sk     Modified  the code to resolve compilation issue when
                   FEATURE_AUDFMT_FIR_FILTER is enabled. CR 167986.
12/08/08    rm     Modification of wnr and rve parameters
12/03/08    sj     Enabled the missing TTY support for 4GV-WB and AMR-WB
                   vocoders. Fixed CR 165146.
12/01/08    ry     Fixed Thin UI compilation errors.
11/26/08   skr     Modified the code to fix THIN UI build issues
11/25/08   skr     Fixed Issues reported by SU1 regression team related to
                   Audio+Camera Concurrency.
11/24/08   skr     Added code for Audio + camera Concurrency
11/24/08    av     Fix for CR137301.
11/18/08    dp     Added support for playing NB-AMR on A2DP
11/06/08    az     Added support for in call video/qtv.
10/31/08   skr     Fixed compilation issues if custwm.h and
                   FEATUE_AVS_INCALL_WMA are undefined.
10/22/08    dp     FM over BT AG changes
10/17/08    vm     added idlemetring support for qtv image
10/22/08    sj     AMR_WB MODE-1 (8.87 kbps) needs 23 bytes of encoded
                   data (177 bits). Fixed CR 159591.
10/22/08    kk     Fixed issues with playing Qtv 4gv nb clips.
10/02/08    vsud   Fixed CR# 157201 for SMAF file play back issues.
                   Adec Channel 1 was never set when same command is sent twice.
10/01/08    ry     Fixed compilation warning.
10/01/08    ry     Flush & Invalidate cache macros are used for ARM PP buffers.
09/24/08   skr     Move resetting of Qensemble interrupt flags to
                   voc_codec_select().
09/22/08    sj     Added support for QVP 4GV-WB image
09/15/08    ry     Safeguarded QDSP_nsSwitch to address compilation issue.
09/15/08   knm     Flush & Invalidate cache macros are used wherever buffer is
                   indirectly shared between ARM & DSP.
04/09/08    av      Corrected typo to fix compiler warning
09/04/08    az     Fixed the CR:144066 - Regarding play pmd included aac
                   via bluetooth.
08/28/08    rm     Added support for RVE.
08/28/08    vsud   Fiixed WMA pro compilation error.
08/28/08    ry     Fixed a compilation error and compilation warnings.
08/28/08    kd     Fixed CR-149453,unable to pause a sequence properly in
                   multi-sequencer mode through A2DP.Removed flag
                   qdsp_cmd_pp_pause in qdsp_cmd_pause_midi_seq() function.
08/27/08    ry     Added code to allocate the pp buffer pool dynamically and modified
                   functions to return the status if malloc fails.
08/26/08   anb     Added support for DSP based WMAPRO
08/26/08  ss/sud   Function qdsp_cmd_adec_flush() is modified such that
                   qdsp_cmd_adpcm_adec_info is cleared for VOC ADPCM.
                   CR_154303 (SR_1099290)
08/12/08   sj      Fixed klokwork errors
08/01/08   knm     Added fix to remove compiler warnings
07/31/08   skr     changes to send 0x501 cmd to bring Audio to foreground
                   (90 deg) without changing to the default gain.
07/31/08   skr     Changes to release VOCODER & ADEC separately.
07/31/08   skr     Adding FEATURE_WMA compile time switch to avoid compilation
                   issues
07/30/08    kk     Featurised the support to play Qtv 4gv nb clips.
07/29/08    kd     Fixed CR-149453-Unable to pause properly of the given
				   sequence in multi-sequencer mode in BT A2DP
07/17/08    kk     Added support to play Qtv 4gv nb clips.
06/25/08    sj     QDSP_PCM_INTERFACE_RX_INPUT interface is supported for
                   crystal speech image. so remvoved crystal speech condition
                   check in function qdsp_cmd_set_pcm_modes() for
                   QDSP_PCM_INTERFACE_RX_INPUT
06/17/08    sj     Fixed the compiler errors thrown by RVCT2.2 compiler
05/26/08   knm     Fixed CR 148005: Added INTFREE_SAV in qdsp_cmd_codec_gain_ctrl
                   to free the lock before returning from the function.
05/14/08    sr     Modified qdsp_cmd_codec_cofig() to include default_frame_
                   rate.Fix for CR 134407 - 16khz PCM sampling.
03/17/08  ymc/anb  Modified codec gain ctrl api to control gain changes.
                   Fix for SC2X codec pop issue through MSMAUD_PCM_DC_OFFSET feature.
03/13/08    az     Fixed the CR: 141003 and 140996 issue regarding
                   Qensemble and Qconcert+.
03/11/08    kk     Added support for sending mp3 configuration
                   information for DSP.
02/28/08   wfd     Integrate ARM changes for DLS CMX 5.0 support.
02/28/08    sj     Fixed ThinUI Linking errors problem
02/08/08    az     Added post processing support for the in call audio.
02/07/08    kk     Added support for Qensemble phase 2 interface changes.
02/05/08    kk     Added support to send DTMF cmds to mixerCommandReg
                   for Incall images.
01/31/08    pl     Added new function to emulate qsynth interrupt.
01/30/08    az     Include the support for the In call Qtv.
01/15/08    hs     Added support ISDB-T dual mono output control
01/07/08    az     Included the in call midi and the new in call architecture.
01/04/08    ss     Fixed two critical lint errors in function,
                   qdsp_cmd_qsynth_change_adec_state.
12/18/07    sj     Removed fetaure FEATURE_MULTIMEDIA_CODEC_GAIN from
                   custavs.h
                   so removed feature FEATURE_MULTIMEDIA_CODEC_GAIN from
                   qdsp_cmd_codec_gain_ctrl() function.
12/14/07    ss     Merged the fix for Bad Quality in MIDI+ADPCM/QCP in PMD
                   files. Fixed CR_122182.
12/06/07    sr     1x Packet Logging in ISR level.
12/06/07    sr     Fixed typo error for FEATURE_AVS_CRYSTAL_SPEECH.
11/20/07   sk/ymc  Featurized the code in qdsp_cmd_set_rx_pcm_iir_filter()
                   to avoid compilation issues when FEATURE_IIR_FILTER
                   is enabled.
11/20/07    sr     Fixed RVCT2.2 compilation errors.
11/15/07    az     Featurized the code for In call to avoid compilation for
                   other targets.
11/14/07    hs     Added QEnsemble support
11/06/07    az     Included the support for in call WMA.
11/06/07    kk     Fixed compilation error for WMA.
10/31/07    az     Included the support for the in call AAC.
10/29/07    sr     Fixed featurization issues for THIN_UI builds
10/28/07    sr     Updating iir_filter & pcm_filter functions -
                   AMR_WB doesnot support FIR filters.
            sr     Cleaned up compilation errors.
10/17/07   ymc     Fixed featurization for GSM voice playback.
08/27/07   ymc     Added Crystal Speech support.
           ymc     Featurized legacy EC symbols preparing for complete removal.
08/24/07    hs     Integrated: Added support for PCR clk sync feature.
08/20/07    hs     Support AAC stand alone encoding.
08/14/07   anb     Removed duplication defintion related to FEATURE_NO_TX_COMFORT_NOISE
07/02/07    pl     Added qdsp_cmd_reset_adec_cmd_buf() to clear the qsynth
                   adec command buffer.
06/13/07   sud     Modified qdsp_cmd_audio_config() to set qdsp_voc_mode to
                   QDSP_VOC_MODE_NONE_V when playing 32 KHz ADPCM file using
                   VOCODER/GRAPH image. Fix for CR:120461
06/04/07    az     Corrected the featurizations to protect the variable qdsp_cmd
                   _silence_frame.
06/04/07   sud     Fixed CR:119881 Observe the audio skipped during
                   AAC Playback. Corrected featurization in qdsp_cmd_register().
05/31/07    az     Included the support for AMR WB for the feature AV SYNC BYTE
                   BASED Feedback.
05/25/07    az     Fixed the CR: 110791 - IMEDIA_Pause after recieving first
                   frame  status message not stopping within a second.
05/23/07   sud     Included QDSP_MODULE_4GV in the TTY interface query
                   function qdsp_cmd_get_tty_intf().
05/07/07    at     Made changes so that a homing sequence is inserted in the
                   recorded stream upon resuming a previously paused .AMR
                   recording, and also changed qdsp_cmd_tx_comfort_noise_ctrl()
                   so that TX is properly unmuted upon resuming (fix for CR 115303).
04/20/07   anb     SC2x 3.0 Related support is added & fixed compiler issues
04/07/07    pl     Changed qdsp_cmd_qsynth_qcp_adec_start() to
                   qdsp_cmd_qsynth_voc_adec_start() because this
                   function will be used for AMR and QCP playback.
03/14/07    az     Fixed the critical lint error.
03/15/07    kan    Added 4GV-WB Code
03/09/07    az     Included the changes for the SR: 899671 - Audio skip after
                   pause in Qtv player.
02/27/07    sk     F3 messages for QAudioFX
02/27/07   ymc     Renamed QDSP_CMD_EC_GEN_LEGEND as QDSP_CMD_EC_GEN_LEGACY.
02/26/07   kan     Added AMR-WB changes
02/20/07    ss     Merged a change regarding ping-pong buffer scheme at line 15766.
02/14/07    az     Fixed the CR: 110523 error fatal during video recording
02/12/07  sg/ay    Added support for AAC error concealment.
02/09/07   act     Modified code to set new discontinuity flag for PCM samples
                   destined for UMTS TTY processing.
02/08/07    ay     Renamed EC interface variables.
01/24/07    ss     Added support to play fractional sample rate wave bitstream.
01/23/07    kk     Fixed issues related to adding 44k sample rate.
01/23/07   suk     Added TTY interface query function that tells qdspcmd
                   function whether a certain interface is available or not.
                   Modified qdsp_cmd_clear_dsp_isr() to clear
                   qdsp_cmd_module_select.
01/11/07   kan     Included log_codes.h and Modified the name for PCM Logging
                   to match the diag codes.
01/09/07   suk     Added QDSP_IMAGE_VOC_COMBO_VOIP support.
                   Updated Copyright text.
12/07/06   ymc     Fixed AUX PCM clock loss due to DSP image swap.
12/04/06    az     Fixed the CR 107239 Phone crash after playing specific amr file.
12/02/06   suk     Added support for VOIP Combo Vocoder, and Combo vocoder
                   with G711 and 4GV.
                   Added the byte-word conversions in the G711 encoder and
                   decoder ISR that is required by G711 callback functions.
11/28/06    sp     Fixed SCO rework issues for QCP files.
11/02/06    ak     Fixed TTY not working for 4GV-NB, for CR 101153
10/25/06    ay     Added DTMF mixing support for G.711 and QVP+EVRC images.
                   Fixed DTMF volume control for QVP and EVRC+QTV images.
                   Fixed G.711 mute not working (CR 101434).
10/23/06    ss     Modified reverb room gain value for all reverb presets.
10/06/06   suk     Fixed CR 96437(BT:A2DP file plays with disturbance
                   and stop in between).
09/20/06    az     Made changes in the code regarding volume control for Incall MP3.
09/19/06    kan    Modified the algo for SID First detection in AMR (A26101)
09/06/06    ak     Added PCM Logging in QXDM "FEATURE_PCM_PKT_LOG"
09/05/06    ay     Added AMR-WB+ support.
09/01/06    hz     Fixed CR#100139 -- No volume control for ADPCM in camera
                   preview mode.
08/29/06    hz     Added support for incall MP3 on 65nm platforms.
08/24/06    sp     Updated DMA Path control for QVP images.
08/22/06    lg     Fixed merge issues with GameAudio changes
08/21/06    hz     Added DTMF mixing support for QVP images, CR#93712.
08/20/06   ymc     Fixed Saturn codec pop noise issue.
08/08/06    st     Updated qdsp_cmd_adec_flush() to support QDSP_IMAGE_G711
                   image.
08/07/06    az     Fixed CR 98235(Crash when playing invalid amr file)
07/31/06    sp     Fixed some merge issues in AV Sync feature and
                   some issues in SCO rework feature
07/31/06    ay     Removed #undef QDSP_PACKET_SNIFFER.
07/28/06    pl     Fixed source position query in qdsp_cmd_3d_pos_query_src_all().
07/28/06    hz     Added fixes for CR#93192.
07/27/06   anb     Added the FEATURE_AVS_BT_SCO_REWORK which enables the AVS to send
                   messages to the BT driver
07/26/06    nm     Added FEATURE_AVS_NEXTGEN_EC.
07/18/06    hz     Fixed a wrong switch/case for voc_mp3.
07/12/06    hz     Added support for incall mp3 GSM/UMTS, BTSCO and PostProc
                   features.
07/12/06   act     Fixed featurization for qdsp_cmd_enc_ctrl() for rate
06/27/06    pl     Added environment & source enable/disable and reset support.
06/26/06    pl     Added support for doppler, reverb, and new ping-pong buffer
                   data writing scheme.
                   reduction mechanism.
06/19/06    sk     Fixed MSMAUD_VOC_1X_COMMON featurization issue for UMTS
                   targets. Wrong featurization caused interrupts not being
                   serviced for 1X vocoders.
06/14/06    hz     Fixed G711 featurization issue. Some wrong featurization
                   causes G711 not compiled in. For CR#95703.
06/12/06    sg     Added new ISR to handle images that support both 1X and
                   UMTS vocoders.
06/01/06    sg     Featurized secondary decoder in GSM vocoder images under
                   FEATURE_VOICE_PLAYBACK.
05/31/06    sg     Re-featureized synth MIDI functions so that they are not
                   under FEATURE_ADEC.
                   Featurized secondary decoder in vocoder images under
                   FEATURE_VOICE_PLAYBACK.
                   Featurized functions common to 1X vocoders under
                   MSMAUD_VOC_1X_COMMON.
05/24/06    ay     Fixed I2SSBC featurization issues.
05/02/06    pl     Modified qdsp_cmd_3d_pos_set_src_vol_atten() to take out
                   the cap on the rolloff factor.
04/26/06   act     Added support for combo vocoder image.
04/26/06    hz     Corrected featurization for baseline in qdsp_cmd_do_av_sync.
04/19/06  lg/st    Fixed issue with Adec Flush on Qsynth image ( CR#89264).
                   Added check for Pause Flag for QCP on QSynth image.
04/08/06    KK     Added support for DTMF re-try mechanism for all
                   Qtunes common images.
04/03/06    ak     Added support for sidetone control.
04/02/06    sg     Unfeature-ized FEATURE_QDSP_USES_MODULES and removed support
                   for the old-style QDSP services.
03/30/06    pl     Fixed compilation error in qdsp_cmd_set_audfmt_pcm_filter()
03/24/06    pl     Seperated FIR filter from FEATURE_QSYNTH_ADRC and
                   FEATURE_QTUNES_ADRC.
03/21/06    pl     Modified qdsp_cmd_do_av_sync() to read byte counter from
                   qsynth DSP.
03/14/06    sp     Fixed a compiler error that occurs due to wrong featurization
                   in qdsp_cmd_adec_chan_start.
03/14/06    sp     Simplified PP functions, fixed WMA/RA 8 KHz noise issues.
03/13/06    lg     Added new API for dereg MIDI command callback
03/13/06    st     Added support for delayed start of ADEC channels with synth
                   image; added support for 3D positional final source settings
                   query command; modified query commands to query DSP based
                   on local adec_enabled flag because there is no indication
                   from DSP when ADEC is configured but not active.
03/09/06    hz     Added support for evrc in-call MP3 support.
02/28/06    sm     Fixed typo in feature definition.
02/23/06    hz     Maturiazed featurization in qdsp_cmd_do_av_sync.
02/21/06   act     Added FEATURE_AVS_VOC_DTMF_MIXING.
02/18/06    hz     Added fixes for in-call mp3.
02/17/06    ay     Added image check for voc_adpcm module.
02/03/06    sm     Added 4GV VOIP support
01/31/06    lg     Added support for 6550-90nm images
01/31/06    hz     Added support for in-call mp3 feature.
01/30/06    sp     Added support for I2S SBC interface.
01/26/06    hz     Added AV sync byte count support for AAC related and Real
                   audio.
01/17/06    hz     Added fix for CR84926 in qdsp_cmd_av_sync_voc_cb.
01/16/06    sm     Added FEATURE_QDJ_TIMEWARP
01/14/06    pl     Modified qdsp_cmd_set_qconcert_config() to explicitly check
                   if qconcert->enable is set to TRUE
01/13/06   act     Fixed compile warning with low-tier featureset.
12/14/05    sp     Changed the DMA path control settings for QVP_MPEG4_AMR and
                   QVP_H263P3_AMR images to fix garbled audio when audio is
                   on BT HS on a QVP call.
12/09/05    hz     Added support for QVP_H263P3_EVRC image.
12/02/05    pl     Modified qdsp_cmd_set_audfmt_iir_filter() to apply iir filter
                   coefficient for QTUNES image.
11/30/05    sm     CR82622: QCP-HR playback fix.
11/21/05    hz     CR78442: Added 32KHz ADPCM support for UMTS vocoder codecs.
11/10/05    sg     CR81885: Fixed ADEC error mask for Real, AAC so that the
                   "out-of-data" bits are not treated as error bits, which
                   cause data underflow to be treated as an error.
11/14/05    hz     Clarified compilation warning.
11/11/05    pl     Modified qdsp_cmd_adec_flush() for proper featurization of
                   FEATURE_QSYNTH_ADPCM.
11/11/05    st     Modified code for lint updates.
11/10/05    pl     Modified qdsp_cmd_adec_config(), qdsp_cmd_qsynth_qcp_adec_start()
                   and qdsp_cmd_synth_qdsp2_isr() to read adecDataWritePtrs
                   once when the audio decoders are started first time.
11/08/05    sm     amr_dec_isr() processes SPEECH_BAD and SID_BAD QCP frames.
11/03/05    sk     Added post processing and ARM based SBC support for RA.
10/27/05    pl     Modified ADPCM block length equation in
                   qdsp_cmd_qsynth_adpcm_start() function because game audio
                   DSP image now supports stereo ADPCM.
10/21/05    hz     Added watermark of how much buffer can be used for
                   pre-allocated Windows Media Buffer.
10/21/05    st     Modified code to return default values when querying 3D
                   source parameters in the time between when ADEC config
                   command has been issued to DSP and before DSP actually
                   executes command.
10/19/05    pl     Added PCM AVSync support.
10/04/05    sp     Fixed a compiler warning.
09/18/05    sp     Added support for DSP based SBC encoder.
09/18/05   pl/st   Added support for QAudioFX: 3D positional commands and query
                   interface; modified code to support new game audio ADEC
                   API; refeaturized qdsp_cmd_pp_free_read_buffer().
09/16/05    hz     Added in-call QTV image support.
09/16/05    sp     Fixed a compiler warning.
09/15/05    hz     Added missing case check for windows media AV sync.
09/14/05    sk     Re featurized code so that FEATURE_ARM_POST_PROCESSING is
                   split into RX interface and RX and TX interface. Enabling
                   FEATURE_ARM_POST_PROCESSING enables both RX and TX. Enabling
                   FEATURE_AVS_WB_PCM_RX_INTERFACE enables only RX.
09/13/05    sp     Added Post Processing and BT A2DP support for WMA.
09/12/05    hz     Added AV sync support for windows media.
09/01/05    sg     CR68646: Fixed issue where the DSP is left in a paused state
                   before the next song starts (while reinitialization is
                   occuring for the new song).
                   Fixed feature-ization in vox control function.
08/31/05    fc     Fixed compilation errors for SNAA build.
            sm     Fix coverity error.
            sm     Added VOX support.
08/30/05    st     Modified qdsp_cmd_qsynth_adpcm_write() to handle odd sized
                   data buffers, CR68979.
08/27/05    hz     Typo fix in qdsp_cmd_voc_adpcm_send_frame.
08/23/05    ac     Corrected AV Sync behaviour for Real playback
08/18/05    sp     Fixed a data cache related issue by calling
                   mmu_invalidate_data_cache_lines instead of
                   mmu_invalidate_data_cache if FEATURE_NO_CACHE_LINES is not
                   defined.
08/18/05    sp     Fixed a merge problem in qdsp_cmd_pause_pb().
08/16/05    sg     Fixed aacPlus featureization.
08/15/05    ac     Added A/V sync support for Qtv image; fixed bug where sync
                   was not being sent for the first vocoder frame.
08/12/05    hz     Added support for DTX and data requrest time for AMR
                   recording.
08/12/05    hz     Fixed a wrong adpcm function invode in qdsp_cmd_adec.
08/11/05    hz     Added enhanced aac plus support for QTV_AAC.
08/10/05    sm     Changed qdsp_cmd_voc_enc_pkt_drop to signed byte in case of
                   memory corruption.
            sm     Fixed double block write at buffer boundary in G723.
            sm     Fixed problem where pause would cause clip to end early
            sm     Added MPEG4 G723 firmware support.
                   Clear SID packet check once good data is received in G723.
08/04/05    sp     Added support for mixing of qcp audio and voice call.
07/29/05    sm     G723 fixes.
07/28/05    sg     Modified qdsp_cmd_set_audfmt_iir_filter() to support other
                   AAC images. Fixed featurization for WAV playback.
07/26/05    pl     Modified qdsp_cmd_set_audfmt_iir_filter() to support
                   AAC IIR Filter.
07/25/05    sm     Fixed high pitch noise problem with G711 wave playback.
07/22/05    sm     Added Wav A/ULaw support.
07/20/05    sp     Added support for AAC LOAS.
07/15/05   act     Modified qdsp_cmd_codec_gain_ctrl to write codecRxGain
                   for _TUNES and _QSYNTH related images.
07/14/05    hz     Fixed a mis function invoke in qdsp_cmd_adec under
                   FEATURE_VOC_ADPCM.
07/05/05    sm     Added G.723.1 support.
07/05/05    aw     Modified qsynth pcm filter for backward compatiblity.
06/23/05    sm     TTY updates for auto-bypass and VCO/HCO
06/15/05    pl     Modified qdsp_cmd_adec_pause() to clear the QDSP adec
                   interrupt flag when MP3/AAC/RA/WM playback resumes.
06/14/05    hz     Moditified data throughput calculation for windows media
                   based on DSP requirement.
06/13/05    sm     Modified FEATURE_NO_TX_COMFORT_NOISE to mute mic.
06/01/05    sg     Modified to not halve the sample count for images that don't
                   support aacPlus.
05/31/05    aw     Added support for H264D_AMR image.
05/27/05    sp     Added support for BT A2DP profile and ARM based SBC codec.
05/27/05    sg     Added Qcamera and H264d_evrc images to the list that supports
                   A/V sync.
05/25/05   ymc     Fixed uplink buzz sound in EFR/FR/HR DTX mode due to
                   wrong packet length definitions.
           ymc     Fixed uplink packet drops during EFR/FR/HR QCP recording.
05/24/05    sg     Updated A/V sync to support the other vocoder images also.
05/24/05    hz     Added support for MultiMedia/AAC record functionality.
05/18/05    ac     Modified code to support AV sync functionality with MP3,
                   AAC and vocoder playback.
05/17/05    sg     Fixed typo in qdsp_cmd_adec_pause().
05/16/05    hz     Added support for Vocoder image+ADPCM+VFE.
05/13/05    hz     Modified data_thr calculation for Windows Media playback.
05/04/05    aw     Replace PCM filter with IIR filter support for Qsynth.
04/29/05   ymc     Added 4GV NB support.
04/28/05    hz     Fixed a logical bug found after virtual packet length added.
04/22/05    aw     Modified code to check NULL pointer in AudioPP fucntions.
04/21/05    hz     Added VirtualPacketLength support for Windows Media
                   playback.
04/18/05    sm     Added GSM/WCDMA TTY support.
04/01/05    hz     Added support for Enhanced AAC Plus decoder.
03/25/05   ac/sg   Added support for A/V synchronization.
03/24/05    sg     Added support for QDSP_IMAGE_QVP_H263P3_AMR.
03/20/05    aw     Modified code to check the first 35 bits in AMR packets
                   to determine SID_FIRST or SID_UPDATE, only used for playback.
03/10/05    hz     Removed hacks from WMA for flush and pause commands.
03/02/05    aw     Added support for Qconcert, stf; added pp for Qsynth, mp3.
02/22/05    sm     Added G.711 vocoder support.
02/15/05   act     Added support for EC parameter calibration.
02/15/05    sm     Added FEATURE_IIR_FILTER
02/14/05    hz     Added qdsp_cmd_do_memswap(), qdsp_cmd_adec_dme_write() and
                   qdsp_cmd_adec_config_cmd() to support Windows Media Audio
                   decoding;
                   Added corresponding support for Windows Media image.
02/08/05    aw     Added support for H264D_EVRC, QVP_MPEG4_AMR, QVP_MPEG4_EVRC
                   images.
02/05/05    st     Modified qdsp_cmd_set_dls_config() to support HQ DLS.
01/20/05    sg     Un-featureized qdsp_cmd_tx_comfort_noise.
01/11/05    sg     Modified to excluded AMR frames that are received before the
                   desired frame rate is set for recording (CR55212).
12/29/04    sp     Added post processing support for QTV images and minor
                   post processing bug fixes.
12/13/04    sg     Allow NES & comfort noise to be set for incall preview.
12/13/04   ymc     Fixed audio loss problem while recording voice in VT call.
12/03/04    sm     Added FEATURE_VOC_DTMF_DETECT, FR tick removal.
11/31/04    aw     Added support for MP4D_AAC_NO_VPP image.
11/19/04    sp     Added support for Arm Post Processing.
            sg     Added support for QTV and QTV_AAC images. Reduced MP3 low
                   water mark so that errors have a better chance of being
                   detected.
            aw     Added equalizer support on QSynth image.
11/04/04    aw     Added support for DFM SAT on AAC image.
10/27/04    aw     Added support for DFM SAT on QTunes image.
10/19/04    aw     Modified code to only do adpcm stop for Qsynth image.
10/15/04    hz     Added support for QDSP_IMAGE_MP4D_AAC_PLUS.
10/14/04    aw     Modified the code to setup correct YADPCM/PCM adec sample
                   rate. Modified code to setup QGL image interrupt callback
                   function and adec Pan/Volume/Reset. Modified to set certain
                   vocoders params only in supported images.
09/22/04    aw     Added support for in call viewfinder and clean up obsolete
                   code.
09/17/04    sg     Fixed AMR feature-ization.
09/15/04    sm     Added QCP file support for EFR/FR/HR vocoders.
09/01/04    sm     Add packet drop to HR vocoder.
08/27/04    sm     Drop first 2 encoder packets from efr/fr/amr vocoders.
08/19/04    sm     Add FEATURE_GSM_BFI_MUTING, FEATURE_GSM_WCDMA_AMR_PKT_LOG_DSP
           ymc     Added support for new UMTS vocoder packets logging.
                   New log packets contain encFlagWord and decFlagWord and
                   vocoder mode.
08/16/04    sg     Set QDSP_upDmaPathControl to 0x58 for BT support on VT.
08/11/04    st     Modified code to handle any number of separate MIDI command
                   buffers; updated frame_size calculation to handle supported
                   DSP settings for PCM playback.
07/29/04    sm     Transfer EFR/FR voc data on BFIs.
07/22/04    sg     Added workaround to force the DSP to interrupt for data after
                   flush is completed, for AAC and similar images. This is
                   required to minimize audio startup delay after seeking to a
                   new location.
07/08/04    aw     Modified code to enable/disable SBR for AACPlus decoder.
06/23/04    aw     Modified code to support new MP4D_AMR_EVRC_V13K image.
                   Modified dsp interrupt function for graph audio images.
06/17/04    aw     Modified code to support PCM filter for AAC.
06/08/04    aw     Added support for Equalizer and Spectrum analyzer.
                   Remove PCM filter support in AAC image.
06/07/04   ymc     Split QVP_YUV_AMR support into QVP_YUV_AMR_H263 and
                   QVP_YUV_AMR_MPEG4.
06/01/04    aw     Fixed compiler warnings. Added support for H264 image.
05/19/04    aw     Modified code to reset adpcm_read_ptr in adpcm_write.
05/11/04    vp     Merged ADRC and PCM filter support MP3/AAC from
                   MSMSHARED_AVS.00.09.05.02.00. Added support for H263 images.
            sg     Added qdsp_cmd_set_adec_int_cb() so that callback can be
                   updated while in QTUNES state, but still retain the correct
                   buffer pointers.
05/04/04    sm     Added FEATURE_NO_TX_COMFORT_NOISE.
                   Added qdsp_cmd_set_gsm_afe().
04/23/04    aw     Modified code to support VFE_YCBRC camera imaga.
03/22/04    st     Updated qdsp_cmd_pause_midi_seq() and
                   qdsp_cmd_set_vol_midi_seq() to return proper status; updated
                   qdsp_cmd_qsynth_adpcm_stop() to reset the reset flag before
                   disabling adec channel; added support for PCM playback;
                   updated qdsp_cmd_qsynth_adpcm_write() to reduce memcpy()
                   commands; updated qdps_cmd_adec_flush() to reset ADPCM/PCM
                   data structures.
                   Updated qdsp_cmd_master_pan() to set correct parameter for
                   Synth images; removed qdsp_cmd_seq_vol(); added
                   qdsp_cmd_pause_midi_seq() and qdsp_cmd_set_vol_midi_seq();
                   modified qdsp_cmd_adec_pause() to remove sequence parameter
                   and set correct parameter for Synth images; updated
                   qdsp_cmd_adec_chan_pause() to set correct parameter.
03/20/04    aw     Fixed featurization for QCamera in qdsp_cmd_audio_config
                   function. (CR40946) (CR40947)
03/19/04   ymc     Added support for QVP_BAYER_AMR image.
03/05/04    sg     Modified to drop frames for Graph encoders if the frame
                   rates are out of range. Modified qdsp_cmd_end_rec() so
                   that it will not attempt to change comfort noise setting
                   (CR40720).
02/13/04    sg     Merged QDSP services changes from
                   MSMSHARED_AVS.00.05.17.01.18.01.00
02/05/04    aw     Modified code to send stop command when the last set of
                   yadpcm data is not a complete frame.
01/30/04    sg     Modified to support only 32k ADPCM for VFE_BAYER. 8k ADPCM
                   and QCP is no longer support by this firmware.
01/26/04    lg     Added support for multi-sequencer. audioPause is now an array
01/26/04    sg     Modified to set the frame rates correctly when the packet
                   interface is enabled. Set rxVolume for TUNES images to max
                   since adecVolume is being aliased as master volume.
01/21/04    aw     Modified code to support qsynth volume mapping function.
01/19/04    sm     Provide packet data to EFR decoder only if not BFI.
01/06/04    sg     Modified to set certain AAC params for the standalone image
                   only (CR38209).
12/08/03    sg     Modified to support changes in the vocoder PCM interface.
12/03/03    aw     Added audio support for QGL image.
12/02/03    sg     Added support for linear PCM playback.
12/02/03    sg     Set valid frame rates when the vocoder switches images to
                   fix CR30258.
11/24/03    aw     Modified code to pad the last adpcm data and update adec
                   adpcm stop interface. Fixed feature typo.
11/22/03    sg     Added support for RealAudio codec.
11/07/03  aw/st    Modified code to support YADPCM and qsynth hybrid mode.
                   Remove compiler warning.
10/30/03    sm     Fixed compiler warnings.
10/10/03    sg     Added support for MP4D_MP3 image. Modified to check the DSP
                   status before writing ADEC data for MP3, AAC (CR33889).
                   Added support for additional AAC data formats.
            aw     Added MSMAUD_VOC_AMR_COMMON featurization.
10/03/03   ymc     Added support for QDSP_IMAGE_QVP_YUV_AMR.
08/26/03    sg     Replaced qdsp_cmd_check_valid_rates() with
                   qdsp_cmd_set_rec_frame_rates().
            sg     Modified to support high and low priority vocoder clients
                   (vis-a-vis QDSP Services).
            st     Added qdsp_cmd_check_valid_rates() for MP4E images.
          sg/st    Force odd trailing byte to be written to the DSP for ADEC
                   data. Fixed feature-ization for select_vocoder() funcs.
            st     Added support for MP4E and MP4E_BAYER images.
           ymc     Removed PVCSPath.
07/21/03    sg     Added support for VFE_BAYER camera image.
06/18/03   ymc     Fixed featurization for QDSP_VOC_MODE_xxx_V.
05/20/03   ymc     Moved WCDMA AMR packet swapping to mvssup for fixing
                   garbled voice in GSM AMR mode.
05/12/03   ymc     Fixed AMR rate bug during voice recording.
           ymc     Added GSM half rate support.
           ymc     Removed WVS support.
           ymc     Removed next amr mode setting in AMR uplink packet xchg.
           ymc     Replaced FEATURE_GSM and FEATURE_WCDMA with MSMAUD_VOC_*.
           ymc     Split up qdsp_cmd_gsm_voc_qdsp_isr.
05/06/03    sa     Added support for Audio dubbing images.
04/18/03    aw     Added audio support for Q3D image.
04/17/03    st     Fixed AMR featurization.
04/17/03    sm     Updated amr uplink func for new MVS; added support for AMR
            st     for both MP4E and MP4D; added support for ADPCM for MP4E
                   images.
            sg     Modified to set the FM SatDcOffset. Added support for
                   vocoder PCM interfaces.
03/21/03    st     Added support for 13K/EVRC for MPEG4 encoder.
                   Added proper featurization for AMR code.
03/13/03    st     Removed specific MP4 decoder support, no longer necessary
                   with new MP4D interface; added support for MP4D+AAC and MP4E.
03/10/03    st     Modified code to implement a pause state for graphics
                   ADPCM mode; modified code to fix resetting of
                   qdsp_cmd_rec_frame_fn until after state has been updated;
                   modified code to use 32-bit value in INTLOCK_SAV().
02/28/03    st     Modified code to fix reference to QDSP_IMAGE_AAC.
02/19/03    st     Modified code to support ADPCM playback with various DSP
                   images.
01/23/03    sm     Featurized AMR record/playback under MSMAUD_VOC_AMR.
01/20/03    st     Merged GSM vocoder bug fixes: Added featurization to remove
                   compiler warnings/errors; modified code to set packet length
                   in qdsp_cmd_gsm_voc_qdsp_isr().
01/05/03    st     Modified to support EFR and FR vocoders.
12/08/02    st     Modified code to add proper featurization in
                   qdsp_cmd_gsm_voc_qdsp_isr() and qdsp_cmd_register();
                   modified code to not write codecTxGain, codecSTGain and
                   QDSP_upDmaPathControl for graphics images.
12/03/02    st     Modified code to add support for audio for graphics images.
11/19/02    st     Added qdsp_cmd_synth_mvol() and qdsp_cmd_adec_mvol()
                   functions.
11/18/02   ymc     Solved AMR rate conflict between voice call and recording.
           ymc     Unfeaturized qdsp_cmd_temp_packet.
            st     Fixed encoder rate settings in qdsp_cmd_start_rec();
                   removed duplicate txVolume setting in qdsp_cmd_vol_ctrl().
11/06/02    sm     Added QCP AMR support.
09/09/02   ymc     Added FEATURE_MVS.
09/05/02    sm     Added MSMAUD_SEL_PCM_PATH_NORM.
08/23/02    sg     Added support for DSP_IMAGE_VOC_EVRC_DEFINED; modified to
                   use FEATURE_EXTERNAL_SDAC.
08/22/02    sg     Added support for TTY activity status indication.
                   (Merged from MSM_AVS.01.05.18.01.02).
08/13/02  aw/st    Added support for ADPCM audio decoder type for QSynth
                   image; modified debug MSG level.
            st     Reduced the QSynth command buffer size from 256 to 128.
          sg/st    Modified so that the DSP ADEC data interrupt is cleared
                   only when data is written to the ADEC buffer. This fixes
                   the problem of receiving multiple interrupts even when
                   no data was written.
                   Fixed qdsp_cmd_adec_write to update data_ptr correctly so
                   that the last remaining (odd) byte (if any) can be
                   written correctly to the DSP.
                   Added support for MP4 and AAC.
07/09/02    sm     Synced with perforce tip.
            sm     Use ifdef(voc_defined) rather than defined(voc_defined).
           ymc     Used UMTS vocoder log codes from log_codes_umts.h
06/18/02    sg     Enabled half duplex EC in SPEAKER mode.
05/21/02   jkl     Fixed qdsp_cmd_set_pufe_config.
03/21/02    st     Fixed check for states in capture_start(); modified code
                   to buffer MIDI commands and issue them when DSP is ready to
                   receive them; added support for MSMAUD_CODEC_CLOCK_CTRL.
03/12/02    st     Obsoleted FEATURE_NEW_SYNTH; modified code to support new
                   QSynth image interface; modified code to have ADEC functions
                   comply with new DSP parser changes; modified
                   qdsp_cmd_dfm_config() to not write to fmDeviationLimits for
                   the synth image.
03/04/02   jkl     Added FEATURE_VR_PUFE.
02/13/02   jkl     Updated VR for new parser support.
01/25/02    sm     Updated for new parser support.
01/15/02   ymc     Added GSM and WCDMA support.
           ymc     Updated copyright.
12/11/01    ro     Use msmaud.h to eliminate targetization.
11/02/01    sg     Force 1/8th rate NULL frames to be sent to voc_tx_cmd if
                   packet interface is in use. Also, drop frames from voc_rx_cmd
                   when the packet interface is in use.
10/29/01    sg     Added packet interface support.
10/29/01    st     Modified qdsp_cmd_voc_qdsp2_isr() to send erasure to decoder
                   in place of EVRC 1/8th rate NULL frames.
10/08/01    st     More cleanup.
10/05/01  ro/st    Cleanup some comments and defines.
10/02/01    st     Modified code to be backwards compatible with older DSP
                   images.
10/01/01    st     Modified code to support multiple ADEC channels.
09/19/01    st     Modified qdsp_cmd_voc_qdsp2_isr() to check proper flag
                   before calling callback function.
09/16/01    st     Modified qdsp_cmd_vol_ctrl() in order to clean up if
                   statement for Tx comfort noise enable setting.
09/14/01    aw     Fixed FEATURE_ACP featurization.
09/11/01  st/aw    Modified code to handle voice prompt paused state properly
                   in decoder ISR; modified QSynth ADRC settings to handle
                   new DSP API.
09/04/01    aw     Added FEATURE_QSYNTH_ADRC. Added functions for QSynth PCM
                   filter and ADRC configuration.
09/03/01    st     Modified code to correct featurization; redesigned vocoder
                   packet recording to: not require recording forward
                   link (or playing reverse link) in DFM to be handled
                   specially by client, handle pause/resume mechanism properly.
08/14/01   ymc     Rename QDSP_ppgUpDmaPathControl as QDSP_upDmaPathControl.
07/24/01   ymc     Use qdsp_gen_interrupt to generate the vocoder frame
                   reference.
                   Added support for loopback tests.
07/12/01   jkl     Fixed qdsp_cmd_dfm_config.
06/18/01  jkl/ym   Added FEATURE_ACP. Replaced FEATURE_DFM_ANSWER_MACHINE.
05/30/01    sm     Added frame reference strobe command.
05/28/01    sm     Enhanced QDSP_PACKET_SNIFFER to support log 7 iface.
05/22/01   jkl     Fixed featurization.
05/21/01   jkl     Removed Enhanced VR feature.
05/18/01    sm     Added TTY support for MSM5100.
05/08/01   jkl     Fixed dma_path control to 0 for VR Codec Configuration.
05/07/01    sm     Added QDSP_PACKET_SNIFFER.
04/26/01    st     Modified code to add proper featurization; modified code to
                   write proper value to QDSP_adecReset; modified code in
                   qdsp_cmd_rx_frame() to copy the frames at byte boundary;
                   modified code in qdsp_cmd_resume_rec() to restore
                   txComfortNoise setting if we are recording forward link.
04/26/01    sm     Support MP3 on MSM5100.  Removed qdsp_cmd_adec_int_speed()
04/04/01    st     Modified code to support new FEATURE_MIDI_OUT feature;
                   modified code to ignore the DTMF retry command if we are
                   no longer in QSynth state; added qdsp_cmd_adec_reset();
                   modified code to verify that we have enough data to give
                   to the QSynth audio decoder.
02/28/01    st     Modified code in qdsp_cmd_adec() to check for size of
                   second buffer; lint updates.
02/22/01    ro     Remove QDSP_UP_TO_DSP_IRQ and use qdsp_up_to_dsp_irq().
02/21/01    vl     Added MSM5100 support.
01/26/01    st     Modified code to implement a DTMF command retry for the
                   QSynth image.
12/20/00   jkl     Added proper featurization for vr_packet_buf.
12/10/00    st     Removed qdsp_cmd_enc_isr_not_ready_count and
                   qdsp_cmd_dec_isr_not_ready_count; added proper featurization
                   and comments throughout file; added VRA isr to isr table;
                   removed improper calls to qdsp_cmd_set_isr(); modified
                   qdsp_cmd_enc_ctrl() such that MinRate and MaxRate are not
                   written to the DSP, just saved so that it can be written
                   at a later time.
12/06/00   jkl     Removed set ISR functions.
12/05/00   jkl     Merged VR4.0 functions. Added FEATURE_ENHANCED_VR,
                   FEATURE_DFM_ANSWER_MACHINE.
12/04/00    sm     Optimized mp3 playback, added master_volume(), master_pan().
                   Flush when in proper image.  Check fr.rate before recording.
                   Added adec_error(), adec_int_speed(), mp3_target_header()
          st/sm    Merged ADEC support, separated QDSP2 ISR routines.
11/07/00    st     Removed address verification in qdsp_cmd_ec_ctrl() again.
11/06/00    st     Removed address verification in qdsp_cmd_ec_ctrl().
10/27/00    st     Modified code to remove compiler warnings.
10/18/00    sm     Uses new QDSP Services support functions.
10/13/00   ymc     Added MSM5105 support; T_MSM33 as T_MSM33 && !T_MSM5105;
                   !T_MSM33 as !T_MSM33 || MSM5105.
                   Removed target dependencies in qdsp_cmd_ec_ctrl.
10/04/00   ymc     Removed msm??reg.h include header, use general msm.h instead.
09/21/00    sm     Return if NULL passed to codec_config.
                   Remove write to dma path control for PPG.
09/18/00    sm     Write dma path control in PPG qdsp anyway for back compat.
09/08/00    sm     Added Bluetooth/PPG support.
08/28/00    ro     Uses QDSP Services.
                   Added qdsp_cmd_register and qdsp_cmd_set_isr.
                   Removed qdsp_cmd_sw_reset and qdsp_cmd_valid_addr.
                   Removed qdsp_cmd_clear_filter_load.
08/22/00    ro     Set QDSP_ecFarendHangoverThres to 100msec for AEC mode.
08/17/00    ro     Modified qdsp_cmd_get_diags to remove un-supported variables.
                   Removed qdsp_cmd_reset_mips.
                   Update recording and capture functions to make
                   microphone muting control interrupt-safe.
08/14/00   spf     Updated codec configuration command for PPG.
                   Fixed target featurization and QDSP_ecFarCoeff address
                   check in qdsp_cmd_ec_ctrl().
07/15/00    st     Lint updates; changed some MSG_ERROR() calls with MSG_HIGH()
                   because those situations are no longer invalid with the
                   QSynth image.
07/14/00   spf     Updated speakerphone echo canceller in qdsp_cmd_ec_ctrl().
                   Lint updates.
06/30/00   spf     Added qdsp_cmd_nes_ctrl().
06/19/00   spf     Updated to use an enumeration for image selection.
06/16/00    sm     avsRlinkSensitivityOffset is a 16-bit word.
06/11/00   spf     Support for firmware image featurization.
05/16/00    st     Modified qdsp2_command() to write command type after writing
                   message, this is used as a semaphore between ARM and QDSP2;
                   added support for QSynth image; added support for stereo
                   DAC; modified swap such that source and dest can be the same;
                   modified qdsp_cmd_midi to write volume every time function
                   is called, CR13463.
05/12/00   spf     Add PPG support.
05/02/00    st     Added call to vre_endpoint_abort() in
                   qdsp_cmd_stop_capture().
05/02/00   spf     Added initial support for speakerphone echo canceller.
            sm     Added qdsp_cmd_hpf_ctrl().
03/28/00    sm     AAGC mainline.
02/09/00    tc     Enabled quarter rate if 3 out of 8 frames are quarter rate.
02/02/00    tc     Unmuted tx for reverse link recording only.
01/27/00    tc     Added FEATURE_PHONE_VR for qdsp_cmd_vr_basic.
01/26/00    tc     Added VR Mode A support.
01/12/00    tc     Moved dfm tramp_set_isr to qdsp_cmd_dfm_go().
12/07/99   spf     Added qdsp_cmd_valid_addr().  Check that DEC_INT_ADVANCE
                   does not match Rx Budget.
12/01/99   spf     Run-time image selection support.
                   Merged with 1.20.1.0: Fixed write to agc sensitivity.
11/30/99   spf     Removed Rx Budget override.
11/22/99   jkl     Updated AGC/AVC functions.
11/17/99   jkl     Initialize AUX_PCM_CLK to be HIGH Level for 5GP Headset.
10/28/99   spf     Initialize Rx Budget in vocoder timing command.
10/18/99    st     Featurized audio AGC/AVC feature.
10/14/99    tc     Added qdsp_cmd_clear_filter_load().
10/07/99   spf     Added qdsp_cmd_clear_sat_dcc().  Backed out RX Budget
                   update in vocoder timing command.
09/25/99    ro     Update RX Budget in vocoder timing command.
09/16/99   spf     Removed FEATURE_QDSP_INTERNAL_CODEC
09/10/99   spf     Commented out CODECPLL register definitions
09/09/99    tc     Add internal codec gain control
09/02/99    tc     Add qdsp software reset function
08/30/99    tc     Add get dfm SatDcc value function
08/27/99    tc     Rx Avc and Tx Agc changes
08/26/99    tc     Pink Panther revision 2 changes
07/19/99    tc     Update code review comments
07/15/99    tc     DFM support
06/17/99    tc     Initial Version

===========================================================================*/

/* <EJECT> */
/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/

#include "msmaud.h"             /* MSM Specific audio features             */
#include "qdsp.h"
#include "qdspcmd.h"            /* QDSP Driver Command Layer definitions   */
#include "qdspext.h"            /* QDSP firmware image definintion         */
#ifdef FEATURE_CMI
#error code not present
#else
#include "clk.h"
#endif
#ifdef FEATURE_CMI_MM
#error code not present
#endif

/* Clock prototypes                        */
#include "msg.h"                /* Message logging macro                   */
#include "err.h"                /* Error logging macro                     */
#include <string.h>             /* String/Memory manipulation routines     */
#include <stdlib.h>             /* Malloc/Free routines                    */

#ifdef FEATURE_PHONE_VR
#include "vrengine.h"           /* Voice-Recognition Engine                */
#ifdef FEATURE_VR_PUFE
#error code not present
#endif /* FEATURE_VR_PUFE */
#endif /* FEATURE_PHONE_VR */

#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */

#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */

#if defined(FEATURE_ARM_POST_PROCESSING) || defined(FEATURE_MM_REC) || \
defined(FEATURE_AVS_WB_PCM_RX_INTERFACE)
#include "cache_mmu.h"
#endif

#ifdef QDSP_PACKET_SNIFFER
#include "log.h"
#endif /* QDSP_PACKET_SNIFFER */

#ifdef FEATURE_PCM_PKT_LOG
#include "log_codes.h"
#endif /* FEATURE_PCM_PKT_LOG */

#include "vocdata.h"
#include "vocstate.h"
#include "vocvp3.h"

#ifdef MSMAUD_SCMM
#error code not present
#endif /* MSMAUD_SCMM */

/* <EJECT> */
/*===========================================================================

                DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains definitions for constants, macros, types, variables
  and other items needed by this module.

===========================================================================*/
/* This delta gain value will be verified once permanent fix is in place */
static uint16 qdsp_deltaRxGain = 35;

/* Variables used to register with qdsp_services
*/
qdsp_event_cb_type qdsp_event_cb;
uint16             qdsp_event_mask;

typedef void (* qdsp_cmd_isr_func_type) (void);
qdsp_cmd_isr_func_type qdsp_cmd_image_isr_table[QDSP_IMAGE_MAX];
qdsp_cmd_isr_func_type qdsp_cmd_isr_table[QDSP_ISR_MAX] = {NULL, NULL};
LOCAL qdsp_image_type  qdsp_cmd_image_select = QDSP_IMAGE_MAX;
LOCAL qdsp_module_type qdsp_cmd_module_select = QDSP_MODULE_MAX;

/* Mapping of virtual vocoder client ids to QDSPS App ids. */
qdsp_app_type qdsp_cmd_qdsps_clients[QDSP_CMD_QDSPS_CLIENT_MAX];

#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */

/* ARM controlling AUX_PCM clock */
#ifdef MSMAUD_INIT_AUX_CODEC
LOCAL boolean qdsp_cmd_arm_ctrl_aux_pcm_clk = FALSE;
#endif
#ifdef FEATURE_AUDIO_ISDBT_DUAL_MONO
/* caution: 0xABAB initized, to distinguish initial value from non dual mono */
#define QDSP_DUAL_MONO_INIT_VALUE 0xABAB
static qdsp_cmd_dualmono_cb_type  qdsp_cmd_codec_update_cb_funcptr = NULL;
static uint16 qdsp_audio_current_mode = QDSP_DUAL_MONO_INIT_VALUE;
#endif

/* <EJECT> */
/*===========================================================================

                       ARM TO QDSP COMMAND DEFINITIONS

===========================================================================*/
/* Command buffer sizes are in 16-bit words.
** Length includes the size and the command code.
*/

/* Maximum command buffer size */
#ifdef FEATURE_PHONE_VR
#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
#define QDSP2_MAX_BUF_LENGTH         10
#else
#define QDSP2_MAX_BUF_LENGTH         9
#endif
#else
/*modified max buf len for wma_pro support*/
#define QDSP2_MAX_BUF_LENGTH         13
#endif /* FEATURE_PHONE_VR */

/* Minimum command buffer size */
#define QDSP2_MIN_BUF_LENGTH         2

/*===========================================================================

                             BIOS SYSTEM COMMANDS

===========================================================================*/

/* Sleep Command - Requests the DSP to go to low power mode */
#define SLEEP_CMD_SIZE               2
#define SLEEP_CMD_HDR                0x0002 /* Command type */

/* Loopback Test Command - Configures loopback test modes */
#define LOOPBACK_TEST_CMD_SIZE       3
#define LOOPBACK_TEST_CMD_HDR        0x0005 /* Command type */

/* IDLE Command - Request the DSP to go to IDLE state */
#define IDLE_CMD_SIZE                2
#define IDLE_CMD_HDR                 0x0007 /* Command type */

/*===========================================================================

                            MODEM MODULE COMMANDS

===========================================================================*/

/* Vocoder Configuration Command */
#if  defined(QDSP_IMAGE_VOC_COMBO_DEFINED) || defined(QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED)
#define VOC_CONFIG_CMD_SIZE          5
#else
#define VOC_CONFIG_CMD_SIZE          3
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#define VOC_CONFIG_CMD_HDR           0x0100 /* Command type */

#ifdef FEATURE_GRAPH_AUDIO
/* Vocoder Select command for graphics images with selectable vocoders */
#define VOC_SELECT_CMD_SIZE          3
#define VOC_SELECT_CMD_HDR           0x0300 /* Command type */

/* Audio Configuration Command for graphics images */
#ifdef FEATURE_GRAPH_ADPCM
/* Audio config command with ADPCM support is 3 words larger than without */
#define AUDIO_CONFIG_CMD_SIZE        6
#else
#define AUDIO_CONFIG_CMD_SIZE        3
#endif /* FEATURE_GRAPH_ADPCM */
#define AUDIO_CONFIG_CMD_HDR         0x0303 /* Command type */
#endif /* FEATURE_GRAPH_AUDIO */

#ifdef FEATURE_MM_REC
#define MM_ENCODER_CONFIG_CMD_SIZE   8      /* Size of DSP encoder command */
#define MM_ENCODER_CONFIG_CMD_HDR    0x0304 /* DSP encoder command type    */
#define MM_AUDIO_CONFIG_CMD_SIZE     2      /* Size of DSP audio command   */
#endif /* FEATURE_MM_REC */

/* Vocoder Timing Command - Commands the DSP to look for the frame reference */
#define VOC_TIMING_CMD_SIZE          5
#define VOC_TIMING_CMD_HDR           0x0101 /* Command type */

/* Frame Reference Command - Manually provide the frame reference strobe */
#define VOC_FRAME_REFERENCE_CMD_SIZE 2
#define VOC_FRAME_REFERENCE_CMD_HDR  0x0306  /* Command type */

/* DFM Configuration Command - Command the DSP to transition to DFM state */
#define DFM_CONFIG_CMD_SIZE          2
#define DFM_CONFIG_CMD_HDR           0x0200 /* Command type */

/*===========================================================================

                       AUDIO FRONT END MODULE COMMANDS

===========================================================================*/

/* Codec Configuration Command */
#ifdef MSMAUD_UP_DMA_PATH_CONTROL
#define CODEC_CONFIG_CMD_SIZE         8
#else
#define CODEC_CONFIG_CMD_SIZE         7
#endif /* MSMAUD_UP_DMA_PATH_CONTROL */
#define CODEC_CONFIG_CMD_HDR          0x0301 /* Command type */

#ifdef QDSP_IMAGE_JPEGD_DEFINED
#define CODEC_PCM_FORMAT_CTRL_JPEGD                 0x22
#define CODEC_RESERVED_JPEGD_DTMF_HW_UPSAMPLE       0x1
#endif /*QDSP_IMAGE_JPEGD_DEFINED*/

#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
#define CODEC_CONFIG_CMD_SIZE_MIXER   9
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB */

/* DTMF Tone Request Command - Command to enable/disable DTMF tone generation */
#define DTMF_TONE_REQUEST_CMD_SIZE    7
#define DTMF_TONE_REQUEST_CMD_HDR     0x0302 /* Command type */
#ifdef FEATURE_GRAPH_AUDIO
#define GRAPH_DTMF_TONE_REQUEST_CMD_SIZE    6
#endif /* FEATURE_GRAPH_AUDIO */

/* Sample Slipping Configuration Command - Used for manual sample slipping */
#define SAMPLE_SLIP_CONTROL_CMD_SIZE  3
#define SAMPLE_SLIP_CONTROL_CMD_HDR   0x0304 /* Command type */

#ifdef FEATURE_AUDIO_PCR_SUPPORT
/* Sample Adjusting Configuration Command - adjusting sample for PCR sync*/
#define QDSP_CMD_PCR_SAMPLE_ADJUST_CMD_SIZE  3
#define QDSP_CMD_PCR_SAMPLE_ADJUST_CMD_HDR   0x0303   /* Command type */
#define QDSP_CMD_PCR_ADD_SAMPLE              0x01     /* command */
#define QDSP_CMD_PCR_DROP_SAMPLE             0xFFFF   /* command */
#endif /* FEATURE_AUDIO_PCR_SUPPORT */

/*===========================================================================

                       AUDIO FRONT END MODULE MESSAGES

===========================================================================*/
#ifdef FEATURE_ACP
#error code not present
#endif  /* FEATURE_ACP */

#ifdef FEATURE_VOC_DTMF_DETECT

/* DTMF detect message - generated only after dtmfDetectSwitch is enabled */
#define QDSP_CMD_DTMF_DETECT_MSG       0x0305  /* Message type */
#define QDSP_CMD_DTMF_DETECT_MSG_SIZE  2
#endif /* FEATURE_VOC_DTMF_DETECT */

#ifdef FEATURE_ADEC
/*===========================================================================

                             ADEC MODULE COMMANDS

===========================================================================*/

/* Bitstream Flush Command */
#define BITSTREAM_FLUSH_CMD_SIZE     3
#define BITSTREAM_FLUSH_CMD_HDR      0x0308 /* Command type */

#define ADEC_CONFIG_CMD_SIZE 7 /*WMA Command size*/
#define ADEC_CONFIG_CMD_WM_PRO_SIZE   13 /* Altered size to fit WMA/WMApro*/
#define ADEC_CONFIG_CMD_HDR  0x0304

#endif /* FEATURE_ADEC */

#ifdef FEATURE_AUDIO_QENSEMBLE
#error code not present
#endif /* FEATURE_AUDIO_QENSEMBLE */

#ifdef FEATURE_AUDFMT_QCONCERT
/*==============================================================================

                        AUDIO POST PROCESSING RESET COMMANDS

==============================================================================*/

#define AUDIO_PP_RESET_CMD_HDR       0x0309  /* Audio PP reset cmd */
#define AUDIO_PP_RESET_CMD_SIZE      2

#endif /* FEATURE_AUDFMT_QCONCERT */

#ifdef FEATURE_SBC_DSP_CODEC
#define SBC_CONFIG_CMD_SIZE_MAX  4
#define SBC_CONFIG_CMD_SIZE  3
#define SBC_CONFIG_CMD_HDR   0x310

#ifdef FEATURE_AVS_I2SSBC
#define I2SSBC_CONFIG_CMD_SIZE  4
#define I2SSBC_CONFIG_CMD_HDR   0x311
#endif /* FEATURE_AVS_I2SSBC */

#endif /* FEATURE_SBC_DSP_CODEC */
/*==============================================================================

                        ARM POST PROCESSING COMMANDS

==============================================================================*/
#ifdef FEATURE_ARM_POST_PROCESSING
/* Enable the interface */

#define QDSP_CMD_ARM_PP_DME_TO_DSP_DONE                   0x0002
#define QDSP_CMD_ARM_PP_RESET_FRAME_CNTR                  0x0000

#define QDSP_CMD_ARM_PP_DATA_READY                        0xFFFF
#define QDSP_CMD_ARM_PP_DATA_NOT_READY                    0x0000

#define QDSP_CMD_ARM_PP_BUFFER_DSP_READ_PEND              0x0008
#define QDSP_CMD_ARM_PP_BUFFER_DSP_READ_DONE              0x0010

#endif /* FEATURE_ARM_POST_PROCESSING */

#if defined(FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)

#define QDSP_CMD_ARM_PP_ENA_V                             0xFFFF
#define QDSP_CMD_ARM_PP_SBC_ENA_V                         0xFFFF

/* Disable the interface */
#define QDSP_CMD_ARM_PP_DIS_V                             0x0000
#define QDSP_CMD_ARM_PP_SBC_DIS_V                         0x0000
#define QDSP_CMD_ARM_PP_BUF_FULL                          0xFFFF
#define QDSP_CMD_ARM_PP_BUF_AVAILABLE                     0x0000

#define QDSP_CMD_ARM_PP_DME_TO_ARM_DONE                   0x0001
#define QDSP_CMD_ARM_PP_CLR_DME_FLAG                      0x0000

#ifdef FEATURE_SBC_DSP_CODEC
#define QDSP_CMD_SBC_CLR_DME_FLAG                         0x0004
#endif

#define QDSP_CMD_ARM_PP_BUFFER_FREE                       0x0000
#define QDSP_CMD_ARM_PP_BUFFER_ARM_READ_PEND              0x0002
#define QDSP_CMD_ARM_PP_BUFFER_ARM_READ_DONE              0x0004
#define  QDSP_CMD_ARM_PP_STATE_BUF_FULL                   0x0001
#define  QDSP_CMD_ARM_PP_STATE_BUF_AVAIL                  0x0002

#define QDSP_CMD_ARM_PP_MIN_BUF_SIZE      2048
#define QDSP_CMD_ARM_PP_BUF_SIZE_1        (QDSP_CMD_ARM_PP_MIN_BUF_SIZE)
#define QDSP_CMD_ARM_PP_BUF_SIZE_2        (QDSP_CMD_ARM_PP_MIN_BUF_SIZE *2)
#define QDSP_CMD_ARM_PP_BUF_SIZE_4        (QDSP_CMD_ARM_PP_MIN_BUF_SIZE *4)
#define QDSP_CMD_ARM_PP_BUF_SIZE_8        (QDSP_CMD_ARM_PP_MIN_BUF_SIZE *8)
#define QDSP_CMD_ARM_PP_BUF_SIZE_16       (QDSP_CMD_ARM_PP_MIN_BUF_SIZE *16)
#define QDSP_CMD_ARM_PP_MAX_BUF_SIZE      (QDSP_CMD_ARM_PP_MIN_BUF_SIZE * 16)

#define QDSP_CMD_ARM_PP_NUM_BUF_SIZE_1    32
#define QDSP_CMD_ARM_PP_NUM_BUF_SIZE_2    (QDSP_CMD_ARM_PP_NUM_BUF_SIZE_1 >> 1)
#define QDSP_CMD_ARM_PP_NUM_BUF_SIZE_4    (QDSP_CMD_ARM_PP_NUM_BUF_SIZE_2 >> 1)
#define QDSP_CMD_ARM_PP_NUM_BUF_SIZE_8    (QDSP_CMD_ARM_PP_NUM_BUF_SIZE_4 >> 1)
#define QDSP_CMD_ARM_PP_NUM_BUF_SIZE_16   (QDSP_CMD_ARM_PP_NUM_BUF_SIZE_8 >> 1)

#define QDSP_CMD_ARM_PP_NUM_BUF_MAX       QDSP_CMD_ARM_PP_NUM_BUF_SIZE_1
#define QDSP_CMD_ARM_PP_NUM_BUF_MIN       QDSP_CMD_ARM_PP_NUM_BUF_SIZE_16

#define QDSP_CMD_ARM_PP_BUFFER_SIZE_MAX  (QDSP_CMD_ARM_PP_NUM_BUF_MIN * \
                                          QDSP_CMD_ARM_PP_MAX_BUF_SIZE)

typedef enum {
  QDSP_CMD_ARM_PP_BUF_TYPE_1,
  QDSP_CMD_ARM_PP_BUF_TYPE_2,
  QDSP_CMD_ARM_PP_BUF_TYPE_4,
  QDSP_CMD_ARM_PP_BUF_TYPE_8,
  QDSP_CMD_ARM_PP_BUF_TYPE_16,
  QDSP_CMD_ARM_PP_BUF_TYPE_MAX
}qdsp_cmd_arm_pp_buf_enum_type;

typedef struct {
  uint16 flag;
  uint16* buf_ptr;
}qdsp_cmd_pp_buffer_desc_type;

typedef struct {
  uint16 num_buf;
  uint16 buf_size;
  qdsp_cmd_pp_buffer_desc_type desc[QDSP_CMD_ARM_PP_NUM_BUF_MAX];
}qdsp_cmd_pp_buf_mgr_type;

typedef enum {
  QDSP_CMD_PP_BUFFER_TYPE_READ,
#ifdef FEATURE_ARM_POST_PROCESSING
  QDSP_CMD_PP_BUFFER_TYPE_WRITE
#endif
}qdsp_cmd_pp_buffer_type_type;

#endif /* FEATURE_ARM_POST_PROCESSIG || FEATURE_AVS_WB_PCM_RX_INTERFACE */


/*VP3 definitions*/
  #define QDSP_CMD_VP3_CONFIG_CMD_SIZE         7
  #define QDSP_CMD_VP3_CONFIG_CMD_HDR          0x306
  #define QDSP_CMD_VP3_UPDATE_MSG_VAL          0xffff
  #define QDSP_CMD_VP3_UPDATE_ACK_VAL          0


#if defined(FEATURE_SBC_DSP_CODEC) && defined(FEATURE_AVS_I2SSBC)
qdsp_cmd_i2ssbc_sample_rate_type qdsp_cmd_i2ssbc_sample_rate =
                                            QDSP_CMD_I2SSBC_SAMPLE_RATE_48000;
#endif /* FEATURE_SBC_DSP_CODEC && FEATURE_AVS_I2SSBC */
#ifdef FEATURE_PHONE_VR
/*===========================================================================

                              VR MODE A COMMANDS

===========================================================================*/

/* VR Basic Command */
#define VR_BASIC_CMD_SIZE            3
#define VR_BASIC_CMD_HDR             0x1002 /* Command type */

#ifdef FEATURE_VR_PUFE
#error code not present
#else
/* VR Diagnostic buffer length */
#define QDSP2_VR_BUF_LENGTH          42
#endif /* FEATURE_VR_PUFE */

#endif /* FEATURE_PHONE_VR */
#if defined( FEATURE_ACP ) && \
    (defined( FEATURE_VOICE_RECORD ) || defined( FEATURE_VOICE_PLAYBACK))
#error code not present
#endif /* FEATURE_ACP && (FEATURE_VOICE_RECORD || FEATURE_VOICE_PLAYBACK) */

typedef enum {
  QDSP_CMD_PKT_DIR_TX,
  QDSP_CMD_PKT_DIR_RX,
  QDSP_CMD_PKT_DIR_BOTH,
  QDSP_CMD_PKT_DIR_MAX
} qdsp_cmd_pkt_dir_enum_type;

/* <EJECT> */
/* Type describing the size of a frame, indexed by the rate returned
** by the hardware.
*/

 /* Array elements are the number of bytes required for the packet
 ** for EVRC
 */
 byte const voc_qdsp2_packet_size_EVRC[] = {
  0,                                      /* Blank        */
  2,                                      /* Eighth rate  */
  0,                                      /* Quarter rate */
  10,                                     /* Half rate    */
  22,                                     /* Full rate    */
  0                                       /* Erasure      */
};

 /* Array elements are the number of bytes required for the packet
 ** for 13K
 */
 byte const voc_qdsp2_packet_size_13k[] = {
  0,                                      /* Blank        */
  3,                                      /* Eighth rate  */
  7,                                      /* Quarter rate */
  16,                                     /* Half rate    */
  34,                                     /* Full rate    */
  0                                       /* Erasure      */
};

#ifdef MSMAUD_VOC_4GV
 /* Array elements are the number of bytes required for the packet
 ** for 4GV
 */
 byte const voc_qdsp2_packet_size_4GV[] = {
  0,                                      /* Blank        */
  2,                                      /* Eighth rate  */
  5,                                      /* Quarter rate */
  10,                                      /* Half rate    */
  22,                                     /* Full rate    */
  0                                       /* Erasure      */
};
#endif  /* MSMAUD_VOC_4GV */

#ifdef MSMAUD_VOC_4GV_WB
 /* Array elements are the number of words required for the packet
 ** for 4GV_WB
 */
 byte const voc_qdsp2_packet_size_4GV_WB[] = {
  0,                                      /* Blank        */
  2,                                      /* Eighth rate  */
  5,                                      /* Quarter rate */
  10,                                      /* Half rate    */
  22,                                     /* Full rate    */
  0                                        /* Erasure      */
};
#endif  /* MSMAUD_VOC_4GV_WB */

#if defined(MSMAUD_VOC_AMR_COMMON) || defined(MSMAUD_VOC_EFR) \
    || defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_HR)

/* Array elements are the number of bytes required for the packet
** for AMR, extra defines for packets outside SPEECH_GOOD.
*/
byte const voc_qdsp2_packet_size_amr[] = {
  12,                /* 4.75k        */
  13,                /* 5.15k        */
  15,                /* 5.9 k (low)  */
  17,                /* 6.7 k        */
  19,                /* 7.4 k        */
  20,                /* 7.95k        */
  26,                /* 10.2k (high) */
  31                 /* 12.2k        */
};

#define PACKET_SIZE_AMR_BAD 0
#define PACKET_SIZE_AMR_SID 3
#define PACKET_SIZE_AMR_SID_BYTES 5

/* In normal voice decoding process, all 17 words will be passed to DSP
   independent of frame type.
*/
#define PACKET_SIZE_GSM_BAD        0
#define PACKET_SIZE_GSM_EFR_SPEECH 16
#define PACKET_SIZE_GSM_EFR_SID    16
#define PACKET_SIZE_GSM_FR_SPEECH  17
#define PACKET_SIZE_GSM_FR_SID     17
#define PACKET_SIZE_GSM_HR_SPEECH  7
#define PACKET_SIZE_GSM_HR_SID     7

#endif /* MSMAUD_VOC_AMR_COMMON || MSMAUD_VOC_EFR ||
          MSMAUD_VOC_FR || MSMAUD_VOC_HR */

#if defined(MSMAUD_VOC_AMR_COMMON) || defined(MSMAUD_VOC_AMR_WB_COMMON)
/* Temp solution: Used to differentiate SID_UPDATE or SID_FIRST,
** SID_FIRST, first 35 bits of comfort-noise data are Zero.
*/
LOCAL const uint8 qdsp_cmd_sid_first_data[] = { 0, 0, 0, 0, 0};
#endif /* MSMAUD_VOC_AMR_COMMON || MSMAUD_VOC_AMR_WB_COMMON */

#ifdef MSMAUD_VOC_AMR_WB_COMMON

/* no. of words of packet for each rate */
byte const voc_qdsp2_packet_size_amr_wb[] = {
  17,                 /*  6.60 kbps */
  23,                 /*  8.85 kbps */
  32,                 /* 12.65 kbps */
  36,                 /* 14.25 kbps */
  40,                 /* 15.85 kbps */
  46,                 /* 18.25 kbps */
  50,                 /* 19.85 kbps */
  58,                 /* 23.05 kbps */
  60                  /* 23.85 kbps */
};

#define PACKET_SIZE_AMR_WB_BAD 0
#define PACKET_SIZE_AMR_WB_SID 3

#endif  /* MSMAUD_VOC_AMR_WB_COMMON */


/* Pointer to the external types and data sizes for the current rate.
*/

/* Default to 13K vocoder */

LOCAL byte const *voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_13k;

/* To extract the number of words from the bytes table */
#define QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(frate) \
        ((voc_qdsp2_packet_data_size[frate] + 1) >> 1)


LOCAL byte qdsp_voc_mode = QDSP_VOC_MODE_IS733_V;


/* Frame counters */
uint32 qdsp_good = 0;
uint32 qdsp_bad = 0;
uint32 qdsp_tx_8 = 0;
uint32 qdsp_tx_4 = 0;
uint32 qdsp_tx_2 = 0;
uint32 qdsp_tx_1 = 0;
uint32 qdsp_rx_8 = 0;
uint32 qdsp_rx_4 = 0;
uint32 qdsp_rx_2 = 0;
uint32 qdsp_rx_1 = 0;
uint32 qdsp_rx_0 = 0;
uint32 qdsp_rx_e = 0;

uint32 qdsp_cmd_enc_miss_count = 0;
uint32 qdsp_cmd_enc_ready_count = 0;
uint32 qdsp_cmd_dec_miss_count = 0;
uint32 qdsp_cmd_dec_ready_count = 0;
uint32 qdsp_cmd_tx_8 = 0;
uint32 qdsp_cmd_tx_4 = 0;
uint32 qdsp_cmd_tx_2 = 0;
uint32 qdsp_cmd_tx_1 = 0;
uint32 qdsp_cmd_rx_8 = 0;
uint32 qdsp_cmd_rx_4 = 0;
uint32 qdsp_cmd_rx_2 = 0;
uint32 qdsp_cmd_rx_1 = 0;
uint32 qdsp_cmd_rx_0 = 0;
uint32 qdsp_cmd_rx_e = 0;

uint32 qdsp_cmd_voc_isr_count = 0;
uint32 qdsp_cmd_enc_isr_ready_count = 0;
uint32 qdsp_cmd_dec_isr_ready_count = 0;
uint32 qdsp_cmd_tx_frame_count = 0;
uint32 qdsp_cmd_rx_frame_count = 0;

#ifdef FEATURE_MM_REC
/* Storage of the record format for current MultiMedia record session */
qdsp_cmd_mm_rec_format_type qdsp_cmd_mm_rec_format;

/* Callback function to sound layer for MultiMedia record interrupt   */
qdsp_cmd_mm_rec_fn_type     qdsp_cmd_mm_rec_frame_fn = NULL;

#ifdef FEATURE_AAC_REC
/* Shared buffer for DSP output during MultiMedia recording           */
static volatile qdsp_cmd_mm_enc_buffer_type
                      qdsp_cmd_aac_enc_buffer[QDSP_CMD_MM_AAC_ENC_MAX_FRAME];
#endif /* FEATURE_AAC_REC */

/* Write index of the current MultiMedia recording session            */
static uint32 qdsp_cmd_mm_rec_write_cnt = 0;

/* Read index of the current MultiMedia recording session             */
static uint32 qdsp_cmd_mm_rec_read_cnt  = 0;

/* Counter wrap around indication                                     */
static boolean qdsp_cmd_cnt_wrap_around = FALSE;

/* Place holder for frame counter retrieve                            */
static uint32 qdsp_cmd_mm_rec_frame_cnt_prev  = 0;

/* Interrupt counter during the MultiMedia recording session          */
static qdsp_cmd_mm_rec_isr_count        = 0;
#endif /* FEATURE_MM_REC */

static uint16  qdsp_cmd_enc_semaphore_flag = 0;
/* flag indicating if packet can be read    */
static uint16  qdsp_cmd_dec_semaphore_flag = 0;
/* flag indicating if packet can be read    */
static uint16  qdsp_cmd_enc_frame_rate = QDSP_RATE_EIGHTH_V;
/* frame rate of Tx packet                 */
static uint16  qdsp_cmd_dec_frame_rate = QDSP_RATE_EIGHTH_V;
#ifdef FEATURE_VOICE_PLAYBACK
static uint16  qdsp_cmd_sec_dec_frame_rate = QDSP_RATE_EIGHTH_V;
#endif
/* frame rate of Tx packet                 */
static uint16  qdsp_cmd_min_frame_rate = QDSP_RATE_BLANK_V;
/* frame rate of Tx packet                 */
static uint16  qdsp_cmd_max_frame_rate = QDSP_RATE_FULL_V;
/* frame rate of Tx packet                 */
static uint16  qdsp_cmd_enc_packet_length;
/* length of packet                        */
static uint16  qdsp_cmd_dec_packet_length;
/* length of packet                        */
static uint16  qdsp_cmd_tx_packet[80];
/* tx packet data buffer                   */
static uint16  qdsp_cmd_rx_packet[80];
#if defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_EFR) \
 || defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_AMR_WB)
#ifdef FEATURE_VOICE_PLAYBACK
static uint16  qdsp_cmd_sec_dec_rx_packet[80];
#endif
#endif /* MSMAUD_VOC_FR || MSMAUD_VOC_EFR || MSMAUD_VOC_AMR
          || MSMAUD_VOC_AMR_WB */
/* rx packet data buffer                   */

#ifdef FEATURE_QDJ_TIMEWARP
/* flag indicating if this frame is warped */
static boolean qdsp_cmd_time_warp_enabled = FALSE;
/* time warp factor to be sent to dsp      */
static uint16  qdsp_cmd_time_warp_factor = 0;

#if defined(MSMAUD_VOC_4GV_VOIP) || defined (MSMAUD_VOC_4GV_WB_VOIP)
/* additional fields for 4GV vocoders */
typedef struct {
  boolean phase_match_enable;
  uint16  run_length;
  uint16  phase_offset;
} qdsp_cmd_4gv_time_warp_parm_type;

#ifdef MSMAUD_VOC_4GV_VOIP
#error code not present
#endif /* defined(MSMAUD_VOC_4GV_VOIP) */

#ifdef MSMAUD_VOC_4GV_WB_VOIP
/* Initial value for 4GV WB timewarp parameters */
static qdsp_cmd_4gv_time_warp_parm_type qdsp_cmd_4gv_wb_time_warp_parm = {
  0,0,0
};
#endif /* defined(MSMAUD_VOC_4GV_WB_VOIP) */
#endif /* defined(MSMAUD_VOC_4GV_VOIP) || defined (MSMAUD_VOC_4GV_WB_VOIP) */
#endif /* FEATURE_QDJ_TIMEWARP */


#ifdef MSMAUD_VOC_AMR_WB_COMMON
#define QDSP_CMD_AMR_WB_PACKET_LENGTH  30    /* AMR-WB packet length in words*/

static qdsp_cmd_amr_wb_frame_type
qdsp_cmd_amr_wb_enc_frame_id = QDSP_AMR_WB_NO_DATA;
static qdsp_cmd_amr_wb_frame_type
qdsp_cmd_amr_wb_dec_frame_id = QDSP_AMR_WB_NO_DATA;

#ifdef FEATURE_VOICE_PLAYBACK
static qdsp_cmd_amr_wb_frame_type
qdsp_cmd_amr_wb_sec_dec_frame_id = QDSP_AMR_WB_NO_DATA;
#endif /* FEATURE_VOICE_PLAYBACK */

static qdsp_cmd_amr_wb_frame_rate_type
qdsp_cmd_amr_wb_enc_frame_rate = QDSP_AMR_WB_RATE_0660;
static qdsp_cmd_amr_wb_frame_rate_type
qdsp_cmd_amr_wb_dec_frame_rate = QDSP_AMR_WB_RATE_0660;

#ifdef FEATURE_VOICE_PLAYBACK
static qdsp_cmd_amr_wb_frame_rate_type
qdsp_cmd_amr_wb_sec_dec_frame_rate = QDSP_AMR_WB_RATE_0660;
#endif
#endif  /* MSMAUD_VOC_AMR_WB_COMMON */


#ifdef FEATURE_NO_TX_COMFORT_NOISE
/* Mute TX packets instead of generating comfort noise */
static boolean qdsp_cmd_mute_tx = FALSE;
/* Saved volume for restoring after exiting mute mode */
static uint16 qdsp_cmd_tx_volume = QDSP_TX_MUTE_GAIN;

#endif /* FEATURE_NO_TX_COMFORT_NOISE */

#if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_EFR) \
    || defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_HR) \
    || defined(MSMAUD_VOC_G711) || defined(MSMAUD_VOC_AMR_WB)

/* Drop the first X packets from FR/EFR/HR/AMR vocoders */
#define QDSP_CMD_VOC_ENC_PKT_DROP_NUM 2
int8 qdsp_cmd_voc_enc_pkt_drop = 0;

#endif

#if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_EFR) \
    || defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_HR)

#define QDSP_CMD_GSM_PACKET_LENGTH  17         /* GSM packet length in words */
#define QDSP_CMD_GSM_AMR_PACKET_LENGTH  80     /* GSM packet length in words*/

static qdsp_cmd_gsm_frame_type qdsp_cmd_gsm_enc_frame_id = QDSP_AMR_NO_DATA;
static qdsp_cmd_gsm_frame_type qdsp_cmd_gsm_dec_frame_id = QDSP_AMR_NO_DATA;
#ifdef FEATURE_VOICE_PLAYBACK
static qdsp_cmd_gsm_frame_type qdsp_cmd_gsm_sec_dec_frame_id = QDSP_AMR_NO_DATA;
#endif /* FEATURE_VOICE_PLAYBACK */

static qdsp_cmd_gsm_frame_rate_type
qdsp_cmd_gsm_enc_frame_rate = QDSP_AMR_RATE_475;
static qdsp_cmd_gsm_frame_rate_type
qdsp_cmd_gsm_dec_frame_rate = QDSP_AMR_RATE_475;
#ifdef FEATURE_VOICE_PLAYBACK
static qdsp_cmd_gsm_frame_rate_type
qdsp_cmd_gsm_sec_dec_frame_rate = QDSP_AMR_RATE_475;
#endif

/* time alignment flag */
static uint16 qdsp_cmd_gsm_dec_taf = 0x0000;

#if defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_HR)
#ifdef FEATURE_VOICE_PLAYBACK
static uint16 qdsp_cmd_gsm_sec_dec_taf = 0x0000;
#endif /* FEATURE_VOICE_PLAYBACK */
#endif /* MSMAUD_VOC_EFR || MSMAUD_VOC_FR || MSMAUD_VOC_HR */

/* frame with first TAF set */
#define QDSP_GSM_LB_FIRST_TAF_FRAME     12

/* periodic count for TAF afterwards */
#define QDSP_GSM_LB_UPDATE_TAF_FRAME    24

#ifdef FEATURE_UP_LOOPBACK_TEST
/* counting loopback frames for TAF insertion */
static uint32 qdsp_cmd_gsm_lb_taf_cnt = 0;
#endif /* FEATURE_UP_LOOPBACK_TEST */

#ifdef MSMAUD_VOC_HR
/* encoder error flag */
static uint16 qdsp_cmd_gsm_enc_err = 0x0000;

/* decoder bfi */
static uint16 qdsp_cmd_gsm_dec_bfi = 0x0000;
#ifdef FEATURE_VOICE_PLAYBACK
static uint16 qdsp_cmd_gsm_sec_dec_bfi = 0x0000;
#endif /* FEATURE_VOICE_PLAYBACK */

/* decoder ufi */
static uint16 qdsp_cmd_gsm_dec_ufi = 0x0000;
#ifdef FEATURE_VOICE_PLAYBACK
static uint16 qdsp_cmd_gsm_sec_dec_ufi = 0x0000;
#endif /* FEATURE_VOICE_PLAYBACK */
#endif /* MSMAUD_VOC_HR */

#ifdef FEATURE_GSM_BFI_MUTING
#error code not present
#endif /* FEATURE_GSM_BFI_MUTING */

#endif /* MSMAUD_VOC_AMR || MSMAUD_VOC_EFR || MSMAUD_VOC_FR || MSMAUD_VOC_HR */


/* ========== Statistical Variables for non-loopback isr ========== */
/* number of encoded packets transmitted
     = qdsp_cmd_gsm_encoded_pkt_cnt - qdsp_cmd_gsm_enc_lost_cnt
   total number of encoder packets provided to vocoder driver
     = qdsp_cmd_gsm_encoded_pkt_cnt - qdsp_cmd_gsm_enc_lost_cnt
       + qdsp_cmd_gsm_enc_miss_cnt
*/
/* packets really passed through encoder */
uint32 qdsp_cmd_gsm_encoded_pkt_cnt = 0;

/* encoded packets not transmitted       */
uint32 qdsp_cmd_gsm_enc_lost_cnt = 0;

/* times when enc packets not available  */
uint32 qdsp_cmd_gsm_enc_miss_cnt = 0;

/* total number of encoder packets provided to vocoder driver */
uint32 qdsp_cmd_gsm_voc_enc_pkt_cnt = 0;


/* number of received packets decoded
     = qdsp_cmd_gsm_decoded_pkt_cnt - qdsp_cmd_gsm_dec_miss_cnt
   total number of decoder packets provided to QDSP driver
     = qdsp_cmd_gsm_decoded_pkt_cnt - qdsp_cmd_gsm_dec_miss_cnt
       + qdsp_cmd_gsm_dec_lost_cnt
*/
/* packets really passed through decoder */
uint32 qdsp_cmd_gsm_decoded_pkt_cnt = 0;

/* received packets not decoded          */
uint32 qdsp_cmd_gsm_dec_lost_cnt = 0;

/* times when dec packets not available  */
uint32 qdsp_cmd_gsm_dec_miss_cnt = 0;

/* total number of decoder packets provided to QDSP driver from
   vocoder driver */
uint32 qdsp_cmd_gsm_voc_dec_pkt_cnt = 0;


/* ========== Statistical Variables for loopback isr ========== */
/* qdsp_cmd_gsm_lb_dec_pkt_cnt
     = qdsp_cmd_gsm_lb_enc_pkt_cnt - qdsp_cmd_gsm_lb_lost_cnt
       + qdsp_cmd_gsm_lb_miss_cnt
*/
/* total number of loopback packets passed through encoder */
uint32 qdsp_cmd_gsm_lb_enc_pkt_cnt = 0;

/* total number of encoded loopback packets not decoded */
uint32 qdsp_cmd_gsm_lb_lost_cnt = 0;

/* total number of loopback packets passed through decoder */
uint32 qdsp_cmd_gsm_lb_dec_pkt_cnt = 0;

/* total number of times when decoder packets are not available */
uint32 qdsp_cmd_gsm_lb_miss_cnt = 0;


/* ======== PCM packets logging definitions ========= */

#ifdef FEATURE_PCM_PKT_LOG
/* Uplink packet data logging format */
LOG_RECORD_DEFINE(LOG_TX_PCM_PACKET_C)
  uint16 length;
  byte   tx_pkt[1];   // actual length is variable
LOG_RECORD_END

/* Downlink packet data logging format */
LOG_RECORD_DEFINE(LOG_RX_PCM_PACKET_C)
  uint16 length;
  byte   rx_pkt[1];   // actual length is variable
LOG_RECORD_END
#endif /*FEATURE_PCM_PKT_LOG*/

/* ======== GSM and WCDMA vocoder packets logging definitions ========= */
#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */


#ifdef MSMAUD_VOC_G711
/* A G.711 packet is 80 words long */
#define QDSP_CMD_G711_PACKET_LENGTH  80

#endif /* MSMAUD_VOC_G711 */

#ifdef MSMAUD_VOC_G723

/* Array elements are the number of bytes required for the packet */
byte const qdsp_cmd_packet_size_g723[] = {
  24,                                     /* High (6.3kbit) 24 octets */
  20,                                     /* Low (5.3kbit)  20 octets */
  4,                                      /* SID frame       4 octets */
  1                                       /* Blank frame     1 octet  */
};

/* Flag to substitute SID data when receiving blank frame without sid */
boolean qdsp_cmd_g723_sid_flag = FALSE;

#endif /* MSMAUD_VOC_G723 */

#if defined(MSMAUD_VOC_G711) || defined(MSMAUD_VOC_G723)

uint32 qdsp_cmd_wlan_dec_miss_cnt = 0;
uint32 qdsp_cmd_wlan_decoded_pkt_cnt = 0;

uint32 qdsp_cmd_wlan_enc_lost_cnt = 0;
uint32 qdsp_cmd_wlan_encoded_pkt_cnt = 0;

#endif /* defined(MSMAUD_VOC_G711) || defined(MSMAUD_VOC_G723) */

#ifdef FEATURE_PHONE_VR
static boolean qdsp_cmd_vr_utterance_capture = FALSE;

/* The user may want to disable talk over voice prompt.  If so encoder
** frames are only given to the endpoint detect function after voice
** prompt is over.
*/
static boolean qdsp_cmd_talkover_capture;

/* Indicates if Snd is playing a tone.  Used to implement talk over
** voice prompt feature.
*/
static boolean qdsp_cmd_snd_active_status;

static uint16  qdsp_cmd_vr_min_frame_rate = QDSP_RATE_HALF_V;
/* frame rate of Tx packet                 */

static uint16  qdsp_cmd_vr_max_frame_rate = QDSP_RATE_HALF_V;
/* frame rate of Tx packet                 */


/* 16 words of common diagnostic data for end point detection     */
/* 26 words of VR acoustic information                            */
/* vr common diagnostic data and acoustic information data buffer */
static uint16  qdsp_cmd_vr_packet[QDSP2_VR_BUF_LENGTH];
#endif /* FEATURE_PHONE_VR */

#if defined(FEATURE_VOICE_RECORD) || defined(FEATURE_PHONE_VR)
/* Comfort-noise state */
static uint16 qdsp_cmd_tx_comfort_noise = QDSP_COMFORT_NOISE_ENA_V;

/* temp packet data buffer */
static uint16  qdsp_cmd_temp_packet[17];
#endif /* FEATURE_VOICE_RECORD || FEATURE_PHONE_VR */

#ifdef FEATURE_VOICE_PLAYBACK

qdsp_cmd_vp_path_enum_type    qdsp_cmd_vp_direction;

boolean                       qdsp_cmd_vp_rx_playing   = FALSE;
qdsp_cmd_get_vp_frame_fn_type qdsp_cmd_get_vp_rx_frame = NULL;

boolean                       qdsp_cmd_vp_tx_playing   = FALSE;
qdsp_cmd_get_vp_frame_fn_type qdsp_cmd_get_vp_tx_frame = NULL;

LOCAL boolean                 qdsp_cmd_vp_paused       = FALSE;

/* Whether this vp is to be muxed with the forward link voice call */
qdsp_cmd_vp_mux_type qdsp_cmd_vp_incall_mux         = QDSP_CMD_VP_MUX_NONE;
/* We will use the following variable to store the incall mux state when
we are paused */
qdsp_cmd_vp_mux_type qdsp_cmd_vp_incall_mux_pause   = QDSP_CMD_VP_MUX_NONE;

boolean              qdsp_cmd_second_dec_configured = FALSE;
qdsp_cmd_second_dec_config_type qdsp_cmd_second_dec_config     =
                                                QDSP_CMD_SECOND_DEC_CONFIG_NONE;
#endif /* FEATURE_VOICE_PLAYBACK */


#ifdef FEATURE_VOICE_RECORD
qdsp_cmd_rec_dir_enum_type qdsp_cmd_rec_dir = QDSP_CMD_REC_NONE;

qdsp_cmd_rec_dir_enum_type qdsp_cmd_rec_dir_pause = QDSP_CMD_REC_NONE;
qdsp_cmd_rec_fn_type       qdsp_cmd_rec_frame_fn = NULL;

static uint16  qdsp_cmd_rec_min_frame_rate = QDSP_RATE_EIGHTH_V;
/* frame rate of Tx packet                 */

static uint16  qdsp_cmd_rec_max_frame_rate = QDSP_RATE_HALF_V;
/* frame rate of Tx packet                 */

#endif /* FEATURE_VOICE_RECORD */


/* 1/4 rate detection disable */
boolean qdsp_cmd_no_qrate = FALSE;

/* enable quarter rate packets flag */
static boolean qdsp_cmd_qrate_enable = FALSE;

static byte qdsp_cmd_rate_index = 0;

/* rate array */
static byte qdsp_cmd_rate_array[8] =
{
  QDSP_RATE_ERASURE_V, QDSP_RATE_ERASURE_V, QDSP_RATE_ERASURE_V,
  QDSP_RATE_ERASURE_V, QDSP_RATE_ERASURE_V, QDSP_RATE_ERASURE_V,
  QDSP_RATE_ERASURE_V, QDSP_RATE_ERASURE_V
};

#ifdef FEATURE_QTUNES
/* The QDSP will interrupt for more data when the QDSP has processed
** QDSP_QTUNES_BUF_WATERMARK words of data.
*/
#define QDSP_QTUNES_BUF_WATERMARK 50

/* MP3 Decoder error status mask */
#define QDSP_ADEC_MP3_ERROR_M          0x7C47
#endif /* FEATURE_QTUNES */

#ifdef FEATURE_QTUNES_AAC
/* Low watermark used to trigger the next DSP data request.
*/
#define QDSP_QTUNES_AAC_BUF_WATERMARK 50

/* AAC Decoder error status mask */
#define QDSP_ADEC_AAC_ERROR_M          0x0D3F

#define QDSP_ADEC_AAC_DATA_UNDERFLOW_M 0x3080

/* Format values to use to configure the DSP for the different AAC formats */
LOCAL const uint16 qdsp_cmd_aac_data_format_values[] =
{
  0,      /* ADIF       */
  0xFFFF, /* ADTS       */
  0,      /* RAW        */
  1,      /* PSEUDO_RAW        */
  2       /* LOAS              */
};

#ifdef FEATURE_AAC_PLUS
/* This value used to configure the AAC Plus DSP to do SBR decoding
*/
#define QDSP_CMD_AAC_PLUS_ON_VAL  1
#define QDSP_CMD_AAC_PLUS_OFF_VAL 0

LOCAL uint16 qdsp_cmd_aac_plus_on_flag = QDSP_CMD_AAC_PLUS_ON_VAL;

#ifdef FEATURE_ENHANCED_AAC_PLUS
/* This value used to configure the AAC Plus DSP to do SBR decoding
*/
#define QDSP_CMD_ENHANCED_AAC_PLUS_ON_VAL  1
#define QDSP_CMD_ENHANCED_AAC_PLUS_OFF_VAL 0

LOCAL uint16 qdsp_cmd_enhanced_aac_plus_on_flag =
             QDSP_CMD_ENHANCED_AAC_PLUS_ON_VAL;
#endif /* FEATURE_ENHANCED_AAC_PLUS */
#endif /* FEATURE_AAC_PLUS */

#if (defined(QDSP_IMAGE_QTV_AAC_DEFINED) || \
     defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
     defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED)) && defined(QDSP_aacConcealFlag)
/* Enable Error concealment: 0==disable; 1==enable */
uint16 qdsp_cmd_enable_err_concealment = 1;
#endif /* (QDSP_IMAGE_QTV_AAC_DEFINED || QDSP_IMAGE_QTV_AAC_H264_DEFINED ||
         QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED)&& QDSP_aacConcealFlag */

#endif /* FEATURE_QTUNES_AAC */

#ifdef FEATURE_REAL_AUDIO
/* Low watermark used to trigger the next DSP data request.
*/
#define QDSP_QTUNES_RA_BUF_WATERMARK 50

/* RealAudio Decoder error status mask */
#define QDSP_ADEC_RA_ERROR_M           0x000F

#define QDSP_ADEC_RA_DATA_UNDERFLOW_M  0x0030

#endif /* FEATURE_REAL_AUDIO */

#ifdef FEATURE_AMR_WBPLUS_AUDIO_DEC
  /* The minimum DSP free-buffer-length to cause the DSP to trigger a data
  ** request interrupt. The minimum buffer size is 163 words calculated by:
  ** 160 words data = [[32kbps/(50=1s/20ms interval)]x4 per superframe]/16-bit
  ** 3 words header = [6 bytes per pseudo-raw header]/16-bit
  **      163 words = total per unit of data
  */
  #define QDSP_ADEC_AMR_WBP_MIN_THRESHOLD    163

  /* AMR-WB+ Decoder error status mask */
  #define QDSP_ADEC_AMR_WBP_ERROR_M          0x14F0

  /* AMR-WB+ Decoder data underflow status bit */
  #define QDSP_ADEC_AMR_WBP_DATA_UNDERFLOW_M 0x0008
#endif /* FEATURE_AMR_WBPLUS_AUDIO_DEC */

#ifdef FEATURE_ADEC
const uint16 qdsp_cmd_sample_rate_values[] = {
  0,
  8000,  11025, 12000,
  16000, 22050, 24000,
  32000, 44100, 48000,
#ifdef FEATURE_AUDIO_44K_SAMPLE_RATE
  44000,
#endif /* FEATURE_AUDIO_44K_SAMPLE_RATE */
  0
};
#endif /* FEATURE_ADEC */

#ifdef FEATURE_GASYNTH_INTERFACE
typedef enum {
  QDSP_CMD_ADEC_STATE_BUFFER1 = 0x0,      /* Buffer 1 should be used first */
  QDSP_CMD_ADEC_STATE_BUFFER2 = 0x1       /* Buffer 2 should be used first */
} qdsp_cmd_adec_buf_state_type;

typedef enum {
  QDSP_CMD_QSYNTH_ADEC_STOPPED  = 0x00000000,
  QDSP_CMD_QSYNTH_START_PENDING = 0x00000001,
  QDSP_CMD_QSYNTH_START_ISSUED  = 0x00000002,
  QDSP_CMD_QSYNTH_ADEC_READY    = 0x00000004,
  QDSP_CMD_QSYNTH_STOP_PENDING  = 0x00000008,
  QDSP_CMD_QSYNTH_STOP_ISSUED   = 0x00000010
}qdsp_cmd_qsynth_adec_state_type;

#endif /* FEATURE_GASYNTH_INTERFACE */

#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP) || \
    defined(FEATURE_QSYNTH_ADPCM)
/* The QDSP will interrupt for more data when the QDSP has processed
** QDSP_QSYNTH_BUF_WATERMARK words of data.
*/
#define QDSP_QSYNTH_ADEC_NUM_CHAN   4
#define QDSP_QSYNTH_BUF_WATERMARK   18
#define QDSP_QSYNTH_ADEC_FRAME_SIZE 36

/* Panning limits for QSynth audio  decoder */
#define QDSP_CMD_QSYNTH_ADEC_PAN_MAX  64
#define QDSP_CMD_QSYNTH_ADEC_PAN_MIN -64
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP || FEATURE_QSYNTH_ADPCM */

#ifdef FEATURE_QSYNTH_ADPCM
/* This structure is used to keep track of the last data buffer given
** to the ADPCM decoder.
*/
typedef struct {
  uint8                    *buffer;      /* Buffer of data                   */
  uint32                   length;       /* Length, in bytes, of data buffer */
#ifdef FEATURE_GASYNTH_INTERFACE
  uint8                    *buffer2;
  uint32                   length2;
  qdsp_cmd_adec_buf_state_type buf_state; /* Keeping track of which buffer
                                             should be processed first by
                                             DSP                             */
  uint8                    stamp_counter; /* Value to be written to
                                             adecBufferReadyFlag             */
  uint32                   adec_state;    /* Value to keep track of the
                                             Adec Start and Stop commands */
#endif /* FEATURE_GASYNTH_INTERFACE */
  uint32                   frame_size;   /* Frame size of the adec data      */
  uint32                   sampling_rate;/* Sampling rate of the adec data   */
  qdsp_cmd_adpcm_mode_type mode;         /* Adec mode                        */
} qdsp_cmd_qsynth_adpcm_data_type;

static qdsp_cmd_qsynth_adpcm_data_type
                  qdsp_cmd_qsynth_adpcm_data[QDSP_QSYNTH_ADEC_NUM_CHAN];
#endif /* FEATURE_QSYNTH_ADPCM */

#ifdef FEATURE_ADEC
/* This variable holds the address of the start of the ADEC bitstream buffer in
** the DSP.  It is initialized upon ADEC_CONFIG().
*/
uint16 qdsp_cmd_adec_data_ptr0 = 0;      /* initial address of the adec data */

#ifdef FEATURE_GASYNTH_INTERFACE
/* Flag to indicate ADEC config has been issued */
boolean qdsp_cmd_synth_adec_enabled[QDSP_QSYNTH_ADEC_NUM_CHAN];

#endif /* FEATURE_GASYNTH_INTERFACE */

#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
uint16 qdsp_cmd_adec_data_ptr1 = 0;      /* initial address of the adec data */
uint16 qdsp_cmd_adec_data_ptr2 = 0;      /* initial address of the adec data */
uint16 qdsp_cmd_adec_data_ptr3 = 0;      /* initial address of the adec data */
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */

uint16 qdsp_cmd_adec_data_buf_size = 0;  /* len of the DSPs circular buffer  */
#endif /* FEATURE_ADEC */

#if defined(FEATURE_ADEC) || defined(FEATURE_WAVE_PB)
/* Callback function pointer for QDSP to request more data from vocoder task.
*/
qdsp_cmd_adec_int_cb_func_type qdsp_cmd_adec_int_cb_ptr = NULL;

/* The only block size that is supported by ADPCM on graphics image is
** currently 256 bytes.
*/
#define QDSP_CMD_ADEC_FRAME_SIZE 256

#if defined(QDSP_IMAGE_VFE_BAYER_DEFINED)    || \
    defined(QDSP_IMAGE_VFE_YCBCR_DEFINED)    || \
    defined(QDSP_IMAGE_VOC_DEFINED)          || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED)    || \
    defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED) || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_VOC_E90_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_EVRC_E90_DEFINED) || \
    defined(QDSP_IMAGE_FR_DEFINED)           || \
    defined(QDSP_IMAGE_EFR_DEFINED)          || \
    defined(QDSP_IMAGE_AMR_DEFINED)          || \
    defined(QDSP_IMAGE_AMR_WB_DEFINED)       || \
    defined(QDSP_IMAGE_HR_DEFINED)           || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_QTV_DEFINED)
#define QDSP_CMD_ADPCM_ADEC_FRAME_SIZE 256*2
#define QDSP_CMD_ADEC_MAX_FRAME_SIZE QDSP_CMD_ADPCM_ADEC_FRAME_SIZE
#else
#define QDSP_CMD_ADEC_MAX_FRAME_SIZE QDSP_CMD_ADEC_FRAME_SIZE
#endif

qdsp_cmd_wav_format_type qdsp_cmd_wav_format = QDSP_CMD_WAV_FORMAT_INVALID;

/* This structure is used to keep track of ADPCM data that is used for
** graphics images.
*/
typedef struct {
#ifdef FEATURE_GASYNTH_INTERFACE
  qdsp_cmd_adec_buf_state_type buf_state;
  /* Maintaining the state to indicate the next buffer to be used */
  uint8  *next_ptr;        /* pointer to the buffer to be used next */
  uint32 next_length;      /* Length of next buffer                 */
  uint8  *free_ptr;        /* Pointer to beginning of buffer        */
#endif /* FEATURE_GASYNTH_INTERFACE */
  uint8  *buf_ptr;        /* Pointer to current ADPCM data buffer    */
  uint32 buf_index;       /* Index to the data to be written next    */
  uint32 buf_length;      /* Length of buffer in bytes               */
  uint8  tmp_buf[QDSP_CMD_ADEC_MAX_FRAME_SIZE];
                          /* Buffer used to hold frame that overlaps */
                          /* end of a data buffer                    */
  uint32 tmp_buf_length;  /* Length of data in frame buffer          */
} qdsp_cmd_adpcm_adec_struct_type;

qdsp_cmd_adpcm_adec_struct_type qdsp_cmd_adpcm_adec_info;

/* This flag is used to indicate if we are currently in graphics ADPCM mode,
** and/or paused.
*/
typedef enum {
  QDSP_CMD_ADPCM_MODE_DISABLED,   /* Graphics ADPCM mode is disabled */
  QDSP_CMD_ADPCM_MODE_ENABLED,    /* Graphics ADPCM mode is enabled  */
  QDSP_CMD_ADPCM_MODE_PAUSED      /* Graphics ADPCM mode is paused   */
} qdsp_cmd_adpcm_mode_status;

qdsp_cmd_adpcm_mode_status qdsp_cmd_adpcm_status;

LOCAL boolean qdsp_cmd_adpcm_data = FALSE;
#endif /* FEATURE_ADEC || FEATURE_WAVE_PB */

#if defined(FEATURE_QSYNTH_COMMON) || defined(FEATURE_QTUNES_COMMON )
/* Clock callback structure that implements DTMF callback for QSynth & Qtunes
** image. Only necessary when issuing DTMF command while command semaphore is
** not cleared in Synth/Tunes image.
*/

	#ifdef FEATURE_CMI
#error code not present
	#else
clk_cb_type        qdsp_cmd_audfmt_dtmf_clk_cb;
	#endif
/* DTMF command to issue when DTMF retry timer calls back */
qdsp_cmd_dtmf_type qdsp_cmd_audfmt_dtmf_retry;

/* Function prototype for DMTF retry function */
void               qdsp_cmd_dtmf_retry ( int4 ms_interval );
#endif /* FEATURE_QSYNTH_COMMON || FEATURE_QTUNES_COMMON */

#ifdef FEATURE_QSYNTH_COMMON
#ifdef FEATURE_AUDFMT_FIR_FILTER
/* Minimum length for PCM Filter
*/
#define QDSP_AUDFMT_FILTER_MIN_LEN    5
#endif /* FEATURE_AUDFMT_FIR_FILTER */

/* Clock callback structure that implements MIDI command callback for QSynth
** image.
*/
	#ifdef FEATURE_CMI
#error code not present
	#else
    		clk_cb_type qdsp_cmd_qsynth_cmd_clk_cb;
	#endif
boolean     qdsp_cmd_qsynth_cmd_clk_enabled = FALSE;

#ifdef FEATURE_GASYNTH_INTERFACE
qdsp_cmd_adec_timer_cb_func_type qdsp_cmd_adec_timer_cb = NULL;

#define QDSP_CMD_ADEC_ACTION_CMD_SIZE 5
#define QDSP_CMD_ADEC_ACTION_BUFF_SIZE 7 /* QDSP_CMD_ADEC_ACTION_CMD_SIZE + 2 */
#define QDSP_CMD_ADEC_CMD_BUFF_SIZE 20 /* Defined for qdsp2_command() */
#define QDSP_CMD_ADEC_ACTION_CMD_HDR 0x0321
#define QDSP_CMD_ADEC_ACTION_ACTIVE 0x1
#define QDSP_CMD_ADEC_ACTION_RESET 0x2
#define QDSP_CMD_ADEC_ACTION_PAUSE 0x4
#define QDSP_CMD_ADEC_ACTION_RESUME 0x8
#define QDSP_CMD_ADEC_ACTION_STOP 0x10


#define QDSP_CMD_ADEC_CONFIG_CMD_HDR 0x0320
#define QDSP_CMD_ADEC_CONFIG_CMD_SIZE 6
#define QDSP_CMD_ADEC_CONFIG_BUFF_SIZE 8 /* QDSP_CMD_ADEC_CONFIG_CMD_SIZE + 2 */
#define QDSP_CMD_ADEC_CMD_MAX_SIZE 6 /* Adec config cmd size */

#ifdef FEATURE_QSYNTH_FRACTIONAL_SAMPLE_RATE
#define QDSP_CMD_ADEC_VOC_SAMPLE_RATE 0x1F40 /* 8K/sec */
#else
#define QDSP_CMD_ADEC_VOC_SAMPLE_RATE 0x50 /* 80 samples/10ms */
#endif /* FEATURE_QSYNTH_FRACTIONAL_SAMPLE_RATE */

#define QDSP_CMD_ADEC_VOC_CHAN_MODE 0x01

typedef struct {
  word cmd_param[QDSP_CMD_ADEC_CMD_MAX_SIZE];
  word cmd_type;
  boolean inuse;
} qdsp_cmd_qsynth_adec_cmd_type; /* Adec command queue element definition */

typedef struct {
  qdsp_cmd_qsynth_adec_cmd_type cmd_content[QDSP_CMD_ADEC_CMD_BUFF_SIZE];
  int front;
  int num_commands;
} qdsp_cmd_qsynth_adec_cmd_buff_type; /* Adec command queue definition */

qdsp_cmd_qsynth_adec_cmd_buff_type qdsp_cmd_qsynth_adec_cmd_buffer;

const uint8 qdsp_cmd_qsynth_stamp_table[3] = {
  2, 3, 1
};

#define GET_ADEC_BUF_MASK(x) 0x1 << x
#endif /* FEATURE_GASYNTH_INTERFACE */

/* These variables are used to buffer the MIDI commands.
*/
#ifdef FEATURE_WEBAUDIO
#define QDSP_CMD_QSYNTH_MAX_CMD_BUFF_SIZE 512
#else
#define QDSP_CMD_QSYNTH_MAX_CMD_BUFF_SIZE 128
#endif /* FEATURE_WEBAUDIO */
uint16 qdsp_cmd_qsynth_cmd_buffer[QDSP_CMD_QSYNTH_MAX_CMD_BUFF_SIZE];
uint16 qdsp_cmd_qsynth_num_commands = 0;
uint16 qdsp_cmd_qsynth_num_words    = 0;

#if defined(QDSP_IMAGE_QGL_DEFINED) || defined(QDSP_IMAGE_Q3D_DEFINED)
#define QDSP_CMD_GRAPHICS_QSYNTH_MAX_CMD_BUFF_SIZE 128
#endif

#endif /* FEATURE_QSYNTH_COMMON */

#ifdef FEATURE_AVS_VOC_DTMF_MIXING
/* Hard-coded enable for now. Being implemented this way in order to
** leave the option available for implementing a dynamic setting in
** the future.
*/
boolean qdsp_cmd_dtmf_mixing_enabled = TRUE;

#define QDSP_CMD_DTMF_MIXING_ENA  0xFFFF
#define QDSP_CMD_DTMF_MIXING_DIS  0x0000
#endif /* FEATURE_AVS_VOC_DTMF_MIXING */

#ifdef FEATURE_AUDIO_QENSEMBLE
#error code not present
#endif /* FEATURE_AUDIO_QENSEMBLE */

#ifdef FEATURE_AUDIO_FORMAT
 /* Variable declared to store the current decoder type in use */
LOCAL qdsp_cmd_decoder_inuse_type decoder_inuse    = QDSP_CMD_DEC_INVALID;
#endif

/* <EJECT> */
#ifdef FEATURE_PHONE_VR
/*===========================================================================

         DATA DEFINITIONS AND DECLARATIONS FOR VR MODE B/C

===========================================================================*/

/***************************************************************************/
/* VR Engine: Mode B/C Commands (From ARM to QDSP2)                        */
/*    VR Codec Config Command                                              */
/*    VR Capture Start Command                                             */
/*    VR Capture Continue Command                                          */
/*    VR Capture End Command                                               */
/*    VR Match Command                                                     */
/*    VR Prompt Command                                                    */
/***************************************************************************/

#define VR_CODEC_CONFIG_CMD_SIZE     8
        /* Size of VR Codec Configuration Command buffer                   */
#define VR_CODEC_CONFIG_CMD_HDR      0x1003
        /* Command type for VR Codec Configuration Command                 */

#define VR_CAPTURE_START_CMD_SIZE    3
        /* Size of VR Capture Start Command buffer                         */
#define VR_CAPTURE_START_CMD_HDR     0x1005
        /* Command type for VR Capture Start Command                       */

#define VR_CAPTURE_CONT_CMD_SIZE     3
        /* Size of VR Capture Continue Command buffer                      */
#define VR_CAPTURE_CONT_CMD_HDR      0x1006
        /* Command type for VR Capture Continue Command                    */

#define VR_CAPTURE_END_CMD_SIZE      9
        /* Size of VR Capture End Command buffer                           */
#define VR_CAPTURE_END_CMD_HDR       0x1007
        /* Command type for VR Capture End Command                         */

#ifdef FEATURE_VR_PUFE
#error code not present
#endif /* FEATURE_VR_PUFE */
#define VR_MATCH_CMD_SIZE            7
        /* Size of VR Match Command buffer                                 */
#define VR_MATCH_CMD_HDR             0x1008
        /* Command type for VR Match Command                               */

#define VR_PROMPT_CMD_SIZE           2
        /* Size of VR Prompt Command buffer                                */
#define VR_PROMPT_CMD_HDR            0x1009
        /* Command type for VR Prompt Command                              */

/* <EJECT> */
/***************************************************************************/
/* VR Engine: Mode B/C Messages (From QDSP2 to ARM)                        */
/*    VR Initialization Status Message                                     */
/*    VR Match Result Message                                              */
/***************************************************************************/

#define VR_INIT_STATUS_MSG           0x1000
        /* Message type for VR Initialization Status Message               */
#define VR_MATCH_RESULT_MSG          0x1003
        /* Message type for VR Match Result Message                        */

/***************************************************************************/
/* VR Match definitions and declarations                                   */
/***************************************************************************/

#define NUM_DSP_PINGPONG_BUF         2
        /* Number of DSP pingpong buffers for pattern download             */
#define MAX_EP_HYP                   3
        /* Max number of endpoint hypotheses.                              */
#define MAX_NUM_VR_PAT               20
        /* Max number of VR patterns in a pattern download command         */
#define MAX_NUM_VR_SCORE             (MAX_EP_HYP * MAX_NUM_VR_PAT)
        /* Max number of VR scores in a match result message               */
#define MAX_SD_PAT_WORDS             61
        /* Max number of Speaker Dependent pattern words                   */

/* Bit mask values for VR template address in VR match result message
** (address to download templates to the DSP.)
*/
#define QDSP_VR_DL_ADDR_M                0x3FFF /** VR template addr mask  */
#define QDSP_VR_DL_MEM_BANK_M            0x4000 /** Memory bank to dnload  */
#define QDSP_VR_DL_RAMA_V                0x0000 /*  Download to RAM A      */
#define QDSP_VR_DL_RAMB_V                0x4000 /*  Download to RAM B      */

/* Indicate VR Match is in progress.
*/
LOCAL boolean qdsp_cmd_match_in_progress = FALSE;

#ifdef FEATURE_VR_PUFE
#error code not present
#else
/***************************************************************************/
/* VR endpoint detection definitions and declarations                      */
/***************************************************************************/

/* The following defines are used to build a VR vocoder frame for endpoint
** detection.
**
** The vocoder packet given to the endpoint detector has the following
** format:
**
** 1st word   :  frame rate                  ( 1 word )
** 2nd  -  9th:  voice frame                 ( 8 words)
**                                           ----------
**               QDSP2_VOICE_FRM_LEN                    ( 9 words or 18 bytes)
**
** 10th word  :  frame number                ( 1 word )
** 11th - 18th:  band power (previous frame) ( 8 words)
** 19th - 26th:  band power (current frame)  ( 8 words)
**                                           ----------
**               QDSP2_VR_DIAG_LEN                      (17 words or 34 bytes)
**                                                      ----------------------
**               QDSP2_VR_PKT_LEN                       (26 words or 52 bytes)
*/
#define QDSP2_VOICE_FRM_LEN          9
        /* Length (in words) of voice data portion of a VR frame           */
#define QDSP2_VR_DIAG_LEN            17
        /* Length (in words) of diagnostic data portion of a VR frame      */
#endif /* FEATURE_VR_PUFE */
#define QDSP2_VR_PKT_LEN             (QDSP2_VOICE_FRM_LEN + QDSP2_VR_DIAG_LEN)
        /* Total length (in words) of a VR frame                           */

/* This function pointer is used to give a frame of captured packet data to
** the appropriate function.
*/
LOCAL qdsp_cmd_endpt_cb_type qdsp_cmd_vr_endpt_cb =
                                     (qdsp_cmd_endpt_cb_type) NULL;

/***************************************************************************/
/* General data declarations                                               */
/***************************************************************************/

/* Count number of QDSP2 ISRs.  Used for debugging purpose only.
*/
#ifdef FEATURE_QDSP_ISR_COUNT
LOCAL uint32 qdsp_cmd_isr_count     = 0;
LOCAL uint32 qdsp_cmd_isr_enc_count = 0;
LOCAL uint32 qdsp_cmd_isr_dec_count = 0;
LOCAL uint32 qdsp_cmd_isr_msg_count = 0;
#endif /* FEATURE_QDSP_ISR_COUNT */

static const uint16 qdsp_vrBarkAveCoeffTable[] = {
  0x7fff, 0x7fff, 0x7fff, 0x7fff,
  0x7fff, 0x7fff, 0x7fff, 0x3fff,
  0x3fff, 0x2aaa, 0x1fff, 0x1999,
  0x1555, 0x0fff, 0x0ccc, 0x09d8
};

static const uint16 qdsp_vrBarkTable [] = {
  2 , 2 , 2 , 2 ,
  2 , 2 , 2 , 3 ,
  3 , 4 , 5 , 6 ,
  7 , 9 , 11, 14
};

#endif /* FEATURE_PHONE_VR */


/***************************************************************************/
/* Declarations for UMTS TTY mode                                          */
/***************************************************************************/
#ifdef FEATURE_TTY
qdsp_tty_mode_type qdsp_cmd_tty_mode = QDSP_TTY_MODE_OFF;

#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */
#endif /* FEATURE_TTY */

/***************************************************************************/
/* Declarations for TTY Activity updates                                   */
/***************************************************************************/
#if defined(FEATURE_TTY) && defined(FEATURE_TTY_ACTIVITY_STATUS)

/* No. of QDSP interrupts to wait before the TTY activity status is updated */
#define QDSP_CMD_TTY_UPDATE_NUM_INTS 15

/* Current TTY status */
static qdsp_tty_mode_type qdsp_tty_mode = QDSP_TTY_DIS_V;

/* Previous values of TTY status, used to eliminate redundant updates */
static boolean qdsp_tty_prev_enc_state = FALSE;
static boolean qdsp_tty_prev_dec_state = FALSE;

/* Callback for status update */
qdsp_tty_status_fn_type qdsp_tty_update_status_func = NULL;

#endif /* FEATURE_TTY && FEATURE_TTY_ACTIVITY_STATUS */


/* <EJECT> */
/***************************************************************************/
/* Declarations for MVS Interface                                          */
/***************************************************************************/
#ifdef FEATURE_MVS

#ifdef MSMAUD_VOC_AMR_WB_COMMON
/* Function pointers for AMR_WB Voice Services
*/
qdsp_amr_wb_ul_fn_type  amr_wb_uplink_func = NULL;
qdsp_amr_wb_dl_fn_type  amr_wb_downlink_func = NULL;
#endif /* MSMAUD_VOC_AMR_WB_COMMON */

#ifdef MSMAUD_VOC_AMR
/* Function pointers for AMR Voice Services
*/
qdsp_amr_ul_fn_type  amr_uplink_func = NULL;
qdsp_amr_dl_fn_type  amr_downlink_func = NULL;
#endif /* MSMAUD_VOC_AMR */

#if defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_EFR)
#error code not present
#endif  /* MSMAUD_VOC_FR || MSMAUD_VOC_EFR */

#ifdef MSMAUD_VOC_HR
/* Functions pointers for HR Voice Services
*/
qdsp_hr_ul_fn_type  hr_uplink_func = NULL;
qdsp_hr_dl_fn_type  hr_downlink_func = NULL;
#endif  /* MSMAUD_VOC_HR */

#ifdef MSMAUD_VOC_G711
/* Function pointers for Voice Services
*/
qdsp_g711_ul_fn_type  g711_uplink_func = NULL;
qdsp_g711_dl_fn_type  g711_downlink_func = NULL;
#endif  /* MSMAUD_VOC_G711 */

#ifdef MSMAUD_VOC_G723
/* Function pointers for Voice Services
*/
qdsp_g723_ul_fn_type  g723_uplink_func = NULL;
qdsp_g723_dl_fn_type  g723_downlink_func = NULL;
#endif  /* MSMAUD_VOC_G723 */

#endif  /* FEATURE_MVS */


#ifdef FEATURE_VOC_PACKET_INTERFACE
/***************************************************************************/
/* Declarations for the Packet interface for Vocoder data                  */
/***************************************************************************/

/* Callbacks for packet clients */
/* Reverse Link Packet Interface */
qdsp_cmd_rl_packet_fn_type  qdsp_cmd_rl_packet_func = NULL;

/* Forward Link Packet Interface */
qdsp_cmd_fl_packet_fn_type  qdsp_cmd_fl_packet_func = NULL;

#endif  /* FEATURE_VOC_PACKET_INTERFACE */

#ifdef FEATURE_VOC_PCM_INTERFACE
/***************************************************************************/
/* Declarations for Vocoder PCM interface                                  */
/***************************************************************************/

/* QDSP command header and command size for controlling PCM modes */
#define QDSP_CMD_PCM_INTERFACE_CONTROL_HDR  0x000d
#define QDSP_CMD_PCM_INTERFACE_CONTROL_SIZE 3

/* Buffer for transferring PCM data */
LOCAL uint16 qdsp_cmd_pcm_data_buffer[QDSP_CMD_PCM_DATA_FRAME_LEN];

uint32 qdsp_cmd_pcm_rx_input_enabled  = FALSE; /* RX Input enabled if  = TRUE */
uint32 qdsp_cmd_pcm_tx_input_enabled  = FALSE; /* TX Input enabled if  = TRUE*/
uint32 qdsp_cmd_pcm_rx_output_enabled = FALSE; /* RX Output enabled if = TRUE */
uint32 qdsp_cmd_pcm_tx_output_enabled = FALSE; /* TX Output enabled if = TRUE */

const qdsp_cmd_pcm_interface_attrib_type qdsp_cmd_pcm_nb_mono_attrib
= {{QDSP_PCM_INTERFACE_MAX, 8000, 320}, NULL};

const qdsp_cmd_pcm_interface_attrib_type qdsp_cmd_pcm_wb_mono_attrib
= {{QDSP_PCM_INTERFACE_MAX, 16000, 640}, NULL};

const
qdsp_cmd_pcm_interleave_attrib_type qdsp_cmd_pcm_nb_stereo_interleave_attrib[2]
= {{QDSP_PCM_INTERFACE_MAX, 2}, {QDSP_PCM_INTERFACE_MAX, 2}};
const qdsp_cmd_pcm_interleave_tbl_type qdsp_cmd_pcm_nb_stereo_interleave_tbl
= {2, (qdsp_cmd_pcm_interleave_attrib_type*)
      qdsp_cmd_pcm_nb_stereo_interleave_attrib};

const qdsp_cmd_pcm_interface_attrib_type qdsp_cmd_pcm_nb_stereo_attrib
= {{QDSP_PCM_INTERFACE_MAX, 16000, 640},
   (qdsp_cmd_pcm_interleave_tbl_type*)&qdsp_cmd_pcm_nb_stereo_interleave_tbl};

const
qdsp_cmd_pcm_interleave_attrib_type qdsp_cmd_pcm_wb_stereo_interleave_attrib[2]
= {{QDSP_PCM_INTERFACE_MAX, 2}, {QDSP_PCM_INTERFACE_MAX, 2}};
const qdsp_cmd_pcm_interleave_tbl_type qdsp_cmd_pcm_wb_stereo_interleave_tbl
= {2, (qdsp_cmd_pcm_interleave_attrib_type*)
      qdsp_cmd_pcm_wb_stereo_interleave_attrib};

const qdsp_cmd_pcm_interface_attrib_type qdsp_cmd_pcm_wb_stereo_attrib
= {{QDSP_PCM_INTERFACE_MAX, 32000, 1280},
   (qdsp_cmd_pcm_interleave_tbl_type*)&qdsp_cmd_pcm_wb_stereo_interleave_tbl};


/* Callback to get RX input data from Client (NULL if disabled) */
qdsp_cmd_pcm_client_input_fn_type  qdsp_pcm_rx_input_func  = NULL;
qdsp_cmd_pcm_interface_attrib_type *qdsp_pcm_rx_input_attrib = NULL;
qdsp_cmd_pcm_interface_attrib_type *qdsp_pcm_rx_input_pending_attrib = NULL;
qdsp_cmd_pcm_interface_attrib_type qdsp_pcm_rx_input_current_attrib;

/* Callback to get TX input data from Client (NULL if disabled) */
qdsp_cmd_pcm_client_input_fn_type  qdsp_pcm_tx_input_func  = NULL;
qdsp_cmd_pcm_interface_attrib_type *qdsp_pcm_tx_input_attrib = NULL;
qdsp_cmd_pcm_interface_attrib_type *qdsp_pcm_tx_input_pending_attrib = NULL;
qdsp_cmd_pcm_interface_attrib_type qdsp_pcm_tx_input_current_attrib;

/* Callback to give RX output data to Client (NULL if disabled) */
qdsp_cmd_pcm_client_output_fn_type qdsp_pcm_rx_output_func = NULL;
qdsp_cmd_pcm_interface_attrib_type *qdsp_pcm_rx_output_attrib = NULL;
qdsp_cmd_pcm_interface_attrib_type *qdsp_pcm_rx_output_pending_attrib = NULL;
qdsp_cmd_pcm_interface_attrib_type qdsp_pcm_rx_output_current_attrib;

/* Callback to give TX output data to Client (NULL if disabled) */
qdsp_cmd_pcm_client_output_fn_type qdsp_pcm_tx_output_func = NULL;
qdsp_cmd_pcm_interface_attrib_type *qdsp_pcm_tx_output_attrib = NULL;
qdsp_cmd_pcm_interface_attrib_type *qdsp_pcm_tx_output_pending_attrib = NULL;
qdsp_cmd_pcm_interface_attrib_type qdsp_pcm_tx_output_current_attrib;

#endif /* FEATURE_VOC_PCM_INTERFACE */

#ifdef FEATURE_AUDFMT_SPECTRUM_ANALYZER
/* Spectrum Analyzer constants
*/
#define QDSP_CMD_SPA_NUM_COEFFS        32

LOCAL uint16 qdsp_cmd_spectrum_analyzer_buffer[QDSP_CMD_SPA_NUM_COEFFS];

/* Callback to return data to client */
qdsp_cmd_spectrum_analyzer_cb_type qdsp_cmd_spectrum_analyzer_cb = NULL;

#endif /* FEATURE_AUDFMT_SPECTRUM_ANALYZER */

#ifdef FEATURE_AUDIO_FORMAT
typedef struct {
  /* AV sync cb interval in packets for QCP related formats. For others in
  ** PCM samples.
  */
  uint32                    av_sync_interval;
  /* true if AAC/AAC+ sample rate < 32 */
  boolean                   pcm_sample_half;
  qdsp_cmd_av_sync_cb_type  qdsp_cmd_av_sync_cb;  /* client av sync cb       */
  uint32                    interrupt_counter;    /* interrupt counter in ms */
  uint32                    av_sync_next;         /* Next AV SYNC count      */
  boolean                   av_sync_first_time;   /* first av sync cb        */
  uint32                    av_sync_bytes_counter;/* Counter for Bytes       */
} qdsp_cmd_av_sync_info_type;

qdsp_cmd_av_sync_info_type qdsp_cmd_av_sync_info =
                           {0, FALSE, NULL, 0, 0,FALSE, 0};
#endif /* FEATURE_AUDIO_FORMAT */

#if defined(FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
/*
 * Post processing buffer pool management vairables
 */
uint32 qdsp_cmd_arm_pp_num_buffers = 0;
boolean qdsp_cmd_pp_buf_pool_selected = FALSE;
uint32 qdsp_cmd_pp_read_q_head = 0;
/* Number of buffers waiting for ARM PP to be done */
uint32 qdsp_cmd_pp_read_q_pending_num = 0;
uint16 * qdsp_cmd_pp_read_buffer = NULL;
qdsp_cmd_pp_buffer_desc_type *qdsp_cmd_pp_read_buffer_desc;
qdsp_cmd_pp_buf_mgr_type
      qdsp_cmd_pp_read_buf_mgr[QDSP_CMD_ARM_PP_BUF_TYPE_MAX] = {
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_1, QDSP_CMD_ARM_PP_BUF_SIZE_1, {0}},
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_2, QDSP_CMD_ARM_PP_BUF_SIZE_2, {0}},
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_4, QDSP_CMD_ARM_PP_BUF_SIZE_4, {0}},
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_8, QDSP_CMD_ARM_PP_BUF_SIZE_8, {0}},
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_16, QDSP_CMD_ARM_PP_BUF_SIZE_16, {0}}
      };

/* State of ARM post processing interface */
uint16 qdsp_cmd_pp_state = QDSP_CMD_ARM_PP_STATE_BUF_AVAIL;
boolean qdsp_cmd_pp_pause = FALSE;

/* Callback to send the pcm data from DSP to client */
qdsp_cmd_arm_pp_cb_type qdsp_cmd_arm_pp_cb = NULL;
qdsp_cmd_pp_type_type   qdsp_cmd_pp_type   = QDSP_CMD_PP_TYPE_NONE;

#endif /* FEATURE_ARM_POST_PROCESSING || FEATURE_AVS_WB_PCM_RX_INTERFACE */

#ifdef FEATURE_ARM_POST_PROCESSING

uint32 qdsp_cmd_pp_write_q_head = 0;
uint32 qdsp_cmd_pp_write_q_tail = 0;
/* Number of buffers processed buffers waiting for DSP to read them */
uint32 qdsp_cmd_pp_write_q_pending_num = 0;
uint16 * qdsp_cmd_pp_write_buffer = NULL;

qdsp_cmd_pp_buffer_desc_type *qdsp_cmd_pp_write_buffer_desc;
qdsp_cmd_pp_buf_mgr_type
      qdsp_cmd_pp_write_buf_mgr[QDSP_CMD_ARM_PP_BUF_TYPE_MAX] = {
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_1, QDSP_CMD_ARM_PP_BUF_SIZE_1, {0}},
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_2, QDSP_CMD_ARM_PP_BUF_SIZE_2, {0}},
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_4, QDSP_CMD_ARM_PP_BUF_SIZE_4, {0}},
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_8, QDSP_CMD_ARM_PP_BUF_SIZE_8, {0}},
        {QDSP_CMD_ARM_PP_NUM_BUF_SIZE_16, QDSP_CMD_ARM_PP_BUF_SIZE_16, {0}}
      };

/* The purpose of delayed start is to hold qdsp_cmd_pp_delayed_start_thres no.
of post processed buffers before we send the first buffer to the DSP. This
can help us in tiding over irregular ARM post processing times and avoid
telling the DSP that data is not ready. */

boolean qdsp_cmd_pp_delayed_start = FALSE;
uint16  qdsp_cmd_pp_delayed_start_thres = 2;
boolean qdsp_cmd_pp_first_buf_sent = FALSE;

#endif /* FEATURE_ARM_POST_PROCESSING */

static boolean qdsp_cmd_sidetone_enable = TRUE;

#ifdef FEATURE_VOC_DTMF_DETECT
/* Callback function for DTMF detection */
qdsp_cmd_dtmf_detect_cb_type qdsp_cmd_dtmf_detect_cb = NULL;

#endif /* FEATURE_VOC_DTMF_DETECT */

#ifdef FEATURE_WMA
#define QDSP_ADEC_WM_ERROR_M                 0x0C17

/* Adec data buffer size */
#define QDSP_CMD_ADEC_PRE_ALLOC_BUFFER_SIZE  1024 * 8

/* Minimum no. of bytes the DSP should underrun before issuing a data
   request interrupt */
#define QDSP_CMD_WMA_DATA_REQUEST_THRESHOLD  0x20

/* Maximum data threshold for DSP stream buffer */
#define QDSP_CMD_WMA_DATA_THR_MAX            2380

/* Offset should be applied when calculate data threshold */
#define QDSP_CMD_WMA_DATA_THR_OFFSET         3
#endif /* FEATURE_WMA */

/* Available data size in adec data buffer */
uint32 qdsp_cmd_adec_data_buffer_size;

/* WaterMark for how long of DME buffer can be used
 * based on the virtual packet length */
uint32 qdsp_cmd_adec_data_buffer_threshold;

#ifdef FEATURE_QAUDIOFX
/* The following macros define the 3D positional commands and sizes */
#define QDSP_CMD_3D_POS_OUTPUT_MODE_CMD_SIZE   3
#define QDSP_CMD_3D_POS_OUTPUT_MODE_CMD        0x0100

#define QDSP_CMD_3D_POS_LSNR_POS_CMD_SIZE      9
#define QDSP_CMD_3D_POS_LSNR_POS_CMD           0x0101

#define QDSP_CMD_3D_POS_LSNR_ORIENT_CMD_SIZE   15
#define QDSP_CMD_3D_POS_LSNR_ORIENT_CMD        0x0102

#define QDSP_CMD_3D_POS_LSNR_VEL_CMD_SIZE      9
#define QDSP_CMD_3D_POS_LSNR_VEL_CMD           0x0103

#define QDSP_CMD_3D_REVERB_CMD_SIZE            9
#define QDSP_CMD_3D_REVERB_CMD                 0x104

#define QDSP_CMD_3D_REVERB_DISABLE_CMD_SIZE    1
#define QDSP_CMD_3D_REVERB_DISABLE_CMD         0x105

#define QDSP_CMD_3D_POS_ENABLE_CMD_SIZE        2
#define QDSP_CMD_3D_POS_ENABLE_CMD             0x0106

#define QDSP_CMD_3D_POS_ENV_RESET_CMD_SIZE     1
#define QDSP_CMD_3D_POS_ENV_RESET_CMD          0x0107

#define QDSP_CMD_3D_POS_SRC_RESET_CMD_SIZE     2
#define QDSP_CMD_3D_POS_SRC_RESET_CMD          0x0010

#define QDSP_CMD_3D_POS_SRC_VOLUME_CMD_SIZE    4
#define QDSP_CMD_3D_POS_SRC_VOLUME_CMD         0x0011

#define QDSP_CMD_3D_POS_SRC_VOL_ATTEN_CMD_SIZE 7
#define QDSP_CMD_3D_POS_SRC_VOL_ATTEN_CMD      0x0012

#define QDSP_CMD_3D_POS_SRC_POS_CMD_SIZE       9
#define QDSP_CMD_3D_POS_SRC_POS_CMD            0x0013

#define QDSP_CMD_3D_POS_SRC_VEL_CMD_SIZE       9
#define QDSP_CMD_3D_POS_SRC_VEL_CMD            0x0014

#define QDSP_CMD_3D_REVERB_SRC_VOL_CMD_SIZE    2
#define QDSP_CMD_3D_REVERB_SRC_VOL_CMD         0x0015

#define QDSP_CMD_3D_POS_SRC_ENABLE_CMD_SIZE    2
#define QDSP_CMD_3D_POS_SRC_ENABLE_CMD         0x016

/* The queue size is set to larger of the sum of environment queue commands or
** the sum of source queue commands. There can only be one of each type of
** command in a queue.
*/
#define QDSP_CMD_3D_POS_QUEUE_SIZE   50

/* The following macros define the query interface offsets */
#define QDSP_CMD_3D_POS_QUERY_ENV_ENABLE_OFFSET    0
#define QDSP_CMD_3D_POS_QUERY_LSNR_POS_OFFSET      1
#define QDSP_CMD_3D_POS_QUERY_LSNR_ORIENT_OFFSET   7
#define QDSP_CMD_3D_POS_QUERY_LSNR_VEL_OFFSET      19

#define QDSP_CMD_3D_POS_QUERY_SRC_OFFSET           25
#define QDSP_CMD_3D_POS_QUERY_SRC_SIZE             21
#define QDSP_CMD_3D_POS_QUERY_SRC_ENABLE_OFFSET    0
#define QDSP_CMD_3D_POS_QUERY_SRC_VOL_OFFSET       1
#define QDSP_CMD_3D_POS_QUERY_SRC_POS_OFFSET       2
#define QDSP_CMD_3D_POS_QUERY_SRC_VOL_ATTEN_OFFSET 8
#define QDSP_CMD_3D_POS_QUERY_SRC_VEL_OFFSET       14
#define QDSP_CMD_3D_POS_QUERY_SRC_REVOL_OFFSET     20
/* These callbacks are for final 3D positional source parameter
** commands. These will be executed when playback of the applicable
** source ends.
*/
qdsp_cmd_3d_pos_src_final_cb_type qdsp_cmd_3d_pos_query_src_final_cb[4];

/* 3D positional query buffers */
#define QDSP_CMD_3D_POS_QUERY_BUFFER_SIZE 110
__align(4) uint16 qdsp_cmd_3d_pos_query_buffer1
                                    [QDSP_CMD_3D_POS_QUERY_BUFFER_SIZE];
__align(4) uint16 qdsp_cmd_3d_pos_query_buffer2
                                    [QDSP_CMD_3D_POS_QUERY_BUFFER_SIZE];

/* Native sampling rate of 3D positional is 44.1kHz */
#define QDSP_CMD_3D_POS_NATIVE_SAMPLING_RATE_INDEX  44

/* The following structure is used as the 3D positional command queue */
typedef struct {
  uint16 cmd_buf[QDSP_CMD_3D_POS_QUEUE_SIZE];
  uint16 num_commands;
  uint32 index;
} qdsp_cmd_3d_pos_cmd_q_type;

/* The following structure contains ping-pong 3D positional command queues */
typedef struct {
  uint32 current_index;
  qdsp_cmd_3d_pos_cmd_q_type cmd_q[2];
} qdsp_cmd_3d_pos_cmd_struct_type;

/* The following enumerated type is used to represent the type of
** command queue.
*/
typedef enum {
  QDSP_CMD_3D_POS_CMD_Q_ENV,   /* 3D positional environment command queue */
  QDSP_CMD_3D_POS_CMD_Q_SRC0,  /* 3D positional source 0 command queue    */
  QDSP_CMD_3D_POS_CMD_Q_SRC1,  /* 3D positional source 1 command queue    */
  QDSP_CMD_3D_POS_CMD_Q_SRC2,  /* 3D positional source 2 command queue    */
  QDSP_CMD_3D_POS_CMD_Q_SRC3,  /* 3D positional source 3 command queue    */
  QDSP_CMD_3D_POS_CMD_Q_INVALID
} qdsp_cmd_3d_pos_cmd_q_enum_type;

/* The following are the 3D positional command queues */
__align(4) qdsp_cmd_3d_pos_cmd_struct_type qdsp_cmd_3d_pos_src_cmd_q[4];
__align(4) qdsp_cmd_3d_pos_cmd_struct_type qdsp_cmd_3d_pos_lsnr_cmd_q;

/* The following structure is used to contain sampling rate index information
** for 3D positional settings.
*/
typedef struct {
  uint32 sr_threshold;  /* Sampling rate threshold */
  uint32 index;         /* Sampling rate index     */
} qdsp_cmd_3d_pos_sample_rate_index_type;

const qdsp_cmd_3d_pos_sample_rate_index_type
            qdsp_cmd_3d_pos_sample_rate_index[8] = {{11512, 0x0000} ,
                                                    {14000, 0x0120} ,
                                                    {19025, 0x0244} ,
                                                    {23025, 0x0368} ,
                                                    {28000, 0x0388} ,
                                                    {38050, 0x04ad} ,
                                                    {46050, 0x05d2} ,
                                                    {48000, 0x06f7}};
#define QDSP_CMD_3D_KNOWN_ENVIRONMENTS 32
#define QDSP_CMD_3D_REVERB_ENV_SIZE 8
#define QDSP_CMD_3D_INVALID_ENVIRONMENTS QDSP_CMD_3D_KNOWN_ENVIRONMENTS+1

/* This array defines the coefficients for known environments */
uint16  qdsp_cmd_3d_reverb_env[QDSP_CMD_3D_KNOWN_ENVIRONMENTS][QDSP_CMD_3D_REVERB_ENV_SIZE] =
{ /* Generic      */ { 32767, 0, 1490, 0, 54395, 7, 3261, 11 },
  /* Paddedcell   */ { 32767, 0, 170, 0, 6554, 1, 3288, 2 },
  /* Room         */ { 32767, 0, 400, 0, 54395, 2, 2753, 3 },
  /* Bathroom     */ { 32767, 0, 1490, 0, 35389, 7, 8192, 11 },
  /* Livingroom   */ { 32767, 0, 500, 0, 6554, 3, 727, 4 },
  /* Arena        */ { 32767, 0, 7240, 0, 21627, 20, 2639, 30 },
  /* Auditorium   */ { 32767, 0, 4320, 0, 38666, 20, 1857, 30 },
  /* Cave         */ { 32767, 0, 2910, 1, 19661, 15, 1830, 22 },
  /* Concert Hall */ { 32767, 0, 3920, 0, 45875, 20, 2585, 29 },
  /* Stone room   */ { 32767, 0, 2310, 0, 41943, 12, 2850, 17 },
  /* Hangar       */ { 32767, 0, 10050, 0, 15073, 20, 3254, 30 },
  /* Hallway      */ { 32767, 0, 1490, 0, 38666, 7, 4304, 11 },
  /* Alley        */ { 32767, 0, 1490, 0, 56361, 7, 2579, 11 },
  /* Carpeted Hallway */ { 32767, 0, 300, 0, 6554, 2, 395, 30 },
  /* Stone corridor   */ { 32767, 0, 2700, 0, 51773, 13, 4082, 20 },
  /* Forrest      */ { 32767, 0, 1490, 0, 35389, 162, 1990, 88 },
  /* Mountain     */ { 32767, 0, 1490, 0, 13763, 300, 495, 100 },
  /* City         */ { 32767, 0, 1490, 0, 43909, 7, 368, 11 },
  /* Quarry       */ { 32767, 0, 1490, 0, 54395, 61, 4607, 25 },
  /* Plain        */ { 32767, 0, 1490, 0, 32768, 179, 281, 100 },
  /* Drug         */ { 32767, 0, 8390, 1, 25428, 2, 8052, 30 },
  /* Parking lot  */ { 32767, 0, 1650, 1, 32768, 8, 687, 12 },
  /* Dizzy        */ { 32767, 0, 17203, 0, 36700, 20, 1279, 30 },
  /* Sewer pipe   */ { 32767, 0, 2810, 0, 9175, 14, 8192, 21 },
  /* Underwater   */ { 32767, 0, 1490, 0, 6554, 7, 8192, 11 },
  /* Small room   */ { 32767, 0, 1100, 0, 54395, 5, 4607, 10 },
  /* Medium room  */ { 32767, 0, 1300, 0, 54395, 10, 2508, 20 },
  /* Large room   */ { 32767, 0, 1500, 0, 54395, 20, 1031, 40 },
  /* Psychotic    */ { 32767, 0, 7560, 0, 59638, 20, 6315, 30 },
  /* Plate        */ { 32767, 0, 1300, 0, 54395, 2, 2591, 10 },
  /* Medium Hall  */ { 32767, 0, 1800, 0, 45875, 15, 1031, 30 },
  /* Large Hall   */ { 32767, 0, 1800, 0, 45875, 30, 517, 60 }
};

boolean qdsp_cmd_3d_reverb_enabled = FALSE;
uint16  qdsp_cmd_3d_reverb_cur_env = QDSP_CMD_3D_INVALID_ENVIRONMENTS;
uint16 qdsp_cmd_3d_reverb_current[QDSP_CMD_3D_REVERB_ENV_SIZE + 1] =
                            { QDSP_CMD_3D_REVERB_CMD, 0, 0, 0, 0, 0, 0, 0, 0 };

#endif /* FEATURE_QAUDIOFX */


#ifdef FEATURE_AMR_REC_HOMING_SEQUENCE
/* These flags indicate to the amr enc and dec ISRs that recording has
** just been resumed and a homing sequence should be inserted in the
** recorded stream. Flags are set by qdsp_cmd_resume_rec() and reset by
** the ISRs.
*/
uint16 qdsp_cmd_silence_frame[17];
boolean qdsp_cmd_reverse_recording_resumed = FALSE;
boolean qdsp_cmd_forward_recording_resumed = FALSE;

/* Raw format AMR-NB homing sequence frames */
uint16 qdsp_cmd_amr_homing_sequences[8][17] = {
    //4.75 kbit/s
    { 0xF89D,  0x38CC,  0x0328,  0xF70F,  0xB182,  0x3D36,  0x0000,
      0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,
      0x0000,  0x0000,  0x0000 },
    //5.15 kbit/s
    { 0xF89D,  0x38CC,  0x03DF,  0xC062,  0xFB7F,  0x7F47,  0xBE00,
      0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,
      0x0000,  0x0000,  0x0000 },
    //5.90 kbit/s
    { 0xF871,  0x8BEF,  0x401E,  0xFE01,  0xCF60,  0x7CFB,  0xF803,
      0xDC00,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,
      0x0000,  0x0000,  0x0000 },
    //6.70 kbit/s
    { 0xF871,  0x8BEF,  0x4017,  0x01E2,  0x63E1,  0x60B8,  0xBC07,
      0xB18E,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,
      0x0000,  0x0000,  0x0000 },
    //7.40 kbit/s
    { 0xF871,  0x8BEF,  0x400D,  0xE036,  0x208F,  0xC4C1,  0xBA6F,
      0x01B0,  0x0378,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,
      0x0000,  0x0000,  0x0000 },
    //7.95 kbit/s
    { 0x6138,  0xC5F7,  0xA006,  0xFA07,  0x3C08,  0x7A5B,  0x1C69,
      0xBC41,  0xCA68,  0x3C82,  0x0000,  0x0000,  0x0000,  0x0000,
      0x0000,  0x0000,  0x0000 },
    //10.2 kbit/s
    { 0xF871,  0x8BD1,  0x4000,  0x0000,  0x00DA,  0xE4C6,  0x77EA,
      0x2C40,  0xAD6B,  0x3D80,  0x6C17,  0xC855,  0xC300,  0x0000,
      0x0000,  0x0000,  0x0000 },
    //12.2 kbit/s
    { 0x0854,  0xDB96,  0xAAAD,  0x6000,  0x0000,  0x001B,  0x587F,
      0x6683,  0x7940,  0x9004,  0x1585,  0x4F10,  0xF6B0,  0x2403,
      0xC7EA,  0x0000,  0x0000 }
};
#endif /* FEATURE_AMR_REC_HOMING_SEQUENCE */

#ifdef FEATURE_AUDIO_CMX_5P0
#define QDSP_DLS_HP_INST_BANK            0x7700
#define QDSP_DLS_HP_DRUM_BANK            0x7600
#define QDSP_DLS_HQ_INST_BANK            0x7300
#define QDSP_DLS_HQ_DRUM_BANK            0x7200
#endif /* FEATURE_AUDIO_CMX_5P0 */

/* <EJECT> */
/*===========================================================================

                             FUNCTION DEFINITIONS

===========================================================================*/

/* Forward declaration for pp isr */
#if defined(FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
  void qdsp_cmd_arm_pp_isr( void );
#endif

/*===========================================================================

FUNCTION qdsp_cmd_get_voc_pkt_len

DESCRIPTION
 This function is used to extract the bytes info.
DEPENDENCIES

RETURN VALUE
  None.
SIDE EFFECTS
  None

===========================================================================*/
uint16 qdsp_cmd_get_voc_pkt_len(byte voc_mode, uint16 dsp_frame_info,
                                qdsp_cmd_pkt_dir_enum_type direction)
{
  uint16 frame_rate;
  uint16 frame_type;
  uint16 packet_length = 0;
    switch (voc_mode) {
#ifdef MSMAUD_VOC_AMR_COMMON
      case QDSP_VOC_MODE_AMR_V:
        frame_rate = dsp_frame_info & 0xff;
        frame_type = dsp_frame_info & 0xff00;
        if(direction == QDSP_CMD_PKT_DIR_RX) {
          switch (frame_type) {
            case QDSP_AMR_RX_NO_DATA_V:
              packet_length = 0;
              break;
            case QDSP_AMR_RX_SID_FIRST_V:
            case QDSP_AMR_RX_SID_UPDATE_V:
            case QDSP_AMR_RX_SID_BAD_V:
              packet_length = PACKET_SIZE_AMR_SID_BYTES;
              break;
              default:
              packet_length = voc_qdsp2_packet_data_size[frame_rate];
              break;
          }
        } else if(direction == QDSP_CMD_PKT_DIR_TX) {
            switch (frame_type) {
              case QDSP_AMR_TX_NO_DATA_V:
                packet_length = 0;
                break;
              case QDSP_AMR_TX_SID_FIRST_V:
              case QDSP_AMR_TX_SID_UPDATE_V:
                packet_length = PACKET_SIZE_AMR_SID_BYTES;
                break;
              default:
                packet_length = voc_qdsp2_packet_data_size[frame_rate];
                break;
              }
           }
           break;
#endif /* MSMAUD_VOC_AMR_COMMON */
#ifdef MSMAUD_VOC_AMR_WB_COMMON
      case QDSP_VOC_MODE_AMR_WB_V:
        frame_rate = dsp_frame_info & 0xff;
        frame_type = dsp_frame_info & 0xff00;
        if(direction == QDSP_CMD_PKT_DIR_RX) {
          switch (frame_type) {
            case QDSP_AMR_WB_RX_NO_DATA_V:
		    case QDSP_AMR_WB_RX_SPEECH_LOST_V:
              packet_length = 0;
              break;
            case QDSP_AMR_WB_RX_SID_FIRST_V:
            case QDSP_AMR_WB_RX_SID_UPDATE_V:
            case QDSP_AMR_WB_RX_SID_BAD_V:
              packet_length = PACKET_SIZE_AMR_WB_SID;
              break;
              default:
              packet_length = voc_qdsp2_packet_data_size[frame_rate];
              break;
          }
        } else if(direction == QDSP_CMD_PKT_DIR_TX) {
            switch (frame_type) {
              case QDSP_AMR_WB_TX_NO_DATA_V:
                packet_length = 0;
                break;
              case QDSP_AMR_WB_TX_SID_FIRST_V:
              case QDSP_AMR_WB_TX_SID_UPDATE_V:
                packet_length = PACKET_SIZE_AMR_WB_SID;
                break;
              default:
                packet_length = voc_qdsp2_packet_data_size[frame_rate];
                break;
              }
           }
           break;
#endif /* MSMAUD_VOC_AMR_WB_COMMON */
#ifdef MSMAUD_VOC_IS127
      case QDSP_VOC_MODE_IS127_V:
        packet_length = voc_qdsp2_packet_data_size[dsp_frame_info];
        break;
#endif /* MSMAUD_VOC_IS127 */
#ifdef MSMAUD_VOC_IS733
      case QDSP_VOC_MODE_IS733_V:
        packet_length = voc_qdsp2_packet_data_size[dsp_frame_info];
        break;
#endif /* MSMAUD_VOC_IS733 */
#ifdef MSMAUD_VOC_4GV
      case QDSP_VOC_MODE_4GV_V:
        packet_length = voc_qdsp2_packet_data_size[dsp_frame_info];
        break;
#endif /* MSMAUD_VOC_4GV */
#ifdef MSMAUD_VOC_4GV_WB
      case QDSP_VOC_MODE_4GV_WB_V:
        packet_length = voc_qdsp2_packet_data_size[dsp_frame_info];
        break;
#endif /* MSMAUD_VOC_4GV_WB */
#ifdef MSMAUD_VOC_G723
      case QDSP_VOC_MODE_G723_V:
        packet_length = voc_qdsp2_packet_data_size[dsp_frame_info];
        break;
#endif /* MSMAUD_VOC_G723 */
    /* GSM Vocoders will be taken in the near future */
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA)
#error code not present
#endif /* FEATURE_GSM || FEATURE_WCDMA */
      default:
        packet_length = 0;
        break;
     }
     return(packet_length);
}

#ifdef FEATURE_QAUDIOFX
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_send_cmd

DESCRIPTION
  Sends the indicated command queue to the DSP, if possible.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_3d_pos_send_cmd (
  qdsp_cmd_3d_pos_cmd_q_enum_type cmd_q,
  qdsp_cmd_3d_pos_cmd_struct_type *cmd_struct
) {
  qdsp_cmd_3d_pos_cmd_q_type *p_cmd_q;
  uint16 cmd_semaphore;

  if((cmd_struct != NULL) && (cmd_q < QDSP_CMD_3D_POS_CMD_Q_INVALID)) {
    p_cmd_q = &cmd_struct->cmd_q[cmd_struct->current_index];

    if(p_cmd_q->num_commands != 0) {
      switch(cmd_q) {
        case QDSP_CMD_3D_POS_CMD_Q_ENV:
          cmd_semaphore = qdsp_read(QDSP_adecPPCommandRegEnv);
          break;

        case QDSP_CMD_3D_POS_CMD_Q_SRC0:
          cmd_semaphore = qdsp_read(QDSP_adecPPCommandReg0);
          break;

        case QDSP_CMD_3D_POS_CMD_Q_SRC1:
          cmd_semaphore = qdsp_read(QDSP_adecPPCommandReg1);
          break;

        case QDSP_CMD_3D_POS_CMD_Q_SRC2:
          cmd_semaphore = qdsp_read(QDSP_adecPPCommandReg2);
          break;

        case QDSP_CMD_3D_POS_CMD_Q_SRC3:
          cmd_semaphore = qdsp_read(QDSP_adecPPCommandReg3);
          break;

        default:
          cmd_semaphore = 1;
          break;
      }

      if(cmd_semaphore == 0) {
        switch(cmd_q) {
          case QDSP_CMD_3D_POS_CMD_Q_ENV:
            qdsp_write(QDSP_adecPPBufEnvExtPtr, (uint32) p_cmd_q->cmd_buf);
            qdsp_write(QDSP_adecPPCommandRegEnv, p_cmd_q->num_commands);
            break;

          case QDSP_CMD_3D_POS_CMD_Q_SRC0:
            qdsp_write(QDSP_adecPPCommandBufExtPtr0, (uint32) p_cmd_q->cmd_buf);
            qdsp_write(QDSP_adecPPCommandReg0, p_cmd_q->num_commands);
            break;

          case QDSP_CMD_3D_POS_CMD_Q_SRC1:
            qdsp_write(QDSP_adecPPCommandBufExtPtr1, (uint32) p_cmd_q->cmd_buf);
            qdsp_write(QDSP_adecPPCommandReg1, p_cmd_q->num_commands);
            break;

          case QDSP_CMD_3D_POS_CMD_Q_SRC2:
            qdsp_write(QDSP_adecPPCommandBufExtPtr2, (uint32) p_cmd_q->cmd_buf);
            qdsp_write(QDSP_adecPPCommandReg2, p_cmd_q->num_commands);
            break;

          case QDSP_CMD_3D_POS_CMD_Q_SRC3:
            qdsp_write(QDSP_adecPPCommandBufExtPtr3, (uint32) p_cmd_q->cmd_buf);
            qdsp_write(QDSP_adecPPCommandReg3, p_cmd_q->num_commands);
            break;
        }

        p_cmd_q->num_commands = 0;
        p_cmd_q->index        = 0;
        if(cmd_struct->current_index == 0) {
          cmd_struct->current_index = 1;
        } else {
          cmd_struct->current_index = 0;
        }
      }
    }
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_src_all

DESCRIPTION
  Queries all the 3D positional source settings.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_3d_pos_query_src_all (
  uint32 src_adec_num
) {
  uint32  query_addr;
  uint16  *query_buffer, *query_base;

  qdsp_cmd_3d_pos_src_all_setting_type src_all;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) &&
     (qdsp_cmd_3d_pos_query_src_final_cb[src_adec_num] != NULL)) {
    query_addr = qdsp_read(QDSP_adecPPStateExtPtrCurr);
    query_base = (uint16 *) query_addr;
    if((query_base == qdsp_cmd_3d_pos_query_buffer1) ||
       (query_base == qdsp_cmd_3d_pos_query_buffer2)) {
      query_base += QDSP_CMD_3D_POS_QUERY_SRC_OFFSET;
      query_base += (src_adec_num * QDSP_CMD_3D_POS_QUERY_SRC_SIZE);

      query_buffer = query_base + QDSP_CMD_3D_POS_QUERY_SRC_ENABLE_OFFSET;

      src_all.src_enable = (*query_buffer == 0xFFFF?TRUE:FALSE);

      query_buffer = query_base + QDSP_CMD_3D_POS_QUERY_SRC_POS_OFFSET;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      src_all.position.x_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      src_all.position.y_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer;
      src_all.position.z_coord = query_addr;

      query_buffer = query_base + QDSP_CMD_3D_POS_QUERY_SRC_VOL_OFFSET;

      src_all.volume = *query_buffer;

      query_buffer = query_base + QDSP_CMD_3D_POS_QUERY_SRC_VOL_ATTEN_OFFSET;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      src_all.vol_atten.max_distance = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      src_all.vol_atten.min_distance = query_addr;

      src_all.vol_atten.rolloff = *query_buffer++;
      src_all.vol_atten.mute    = (*query_buffer == 0)?FALSE:TRUE;

      query_buffer = query_base + QDSP_CMD_3D_POS_QUERY_SRC_VEL_OFFSET;
      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      src_all.vel_vector.x_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      src_all.vel_vector.y_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer;
      src_all.vel_vector.z_coord = query_addr;

      query_buffer = query_base += QDSP_CMD_3D_POS_QUERY_SRC_REVOL_OFFSET;
      src_all.reverb_vol = *query_buffer;

      qdsp_cmd_3d_pos_query_src_final_cb[src_adec_num](src_adec_num, &src_all);

    }
  }
}
#endif /* FEATURE_QAUDIOFX */

/* <EJECT> */
#ifdef FEATURE_AUDIO_FORMAT
/*===========================================================================

FUNCTION qdsp_cmd_av_sync_voc_cb

DESCRIPTION
  Do vocoder AV Sync callback with current status.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  AV Sync cb with timestamp and vocoder packet count

==========================================================================*/
void qdsp_cmd_av_sync_voc_cb (void)
{
  qword num_samples_counter = {0,0};
  qword msecs = {0,0};
  qword num_bytes_counter = {0,0};

  if (qdsp_cmd_av_sync_info.qdsp_cmd_av_sync_cb != NULL) {
    
    #ifdef FEATURE_CMI
#error code not present
    #else
    	clk_uptime_ms(msecs);
    #endif
    qw_set(num_samples_counter, 0, qdsp_cmd_av_sync_info.interrupt_counter);
    qw_set(num_bytes_counter, 0, qdsp_cmd_av_sync_info.av_sync_bytes_counter);
    MSG_HIGH(" av_sync_info:int_counter = %d bytes_counter = %d",
               qdsp_cmd_av_sync_info.interrupt_counter ,
               qdsp_cmd_av_sync_info.av_sync_bytes_counter,0);

    qdsp_cmd_av_sync_info.qdsp_cmd_av_sync_cb(msecs,
                                              num_samples_counter,
                                              num_bytes_counter);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_av_sync_flush

DESCRIPTION
  AV Sync flush functionality.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Clear AV Sync related variables

==========================================================================*/
void qdsp_cmd_av_sync_flush (void)
{
  qdsp_cmd_av_sync_info.interrupt_counter = 0;
  qdsp_cmd_av_sync_info.av_sync_next      = 0;
  qdsp_cmd_av_sync_info.av_sync_bytes_counter = 0;

  switch (qdsp_cmd_image_select) {

#if defined(QDSP_IMAGE_H263D_DEFINED)                || \
    defined(QDSP_IMAGE_H263D_AMR_DEFINED)            || \
    defined(QDSP_IMAGE_H264D_AMR_DEFINED)            || \
    defined(QDSP_IMAGE_H264D_EVRC_DEFINED)           || \
    defined(QDSP_IMAGE_MP4D_DEFINED)                 || \
    defined(QDSP_IMAGE_MP4D_AMR_DEFINED)             || \
    defined(QDSP_IMAGE_AMR_DEFINED)                  || \
    defined(QDSP_IMAGE_AMR_WB_DEFINED)               || \
    defined(QDSP_IMAGE_VOC_DEFINED)                  || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED)            || \
    defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)              || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED)         || \
    defined(QDSP_IMAGE_VOC_EVRC_DEFINED)             || \
    defined(QDSP_IMAGE_VOC_E90_DEFINED)              || \
    defined(QDSP_IMAGE_VOC_EVRC_E90_DEFINED)         || \
    defined(QDSP_IMAGE_VOC_QTV_DEFINED)              || \
    defined(QDSP_IMAGE_4GV_DEFINED)                  || \
    defined(QDSP_IMAGE_EFR_DEFINED)                  || \
    defined(QDSP_IMAGE_FR_DEFINED)                   || \
    defined(QDSP_IMAGE_HR_DEFINED)                   || \
    defined(QDSP_IMAGE_AMR_YCBCR2_DEFINED)           || \
    defined(QDSP_IMAGE_EFR_YCBCR2_DEFINED)           || \
    defined(QDSP_IMAGE_FR_YCBCR2_DEFINED)            || \
    defined(QDSP_IMAGE_HR_YCBCR2_DEFINED)            || \
    defined(QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED)     || \
    defined(QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED)    || \
    defined(QDSP_IMAGE_QVP_BAYER_AMR_DEFINED)        || \
    defined(QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED)        || \
    defined(QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED)       || \
    defined(QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED)      || \
    defined(QDSP_IMAGE_QVP_H263P3_AMR_DEFINED)       || \
    defined(QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED)      || \
    defined(QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED)     || \
    defined(QDSP_IMAGE_QTV_VOC_H264_DEFINED)         || \
    defined(QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED)   || \
    defined(QDSP_IMAGE_QTV_DEFINED)                  || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)	     || \
    defined(QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED)
#ifdef QDSP_IMAGE_H263D_DEFINED
    case QDSP_IMAGE_H263D:
#endif
#ifdef QDSP_IMAGE_H263D_AMR_DEFINED
    case QDSP_IMAGE_H263D_AMR:
#endif
#ifdef QDSP_IMAGE_H264D_AMR_DEFINED
    case QDSP_IMAGE_H264D_AMR:
#endif
#ifdef QDSP_IMAGE_H264D_EVRC_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_MP4D_DEFINED
    case QDSP_IMAGE_MP4D:
#endif
#ifdef QDSP_IMAGE_MP4D_AMR_DEFINED
    case QDSP_IMAGE_MP4D_AMR:
#endif
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif
#ifdef QDSP_IMAGE_4GV_DEFINED
    case QDSP_IMAGE_4GV:
#endif
#ifdef QDSP_IMAGE_4GV_VOIP_DEFINED
    case QDSP_IMAGE_4GV_VOIP:
#endif
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif
#ifdef QDSP_IMAGE_AMR_YCBCR2_DEFINED
    case QDSP_IMAGE_AMR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_EFR_YCBCR2_DEFINED
    case QDSP_IMAGE_EFR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_FR_YCBCR2_DEFINED
    case QDSP_IMAGE_FR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_HR_YCBCR2_DEFINED
    case QDSP_IMAGE_HR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_H263:
#endif
#ifdef QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_MPEG4:
#endif
#ifdef QDSP_IMAGE_QVP_BAYER_AMR_DEFINED
    case QDSP_IMAGE_QVP_BAYER_AMR;
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_AMR_DEFINED
    case QDSP_IMAGE_QVP_H263P3_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED
    case QDSP_IMAGE_QVP_H263P3_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_DEFINED
    case QDSP_IMAGE_QTV:
#endif
#ifdef QDSP_IMAGE_QTV_VOC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED
    case QDSP_IMAGE_QCAMCORDER_COMBO:
#endif
      qdsp_cmd_av_sync_voc_cb();
      break;
#endif

    default:
      break;
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_set_av_sync

DESCRIPTION
  Set AV Sync parameters

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_av_sync_info is set

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_av_sync
(
  qdsp_cmd_av_sync_dec_enum_type dec_type,
  qdsp_cmd_av_sync_cb_type       av_sync_cb,
  uint32                         av_sync_interval,
  uint16                         sample_rate
)
{
  qdsp_cmd_av_sync_info.qdsp_cmd_av_sync_cb = av_sync_cb;
  qdsp_cmd_av_sync_info.pcm_sample_half = FALSE;
  qdsp_cmd_av_sync_flush();

  switch(dec_type) {
#if defined(QDSP_IMAGE_H263D_DEFINED)                || \
    defined(QDSP_IMAGE_H263D_AMR_DEFINED)            || \
    defined(QDSP_IMAGE_H264D_AMR_DEFINED)            || \
    defined(QDSP_IMAGE_H264D_EVRC_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_VOC_H264_DEFINED)         || \
    defined(QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED)   || \
    defined(QDSP_IMAGE_QTV_DEFINED)                  || \
    defined(QDSP_IMAGE_MP4D_DEFINED)                 || \
    defined(QDSP_IMAGE_MP4D_AMR_DEFINED)             || \
    defined(QDSP_IMAGE_AMR_DEFINED)                  || \
    defined(QDSP_IMAGE_AMR_WB_DEFINED)               || \
    defined(QDSP_IMAGE_VOC_DEFINED)                  || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED)            || \
    defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)              || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED)         || \
    defined(QDSP_IMAGE_VOC_EVRC_DEFINED)             || \
    defined(QDSP_IMAGE_VOC_E90_DEFINED)              || \
    defined(QDSP_IMAGE_VOC_EVRC_E90_DEFINED)         || \
    defined(QDSP_IMAGE_VOC_QTV_DEFINED)              || \
    defined(QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED)   || \
    defined(QDSP_IMAGE_4GV_DEFINED)                  || \
    defined(QDSP_IMAGE_4GV_WB_DEFINED)               || \
    defined(QDSP_IMAGE_EFR_DEFINED)                  || \
    defined(QDSP_IMAGE_FR_DEFINED)                   || \
    defined(QDSP_IMAGE_HR_DEFINED)                   || \
    defined(QDSP_IMAGE_AMR_YCBCR2_DEFINED)           || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)              || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)              || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)               || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)               || \
    defined(QDSP_IMAGE_EFR_YCBCR2_DEFINED)           || \
    defined(QDSP_IMAGE_FR_YCBCR2_DEFINED)            || \
    defined(QDSP_IMAGE_HR_YCBCR2_DEFINED)            || \
    defined(QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED)     || \
    defined(QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED)    || \
    defined(QDSP_IMAGE_QVP_BAYER_AMR_DEFINED)        || \
    defined(QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED)        || \
    defined(QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED)       || \
    defined(QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED)      || \
    defined(QDSP_IMAGE_QVP_H263P3_AMR_DEFINED)       || \
    defined(QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED)	     || \
    defined(QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED)     || \
    defined(QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED)	     || \
    defined(QDSP_IMAGE_QTV_DEFINED)
    case QDSP_CMD_AV_SYNC_DEC_VOCODER:
      qdsp_cmd_av_sync_info.av_sync_interval = av_sync_interval;
      qdsp_cmd_av_sync_info.av_sync_next     = av_sync_interval;
      qdsp_cmd_av_sync_info.av_sync_first_time = TRUE;
      break;
#endif

#ifdef FEATURE_QTUNES_AAC
    case QDSP_CMD_AV_SYNC_DEC_AAC:
      switch(qdsp_cmd_image_select) {
        /* Images that support aacPlus */
#if defined(QDSP_IMAGE_AAC_DEFINED)             || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED)    || \
    defined(QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED)   || \
    defined(QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED) || \
    defined(QDSP_IMAGE_H264D_AAC_DEFINED)       || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)    || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)         || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)
#ifdef QDSP_IMAGE_AAC_DEFINED
        case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
        case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
        case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
        case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
        case QDSP_IMAGE_H264D_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
        case QDSP_IMAGE_QTV_AAC:
#endif
          qdsp_write(QDSP_AVSyncInterruptInterval, av_sync_interval);
          qdsp_cmd_av_sync_info.pcm_sample_half = (sample_rate < 32);
          break;
#endif

        /* Images that don't support aacPlus */
#if defined(QDSP_IMAGE_MP4D_AAC_DEFINED)        || \
    defined(QDSP_IMAGE_H263D_AAC_DEFINED)
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
        case QDSP_IMAGE_MP4D_AAC:
#endif
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
        case QDSP_IMAGE_H263D_AAC:
#endif
          qdsp_write(QDSP_AVSyncInterruptInterval, av_sync_interval);
          break;
#endif
        default:
         break;
      }
      break;
#endif /* FEATURE_QTUNES_AAC */

#if defined(QDSP_IMAGE_TUNES_DEFINED)    || \
    defined(QDSP_IMAGE_RA_DEFINED)       || \
    defined(QDSP_IMAGE_WM_DEFINED)       || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)   || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)
    case QDSP_CMD_AV_SYNC_DEC_MP3:
    case QDSP_CMD_AV_SYNC_DEC_RA:
    case QDSP_CMD_AV_SYNC_DEC_WMA:
    case QDSP_CMD_AV_SYNC_DEC_AMR_WBPLUS:
      switch(qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_TUNES_DEFINED
        case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
        case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_WM_DEFINED
        case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
        case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
        case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
        case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
          qdsp_write(QDSP_AVSyncInterruptInterval, av_sync_interval);
          break;

        default:
          break;
      }
      break;
#endif /* QDSP_IMAGE_TUNES_DEFINED    ||
          QDSP_IMAGE_RA_DEFINED       ||
          QDSP_IMAGE_WM_DEFINED       ||
          QDSP_IMAGE_QTV_CONC_DEFINED */

#if defined(FEATURE_QSYNTH_ADPCM)
    case QDSP_CMD_AV_SYNC_DEC_WAVE:
      switch(qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
        case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#ifdef QDSP_IMAGE_SYNTH_DEFINED
        case QDSP_IMAGE_SYNTH:
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
          qdsp_write(QDSP_AVSyncInterruptInterval, av_sync_interval);
          break;
#endif /*  QDSP_IMAGE_SYNTH_DEFINED */

#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
        case QDSP_IMAGE_VOC_COMBO_SYNTH:
          qdsp_write(QDSP_AVSyncInterruptInterval, av_sync_interval);
          break;
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */

        default:
          break;
      }
      break;
#endif /* FEATURE_QSYNTH_ADPCM */

    default:
      qdsp_cmd_av_sync_info.av_sync_interval    = 0;
      qdsp_cmd_av_sync_info.qdsp_cmd_av_sync_cb = NULL;
      break;
  }
  return (QDSP_CMD_SUCCESS);
}

/*===========================================================================

FUNCTION qdsp_cmd_set_decoder_in_use

DESCRIPTION
  set the decoder type currently in use in the qdsp

DEPENDENCIES
  None

RETURN VALUE
  QDSP_CMD_SUCCESS

SIDE EFFECTS
  qdsp_cmd_set_decoder_in_use is set

==========================================================================*/
extern qdsp_cmd_status_type qdsp_cmd_set_decoder_in_use(qdsp_cmd_decoder_inuse_type dec_type)
{
  decoder_inuse = dec_type;
  return QDSP_CMD_SUCCESS;
}

/*===========================================================================

FUNCTION qdsp_cmd_get_decoder_in_use

DESCRIPTION
  get the decoder type currently in use in the qdsp

DEPENDENCIES
  None

RETURN VALUE
  The decoder type in use

SIDE EFFECTS
  qdsp_cmd_set_decoder_in_use is set

==========================================================================*/
extern qdsp_cmd_decoder_inuse_type qdsp_cmd_get_decoder_in_use(void)
{
  return decoder_inuse;
}


/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_do_av_sync

DESCRIPTION
  Process the AV Sync interrupt. This function is called in interrupt context

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  AV Sync callback request is queued with snd task. May result in task switch

==========================================================================*/
void qdsp_cmd_do_av_sync( void )
{
#if defined(FEATURE_QSYNTH_ADPCM) || defined(FEATURE_QTUNES_COMMON)
  qword num_samples_counter = {0, 0}, msecs = {0, 0};
  qword num_bytes_counter   = {0, 0};
#endif /* FEATURE_QSYNTH_ADPCM || FEATURE_QTUNES_COMMON */

  if (qdsp_cmd_av_sync_info.qdsp_cmd_av_sync_cb == NULL) {
    return;
  }

  switch (qdsp_cmd_image_select) {

#if defined(QDSP_IMAGE_H263D_DEFINED)                || \
    defined(QDSP_IMAGE_H263D_AMR_DEFINED)            || \
    defined(QDSP_IMAGE_H264D_AMR_DEFINED)            || \
    defined(QDSP_IMAGE_H264D_EVRC_DEFINED)           || \
    defined(QDSP_IMAGE_MP4D_DEFINED)                 || \
    defined(QDSP_IMAGE_MP4D_AMR_DEFINED)             || \
    defined(QDSP_IMAGE_AMR_DEFINED)                  || \
    defined(QDSP_IMAGE_AMR_WB_DEFINED)               || \
    defined(QDSP_IMAGE_VOC_DEFINED)                  || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED)            || \
    defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)              || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED)         || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)              || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)              || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)               || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)               || \
    defined(QDSP_IMAGE_VOC_EVRC_DEFINED)             || \
    defined(QDSP_IMAGE_VOC_E90_DEFINED)              || \
    defined(QDSP_IMAGE_VOC_EVRC_E90_DEFINED)         || \
    defined(QDSP_IMAGE_VOC_QTV_DEFINED)              || \
    defined(QDSP_IMAGE_4GV_DEFINED)                  || \
    defined(QDSP_IMAGE_4GV_WB_DEFINED)               || \
    defined(QDSP_IMAGE_EFR_DEFINED)                  || \
    defined(QDSP_IMAGE_FR_DEFINED)                   || \
    defined(QDSP_IMAGE_HR_DEFINED)                   || \
    defined(QDSP_IMAGE_AMR_YCBCR2_DEFINED)           || \
    defined(QDSP_IMAGE_EFR_YCBCR2_DEFINED)           || \
    defined(QDSP_IMAGE_FR_YCBCR2_DEFINED)            || \
    defined(QDSP_IMAGE_HR_YCBCR2_DEFINED)            || \
    defined(QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED)     || \
    defined(QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED)    || \
    defined(QDSP_IMAGE_QVP_BAYER_AMR_DEFINED)        || \
    defined(QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED)        || \
    defined(QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED)       || \
    defined(QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED)      || \
    defined(QDSP_IMAGE_QVP_H263P3_AMR_DEFINED)       || \
    defined(QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED)	     || \
    defined(QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED)     || \
    defined(QDSP_IMAGE_QCAMERA_DEFINED)              || \
    defined(QDSP_IMAGE_QTV_VOC_H264_DEFINED)         || \
    defined(QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED)   || \
    defined(QDSP_IMAGE_QTV_DEFINED)
#ifdef QDSP_IMAGE_H263D_DEFINED
    case QDSP_IMAGE_H263D:
#endif
#ifdef QDSP_IMAGE_H263D_AMR_DEFINED
    case QDSP_IMAGE_H263D_AMR:
#endif
#ifdef QDSP_IMAGE_H264D_AMR_DEFINED
    case QDSP_IMAGE_H264D_AMR:
#endif
#ifdef QDSP_IMAGE_H264D_EVRC_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_MP4D_DEFINED
    case QDSP_IMAGE_MP4D:
#endif
#ifdef QDSP_IMAGE_MP4D_AMR_DEFINED
    case QDSP_IMAGE_MP4D_AMR:
#endif
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif
#ifdef QDSP_IMAGE_4GV_DEFINED
    case QDSP_IMAGE_4GV:
#endif
#ifdef QDSP_IMAGE_4GV_WB_DEFINED
    case QDSP_IMAGE_4GV_WB:
#endif
#ifdef QDSP_IMAGE_4GV_VOIP_DEFINED
    case QDSP_IMAGE_4GV_VOIP:
#endif
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif
#ifdef QDSP_IMAGE_AMR_YCBCR2_DEFINED
    case QDSP_IMAGE_AMR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_EFR_YCBCR2_DEFINED
    case QDSP_IMAGE_EFR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_FR_YCBCR2_DEFINED
    case QDSP_IMAGE_FR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_HR_YCBCR2_DEFINED
    case QDSP_IMAGE_HR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_H263:
#endif
#ifdef QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_MPEG4:
#endif
#ifdef QDSP_IMAGE_QVP_BAYER_AMR_DEFINED
    case QDSP_IMAGE_QVP_BAYER_AMR;
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_AMR_DEFINED
    case QDSP_IMAGE_QVP_H263P3_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED
    case QDSP_IMAGE_QVP_H263P3_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
#endif
#ifdef QDSP_IMAGE_QTV_VOC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_DEFINED
    case QDSP_IMAGE_QTV:
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED
    case QDSP_IMAGE_QCAMCORDER_COMBO:
#endif
      qdsp_cmd_av_sync_info.interrupt_counter++;
      if (qdsp_cmd_av_sync_info.av_sync_first_time == TRUE) {
        qdsp_cmd_av_sync_voc_cb();
        qdsp_cmd_av_sync_info.av_sync_first_time = FALSE;
      }

      if(qdsp_cmd_av_sync_info.interrupt_counter ==
                          qdsp_cmd_av_sync_info.av_sync_next) {
        qdsp_cmd_av_sync_info.av_sync_next +=
                                 qdsp_cmd_av_sync_info.av_sync_interval;
        if (qdsp_cmd_av_sync_info.av_sync_first_time == FALSE) {
          qdsp_cmd_av_sync_voc_cb();
        }
      }
      break;
#endif

#if defined(FEATURE_QSYNTH_ADPCM) || defined(FEATURE_QTUNES_COMMON)

#if defined(QDSP_IMAGE_RA_DEFINED)              || \
    defined(QDSP_IMAGE_WM_DEFINED)              || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)          || \
    defined(QDSP_IMAGE_AAC_DEFINED)             || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED)    || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)         || \
    defined(QDSP_IMAGE_MP4D_AAC_DEFINED)        || \
    defined(QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED) || \
    defined(QDSP_IMAGE_H263D_AAC_DEFINED)       || \
    defined(QDSP_IMAGE_H264D_AAC_DEFINED)       || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)    || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_TUNES_DEFINED)           || \
    defined(QDSP_IMAGE_MP4D_MP3_DEFINED)        || \
    defined(QDSP_IMAGE_H263D_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)        || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)

#if defined(QDSP_IMAGE_RA_DEFINED)              || \
    defined(QDSP_IMAGE_WM_DEFINED)              || \
    defined(QDSP_IMAGE_AAC_DEFINED)             || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED)    || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)         || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)    || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)        || \
    (defined(QDSP_IMAGE_SYNTH_DEFINED) && defined(FEATURE_WEBAUDIO)) || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)   || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)

#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#if defined(QDSP_IMAGE_SYNTH_DEFINED) && \
    defined(FEATURE_WEBAUDIO)
    case QDSP_IMAGE_SYNTH:
#endif /*  QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
      if (qdsp_read(QDSP_AVSyncInterruptFlag))
      {
        qw_set(num_bytes_counter,
               qdsp_read(QDSP_AVSyncNumBytesCounterMSW),
               qdsp_read(QDSP_AVSyncNumBytesCounterDword));

        MSG_HIGH("num_bytes = %d%d",
                 qw_hi(num_bytes_counter),
                 qw_lo(num_bytes_counter),
                 0);
      }
#endif /* QDSP_IMAGE_RA_DEFINED      || QDSP_IMAGE_WM_DEFINED           ||
          QDSP_IMAGE_AAC_DEFINED     || QDSP_IMAGE_ENH_AAC_PLUS_DEFINED ||
          QDSP_IMAGE_QTV_AAC_DEFINED || QDSP_IMAGE_QTV_CONC_DEFINED     ||
          QDSP_IMAGE_SYNTH_DEFINED                                      */

    /* Fall Through */
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */

      if (qdsp_read(QDSP_AVSyncInterruptFlag))
      {
        qw_set(num_samples_counter,
               qdsp_read(QDSP_AVSyncNumSamplesCounterMSW),
               qdsp_read(QDSP_AVSyncNumSamplesCounterDword));
        if(qdsp_cmd_av_sync_info.pcm_sample_half) {
          qw_div(num_samples_counter,num_samples_counter, 2);
        }

        MSG_HIGH("num_samples = %d%d",
                 qw_hi(num_samples_counter),
                 qw_lo(num_samples_counter),
                 0);

        
   #ifdef FEATURE_CMI
#error code not present
    #else
    	clk_uptime_ms(msecs);
    #endif

        MSG_HIGH("msecs = %d%d",
                 qw_hi(msecs),
                 qw_lo(msecs),
                 0);

        qdsp_cmd_av_sync_info.qdsp_cmd_av_sync_cb(msecs,
                                                  num_samples_counter,
                                                  num_bytes_counter);

        qdsp_write(QDSP_AVSyncInterruptFlag,0x00);
      }
      break;
#endif /* QDSP_IMAGE_RA_DEFINED        || QDSP_IMAGE_WM_DEFINED        ||
          QDSP_IMAGE_AAC_DEFINED       || QDSP_IMAGE_ENH_AAC_DEFINED   ||
          QDSP_IMAGE_MP4D_AAC_DEFINED  || QDSP_IMAGE_MP4D_AAC_NO_VPP   ||
          QDSP_IMAGE_H263D_AAC_DEFINED || QDSP_IMAGE_H264D_AAC_DEFINED ||
          QDSP_IMAGE_QTV_AAC_DEFINED   || QDSP_IMAGE_TUNES_DEFINED     ||
          QDSP_IMAGE_MP4D_MP3_DEFINED  || QDSP_IMAGE_H263D_MP3_DEFINED ||
          QDSP_IMAGE_SYNTH_DEFINED     || QDSP_IMAGE_QTV_CONC_DEFINED  */
#endif /* FEATURE_QSYNTH_ADPCM || FEATURE_QTUNES_COMMON */
    default:
      break;
  }

}
#endif /* FEATURE_AUDIO_FORMAT */

/* <EJECT> */
#ifdef FEATURE_MVS

#ifdef MSMAUD_VOC_AMR_WB
/*===========================================================================

FUNCTION QDSP_CMD_AMR_WB_REGISTER

DESCRIPTION
  Call this function to register the uplink and downlink processing funcitons
  for AMR_WB Voice Services.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_amr_wb_register(
  qdsp_amr_wb_ul_fn_type  uplink_func,
  qdsp_amr_wb_dl_fn_type  downlink_func
)
{
  amr_wb_uplink_func   = uplink_func;
  amr_wb_downlink_func = downlink_func;
}
#endif /* MSMAUD_VOC_AMR_WB */

/* <EJECT> */
#ifdef MSMAUD_VOC_AMR
/*===========================================================================

FUNCTION QDSP_CMD_AMR_REGISTER

DESCRIPTION
  Call this function to register the uplink and downlink processing funcitons
  for AMR Voice Services.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_amr_register(
  qdsp_amr_ul_fn_type  uplink_func,
  qdsp_amr_dl_fn_type  downlink_func
)
{
  amr_uplink_func   = uplink_func;
  amr_downlink_func = downlink_func;
}
#endif /* MSMAUD_VOC_AMR */

/* <EJECT> */
#if defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_EFR)
#error code not present
#endif  /* MSMAUD_VOC_FR || MSMAUD_VOC_EFR */

/* <EJECT> */
#ifdef MSMAUD_VOC_HR
/*===========================================================================

FUNCTION qdsp_cmd_hr_register

DESCRIPTION
  This function sets the function pointers for the HR uplink and downlink
  processing functions.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_hr_register(
  qdsp_hr_ul_fn_type  uplink_func,
  qdsp_hr_dl_fn_type  downlink_func
)
{
  hr_uplink_func   = uplink_func;
  hr_downlink_func = downlink_func;
}
#endif  /* MSMAUD_VOC_HR */

/* <EJECT> */
#ifdef MSMAUD_VOC_G711
/*===========================================================================

FUNCTION qdsp_cmd_g711_register

DESCRIPTION
  This function sets the function pointers for the G711 uplink and downlink
  processing functions.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_g711_register(
  qdsp_g711_ul_fn_type  uplink_func,
  qdsp_g711_dl_fn_type  downlink_func
)
{
  g711_uplink_func   = uplink_func;
  g711_downlink_func = downlink_func;
}
#endif  /* MSMAUD_VOC_G711 */

/* <EJECT> */
#ifdef MSMAUD_VOC_G723
/*===========================================================================

FUNCTION qdsp_cmd_g723_register

DESCRIPTION
  This function sets the function pointers for the G723 uplink and downlink
  processing functions.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_g723_register(
  qdsp_g723_ul_fn_type  uplink_func,
  qdsp_g723_dl_fn_type  downlink_func
)
{
  g723_uplink_func   = uplink_func;
  g723_downlink_func = downlink_func;
}
#endif  /* MSMAUD_VOC_G723 */

#endif  /* FEATURE_MVS */

/* <EJECT> */

#ifdef FEATURE_VOC_PACKET_INTERFACE
/*===========================================================================

FUNCTION QDSP_CMD_REGISTER_PACKET_CLIENTS

DESCRIPTION
  Clients that use the packet interface to send/receive data must
  register callbacks using this function.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_register_packet_clients (
  qdsp_cmd_rl_packet_fn_type  rl_func,
  qdsp_cmd_fl_packet_fn_type  fl_func
)
{
  qdsp_cmd_rl_packet_func = rl_func;
  qdsp_cmd_fl_packet_func = fl_func;
}
#endif /* FEATURE_VOC_PACKET_INTERFACE */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_COMMAND

DESCRIPTION
  This function will send a command to the firmware using the specified command
  register.

DEPENDENCIES
  The command register must be zero - indicating that the firmware is free to
  accept a new command

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type  qdsp_command (
  volatile uint16 *cmd_register,
    /* Address of the firmware command register */
  volatile uint16 *cmd_buf_ptr,
    /* Address of the firmware command param buffer */
           uint16 *cmd_ptr
    /* Pointer to command packet to send. The first word of this packet
       must specify the length, in words, of the remainder of the command
       packet. */
)
{
  int             buf_length;      /* length of command                       */
  volatile uint16 *buf_ptr;
  uint32          isave;           /* save int flags                          */
  word            command;
  word            semaphore_flag;  /* indicates whether packet can be written */
  qdsp_cmd_status_type  ret_val;          /* return status of packet exchange */


  /*  Get the address of the command buffer in the ARM address space
  */
  buf_ptr = cmd_buf_ptr;

  /* Only one command can be sent to the firmware at a time,
     so check if the firmware is busy, lock interrupts to avoid
     race conditions.
  */

  INTLOCK_SAV( isave );

  buf_length = *cmd_ptr++;            /* Copy length of command   */

  /* make sure we have a valid command buffer    */
  if ((buf_length > QDSP2_MAX_BUF_LENGTH) ||
      (buf_length < QDSP2_MIN_BUF_LENGTH))
  {
    MSG_ERROR("Firmware cmd length exceeds buffer length!", 0,0,0);
    ret_val = QDSP_CMD_FAILED;
    INTFREE_SAV( isave );
    return(ret_val);
  }

  buf_length--;

  /* Check the command header to make sure that the QDSP2 is ready to accept
  ** a command.
  */
  semaphore_flag = qdsp_read(cmd_register);

  /* If sempahore flag is not 0 then DSP has not cleared the command
  header */
  if ( semaphore_flag != 0 )
  {
    MSG_HIGH("QDSP command buffer not ready %d ", semaphore_flag,0,0);
    ret_val = QDSP_CMD_FAILED;
    INTFREE_SAV( isave );
    return(ret_val);
  }

  /* Save command type to be written after the whole command has
  ** been written to the DSP.
  */
  command = *cmd_ptr++;

  /* send command buffer data to DSP               */
  while (--buf_length) {
    *buf_ptr++ = *cmd_ptr++;
  }

  /* semaphore was 0 so write the command type into command header */
  qdsp_write(cmd_register, command);

  /* To generate microprocessor interrupt */
  qdsp_up_to_dsp_irq();

  ret_val = QDSP_CMD_SUCCESS;
  INTFREE_SAV( isave );

  MSG_HIGH("qdsp_command(0x%x)", command, 0, 0);

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP2_COMMAND

DESCRIPTION
  This function will send a command to the DSP.

DEPENDENCIES
  The host should not issue any additional commands for at least 1.5ms after
  reset.  After the 1.5ms the host must issue the configuration command (0x0100)
  and initialize vocoder timing command (0x0101) to resume operation of the
  vocoder.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type  qdsp2_command (
  uint16 *cmd_ptr
    /* Pointer to command packet to send. The first word of this packet
       must specify the length, in words, of the remainder of the command
       packet. */
)
{
  return qdsp_command(qdsp_address(QDSP_uPCommandReg, 0),
                      qdsp_address(QDSP_uPCommandBuf, 0),
                      cmd_ptr);
}

#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
/*===========================================================================

FUNCTION qdsp_mixer_command

DESCRIPTION
  This function specifically sends command to mixer part.

DEPENDENCIES
  NONE.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type  qdsp_mixer_command (
  uint16 *cmd_ptr
    /* Pointer to command packet to send. The first word of this packet
       must specify the length, in words, of the remainder of the command
       packet. */
)
{
  return qdsp_command(qdsp_address(QDSP_mixerCommandReg, 0),
                      qdsp_address(QDSP_mixerCommandBuf, 0),
                      cmd_ptr);
}
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB */

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
/*===========================================================================

FUNCTION qdsp_adec_command

DESCRIPTION
  Issues the adec command to audio part during incall state.

DEPENDENCIES
  NONE.

RETURN VALUE
   A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type  qdsp_adec_command (
  uint16 *cmd_ptr
    /* Pointer to command packet to send. The first word of this packet
       must specify the length, in words, of the remainder of the command
       packet. */
)
{
  return qdsp_command(qdsp_address(QDSP_adecCommandReg, 0),
                      qdsp_address(QDSP_adecCommandBuf, 0),
                      cmd_ptr);
}
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */

/* <EJECT> */
#ifdef FEATURE_GASYNTH_INTERFACE
/*===========================================================================

FUNCTION qdsp_cmd_reset_adec_cmd_buf

DESCRIPTION
  A function resets the qsynth adec commands buffer as any currently queued
  commands are no longer valid.

DEPENDENCIES
  This function should only be invoked as QSYNTH DSP is transitioning to
  sleep state

RETURN VALUE
  None

SIDE EFFECTS
  None
============================================================================*/
void qdsp_cmd_reset_adec_cmd_buf() {

  MSG_LOW("Reset qsynth adec cmd buffer", 0, 0, 0);
  TASKLOCK();
  qdsp_cmd_qsynth_adec_cmd_buffer.front = 0;
  qdsp_cmd_qsynth_adec_cmd_buffer.num_commands = 0;
  TASKFREE();

}

/*===========================================================================

FUNCTION qdsp_cmd_set_adec_timer_cb

DESCRIPTION
  A function sets the callback function pointer. The callback function is
  used to schedule rex timer to try sending adec command to DSP again.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
============================================================================*/
void qdsp_cmd_set_adec_timer_cb(
  qdsp_cmd_adec_timer_cb_func_type cb_func
) {
  qdsp_cmd_adec_timer_cb = cb_func;
}

/*===========================================================================

FUNCTION qdsp_cmd_qsynth_send_cmd

DESCRIPTION
  A function sends the synth cmd to to DSP.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
============================================================================*/
inline qdsp_cmd_status_type qdsp_cmd_qsynth_send_cmd(
  word *cmd_buf
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  if (qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {
    ret_val = qdsp2_command(cmd_buf);
  }
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif

 #ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
  else if (qdsp_cmd_image_select==QDSP_IMAGE_CAM_AUDIO_CONC){
    ret_val = qdsp2_command(cmd_buf);
  }
 #endif /*  QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */

#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
  else if (qdsp_cmd_image_select == QDSP_IMAGE_VOC_COMBO_SYNTH) {
    ret_val = qdsp_adec_command(cmd_buf);
  }
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
  return(ret_val);
}
/*===========================================================================

FUNCTION qdsp_cmd_qsynth_state_addr

DESCRIPTION
 check the state of the DSP.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
==========================================================================*/
inline volatile uint16 *qdsp_cmd_qsynth_state_addr() {
  if (qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {
    return(QDSP_qdspState);
  }

#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif /*  QDSP_IMAGE_QSYNTH_RS_DEFINED */

#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
  else if ( qdsp_cmd_image_select == QDSP_IMAGE_CAM_AUDIO_CONC ){
    return (QDSP_qdspState);
  }
#endif /*  QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
  else if (qdsp_cmd_image_select == QDSP_IMAGE_VOC_COMBO_SYNTH) {
    return(QDSP_adecState);
  }
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
}
/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_qsynth_adec_cmd_retry

DESCRIPTION
  A retry function to issue audio decoder command that are put in the command
  buffer to DSP.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
==========================================================================*/
void qdsp_cmd_qsynth_adec_cmd_retry() {
  qdsp_cmd_qsynth_adec_cmd_type *current_cmd;
  word                          adec_cmd[QDSP_CMD_ADEC_CONFIG_BUFF_SIZE];

  INTLOCK();
  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)

#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
      if ((sint15) qdsp_read(qdsp_cmd_qsynth_state_addr()) ==
          QDSP_STATE_SYNTH) {
        if (qdsp_cmd_qsynth_adec_cmd_buffer.num_commands > 0) {
          /* Command queue is not empty */
          current_cmd = &qdsp_cmd_qsynth_adec_cmd_buffer.cmd_content[
                                qdsp_cmd_qsynth_adec_cmd_buffer.front];
          while( current_cmd->inuse == FALSE){
            if ((++qdsp_cmd_qsynth_adec_cmd_buffer.front) >=
                    QDSP_CMD_ADEC_CMD_BUFF_SIZE) {
              /* essentially doing modulus operation */
              qdsp_cmd_qsynth_adec_cmd_buffer.front -=
                                       QDSP_CMD_ADEC_CMD_BUFF_SIZE;
            }
            if( --qdsp_cmd_qsynth_adec_cmd_buffer.num_commands == 0){
              break;
            }
            current_cmd = &qdsp_cmd_qsynth_adec_cmd_buffer.cmd_content[
                                 qdsp_cmd_qsynth_adec_cmd_buffer.front];
          }

         if( current_cmd->inuse){
          if (current_cmd->cmd_type ==
              QDSP_CMD_ADEC_ACTION_CMD_HDR) {
            adec_cmd[0] = QDSP_CMD_ADEC_ACTION_BUFF_SIZE;
            adec_cmd[1] = QDSP_CMD_ADEC_ACTION_CMD_HDR;
          } else {
            adec_cmd[0] = QDSP_CMD_ADEC_CONFIG_BUFF_SIZE;
            adec_cmd[1] = QDSP_CMD_ADEC_CONFIG_CMD_HDR;
          }
          memcpy(adec_cmd + 2, (byte*) current_cmd->cmd_param,
                 QDSP_CMD_ADEC_CMD_MAX_SIZE << 1);
          if (qdsp_cmd_qsynth_send_cmd(adec_cmd) == QDSP_CMD_SUCCESS) {
            qdsp_cmd_qsynth_change_adec_state( adec_cmd, 0xFFFF, TRUE );
              qdsp_cmd_qsynth_adec_cmd_buffer.front++;
              if (qdsp_cmd_qsynth_adec_cmd_buffer.front >=
                      QDSP_CMD_ADEC_CMD_BUFF_SIZE) {
                /* essentially doing modulus operation */
                qdsp_cmd_qsynth_adec_cmd_buffer.front -=
                                         QDSP_CMD_ADEC_CMD_BUFF_SIZE;
              }
              qdsp_cmd_qsynth_adec_cmd_buffer.num_commands--;
            }  /* qdsp2_command End */
          } /* current_cmd->inuse == TRUE */
        } /* num_commands > 0 */
      } /* qdsp_state_synth */
      break;

#endif /* QDSP_IMAGE_SYNTH_DEFINED || QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */

    default: /* Synth image is no longer resident. Clear the queue */
      MSG_HIGH("Enter qdsp_cmd_qsynth_adec_cmd_retry() with wrong DSP image",
                                                                       0, 0, 0);
      qdsp_cmd_qsynth_adec_cmd_buffer.front = 0;
      qdsp_cmd_qsynth_adec_cmd_buffer.num_commands = 0;
      break;
  }

  if (qdsp_cmd_adec_timer_cb != NULL) {
    if (qdsp_cmd_qsynth_adec_cmd_buffer.num_commands > 0) {
      /* There are still commands left in the queue. schedule timer again*/
      qdsp_cmd_adec_timer_cb(TRUE);
    } else {
      qdsp_cmd_adec_timer_cb(FALSE);
    }
  }
  INTFREE();
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_qsynth_adec_cmd

DESCRIPTION
  Issue audio decoder command to DSP. It will queue up the command if DSP is not
  ready to accept the command. If the queue is full, return QDSP_CMD_FAILED


RETURN VALUE
   Returns QDSP_CMD_SUCCESS either the command is delivered succesfully or
   insert in the command queue. Returns QDSP_CMD_FAILED if the command
   queue is full.

SIDE EFFECTS
  None

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_qsynth_adec_cmd(
  word  *req_cmd,
  uint32  channel
) {
  word                          *buf_ptr;
  int                           buf_length;
  int                           index;
  qdsp_cmd_qsynth_adec_cmd_type *current_cmd;
  qdsp_cmd_status_type          retval = QDSP_CMD_SUCCESS;
  boolean                       queuecmd = TRUE;
  boolean                       ret_state = FALSE;

  ret_state = qdsp_cmd_qsynth_change_adec_state( req_cmd, channel, FALSE );
  INTLOCK();
  if (qdsp_cmd_qsynth_adec_cmd_buffer.num_commands != 0) {
    /* Command queue is not empty, attempt to write
       command to DSP right away */
    qdsp_cmd_qsynth_adec_cmd_retry();
  } else if (ret_state == TRUE){
    if(qdsp_cmd_qsynth_send_cmd(req_cmd) == QDSP_CMD_SUCCESS) {
      qdsp_cmd_qsynth_change_adec_state( req_cmd, channel, TRUE );
      queuecmd = FALSE;
    }
  } else {
    queuecmd = FALSE;
  }

  if (queuecmd == TRUE) {
    /* Queue the command if the queue is not empty
       or DSP is not accepting command */
    if (qdsp_cmd_qsynth_adec_cmd_buffer.num_commands <
            QDSP_CMD_ADEC_CMD_BUFF_SIZE) {
          /* Command buffer is not full */
      index = qdsp_cmd_qsynth_adec_cmd_buffer.front +
              qdsp_cmd_qsynth_adec_cmd_buffer.num_commands;
      if (index >= QDSP_CMD_ADEC_CMD_BUFF_SIZE) {
        /* essentially doing modulus operation */
        index -= QDSP_CMD_ADEC_CMD_BUFF_SIZE;
      }
      current_cmd = &qdsp_cmd_qsynth_adec_cmd_buffer.cmd_content[index];
      buf_length = *req_cmd++;
      buf_length -= 2;
      current_cmd->cmd_type = *req_cmd++;
      current_cmd->inuse    = TRUE;
      buf_ptr = &current_cmd->cmd_param[0];
      memcpy((byte*) buf_ptr, (byte*) req_cmd, buf_length << 1);
      qdsp_cmd_qsynth_adec_cmd_buffer.num_commands++;
      if (qdsp_cmd_adec_timer_cb != NULL) {
        qdsp_cmd_adec_timer_cb(TRUE);
      }
    } else {
      MSG_ERROR("Audio decoder command buffer is full", 0, 0, 0);
      retval = QDSP_CMD_FAILED;
    }
  }
  INTFREE();

  return(retval);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_qsynth_change_adec_state

DESCRIPTION
  Changes the State of qdsp_cmd_qsynth_adpcm_data[channel].adec_state and
  maintains Start/Stop states (qdsp_cmd_qsynth_adec_state) based on the
  state of DSP. Issued indicates that the present command has been sent to
  DSP successfully. It follows the below structure:

  1.ADEC Config Command/ADEC Action Active(Start/Delayed Start):

   If(not issued)-------> Start Pending--------->Start Issued
                                       If(issued)   |
                                                    | If((adec_active = 1)
                                                    |  & (adec_stop = 0))
              return TRUE  <----------ADEC Ready  <-

  2.ADEC Action STOP:

  2.1 If(not issued)-------> Stop Pending--------->Stop Issued
                                       If(issued)   |
                                                    | If((adec_active = 0)
                                                    |  & (adec_stop = 1))
              return TRUE  <---------ADEC Stopped <-

  2.2 If(not issued)-------> Stop Pending---------------> Search for Config/
                                        If(Start Pending) Action Active
                                                          and cancel all the
                                                          commands after that
                                                          in Cmd Queue.
      return FALSE <------- Reset Start & Stop Pending <--|


RETURN VALUE
   Returns TRUE if the state has been successfully changed.
   If this returns TRUE, the config/action command can be written to
   DSP. Returns FALSE when the present command should not be written
   to DSP.

SIDE EFFECTS
  None

==========================================================================*/
boolean qdsp_cmd_qsynth_change_adec_state(
  uint16  *adec_cmd,
  uint32  channel,
  boolean  issued
){
  boolean ret_val = TRUE;
  uint32 adec_state;
  volatile uint16   *adec_active;
  volatile uint16   *adec_stop;
  int               index;
  uint16            adec_cmd_channel;

  if( (adec_cmd != NULL) && (channel == 0xFFFF)){
    channel = 0;
    adec_cmd_channel = adec_cmd[2] & 0x7FFF;
    /* Note: This doesn't give the correct channel num if a single command
             is issued for multiple channels */
    if ( adec_cmd[1] == QDSP_CMD_ADEC_CONFIG_CMD_HDR ) {
      channel = adec_cmd_channel;
    } else if ( adec_cmd[1] == QDSP_CMD_ADEC_ACTION_CMD_HDR ) {
      while( adec_cmd_channel > 1 ) {
        adec_cmd_channel >>= 1;
        channel++;
      }
    }
  }

  switch(channel) {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS

#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
  {
    case 1:
      adec_active        = QDSP_adecAdpcmActive1;
      adec_stop          = QDSP_adecStopFlagCh1;
      break;

    case 2:
      adec_active        = QDSP_adecAdpcmActive2;
      adec_stop          = QDSP_adecStopFlagCh2;
      break;

    case 3:
      adec_active        = QDSP_adecAdpcmActive3;
      adec_stop          = QDSP_adecStopFlagCh3;
      break;
  }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */

    case 0:
    default:
      adec_active        = QDSP_adecAdpcmActive0;
      adec_stop          = QDSP_adecStopFlagCh0;
      channel            = 0;
      break;
  }

  adec_state = qdsp_cmd_qsynth_adpcm_data[channel].adec_state;
  if ((adec_state & QDSP_CMD_QSYNTH_START_ISSUED) &&
      (qdsp_read( adec_active) && !qdsp_read(adec_stop))
     ){
    adec_state &= ~QDSP_CMD_QSYNTH_START_ISSUED;
    adec_state |= QDSP_CMD_QSYNTH_ADEC_READY;
  }
  if ((adec_state & QDSP_CMD_QSYNTH_STOP_ISSUED) &&
      !(qdsp_read( adec_active) && qdsp_read(adec_stop))
     ){
    adec_state &= ~QDSP_CMD_QSYNTH_STOP_ISSUED;
    adec_state |= QDSP_CMD_QSYNTH_ADEC_STOPPED;
  }

  if( adec_cmd != NULL){
    if((adec_cmd[1] == QDSP_CMD_ADEC_CONFIG_CMD_HDR) ||
       ((adec_cmd[1] == QDSP_CMD_ADEC_ACTION_CMD_HDR) &&
        (adec_cmd[channel + 3] == QDSP_CMD_ADEC_ACTION_ACTIVE))){
      /*  ADEC Config Command or ADEC Action Active*/

      if( !issued){
        adec_state |= QDSP_CMD_QSYNTH_START_PENDING;
      } else {
        adec_state &= ~QDSP_CMD_QSYNTH_START_PENDING;
        adec_state |= QDSP_CMD_QSYNTH_START_ISSUED;
      }
      if( adec_state & QDSP_CMD_QSYNTH_ADEC_STOPPED){
        adec_state &= ~QDSP_CMD_QSYNTH_ADEC_STOPPED;
      }
    } else if ((adec_cmd[1] == QDSP_CMD_ADEC_ACTION_CMD_HDR) &&
               (adec_cmd[channel + 3] == QDSP_CMD_ADEC_ACTION_STOP)){
      /* ADEC Action STOP */

      if( !issued){
        adec_state |= QDSP_CMD_QSYNTH_STOP_PENDING;
      } else {
        adec_state &= ~QDSP_CMD_QSYNTH_STOP_PENDING;
        adec_state |= QDSP_CMD_QSYNTH_STOP_ISSUED;
      }
      if( adec_state & QDSP_CMD_QSYNTH_ADEC_READY){
        adec_state &= ~QDSP_CMD_QSYNTH_ADEC_READY;
      } else if( !issued && (adec_state & QDSP_CMD_QSYNTH_START_PENDING) ){
        // removing all commands after start from command queue
        qdsp_cmd_qsynth_adec_cmd_type  *current_cmd;
        boolean found_start = FALSE;
        index = 0;

        current_cmd = &qdsp_cmd_qsynth_adec_cmd_buffer.cmd_content[
                                    qdsp_cmd_qsynth_adec_cmd_buffer.front];
        while( index++ < qdsp_cmd_qsynth_adec_cmd_buffer.num_commands) {

          if( (1 << channel) & current_cmd->cmd_param[0]){
            if( (current_cmd->cmd_type == QDSP_CMD_ADEC_CONFIG_CMD_HDR) ||
                (current_cmd->cmd_param[channel + 1] == QDSP_CMD_ADEC_ACTION_ACTIVE)){
              found_start = TRUE;
            }
            if( found_start == TRUE){
              current_cmd->cmd_param[0] &= ~(1 << channel);
              if( (current_cmd->cmd_param[0] & 0x7FFF) == 0){
                current_cmd->inuse = FALSE;
              }
            }
          }

          if( qdsp_cmd_qsynth_adec_cmd_buffer.front + index
              == QDSP_CMD_ADEC_CMD_BUFF_SIZE){
            current_cmd = &qdsp_cmd_qsynth_adec_cmd_buffer.cmd_content[0];
          } else{
            current_cmd++;
          }
        } /* While all commands in command queue */

        adec_state &=
           ~( QDSP_CMD_QSYNTH_START_PENDING|QDSP_CMD_QSYNTH_STOP_PENDING);
        ret_val = FALSE;
        /* Ignoring the command-write after resetting Start and Stop */
      }
    }
  }

  qdsp_cmd_qsynth_adpcm_data[channel].adec_state = adec_state;

  return ret_val;
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_qsynth_voc_adec_start

DESCRIPTION
  This function configures audio decoder to process QCP or AMR-NB
  audio

DEPENDENCIES
  This command is only valid when the DSP is in QSYNTH state.

RETURN VALUE
  A value of qdsp_cmd_status_type to inidicate whether the
  configuration command was sent to DSP correctly.

SIDE EFFECTS
  NONE

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_qsynth_voc_adec_start(
  uint32                             channel,
  qdsp_cmd_adec_voc_enum_type        voc_type,
  qdsp_cmd_adec_start_mode_enum_type start_mode
) {
  qdsp_cmd_status_type retval = QDSP_CMD_SUCCESS;
  word                 config_cmd[QDSP_CMD_ADEC_CONFIG_BUFF_SIZE];
  uint8                cmd_index = 0;

  config_cmd[cmd_index++] = QDSP_CMD_ADEC_CONFIG_BUFF_SIZE;
  config_cmd[cmd_index++] = QDSP_CMD_ADEC_CONFIG_CMD_HDR;
  /* Setting bit 15 to 1 to activate decoder right away */
  if(start_mode == QDSP_CMD_ADEC_START_MODE_DELAYED) {
    config_cmd[cmd_index++] = channel;
  } else {
    config_cmd[cmd_index++] = channel | 0x8000;
  }
  if (voc_type == QDSP_CMD_ADEC_VOC_AMR) {
    config_cmd[cmd_index++] = QDSP_CMD_QSYNTH_ADEC_AMR;
  } else {
    config_cmd[cmd_index++] = QDSP_CMD_QSYNTH_ADEC_QCP;
  }
  config_cmd[cmd_index++] = QDSP_CMD_ADEC_VOC_SAMPLE_RATE;
  config_cmd[cmd_index]   = QDSP_CMD_ADEC_VOC_CHAN_MODE;

#ifdef FEATURE_QSYNTH_ADPCM
  qdsp_cmd_qsynth_adpcm_data[channel].mode = QDSP_CMD_ADPCM_INVALID_MODE;
#endif /* FEATURE_QSYNTH_ADPCM */
  qdsp_cmd_synth_adec_enabled[channel] = TRUE;
  qdsp_cmd_qsynth_adpcm_data[channel].stamp_counter = 1;
  qdsp_cmd_qsynth_adpcm_data[channel].buffer = NULL;
  qdsp_cmd_qsynth_adpcm_data[channel].buffer2 = NULL;
  qdsp_cmd_qsynth_adpcm_data[channel].length = 0;
  qdsp_cmd_qsynth_adpcm_data[channel].length2 = 0;
  qdsp_cmd_qsynth_adpcm_data[channel].buf_state = QDSP_CMD_ADEC_STATE_BUFFER1;
  retval = qdsp_cmd_qsynth_adec_cmd(config_cmd, channel);
  MSG_MED("start decoder %d", channel, 0, 0);
#ifdef FEATURE_QAUDIOFX
  if (retval == QDSP_CMD_SUCCESS) {
    qdsp_cmd_3d_pos_reset_src(channel);
  }
#endif /* FEATURE_QAUDIOFX */

  return (retval);
}

/*===========================================================================

FUNCTION qdsp_cmd_adec_data_consumed

DESCRIPTION
  This function detects decoder has finished consuming data.

DEPENDENCIES
  This command is only valid when the DSP is in QSYNTH state.

RETURN VALUE
  TRUE - data_is_needed flag is set
  FALSE - data_is_needed flag is not set

SIDE EFFECTS
  NONE

===========================================================================*/
boolean qdsp_cmd_adec_data_consumed(
  uint8 channel
) {
  boolean ret_val = FALSE;
  volatile uint16                 *adec_active;
  volatile uint16                 *adec_data_is_needed;

    switch(qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef QDSP_IMAGE_SYNTH_DEFINED
      case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
      case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
      switch(channel) {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS

#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
  {
      case 1:
        adec_active         = QDSP_adecAdpcmActive1;
        adec_data_is_needed = QDSP_adecAdpcmDataIsNeeded1;
        break;

      case 2:
        adec_active         = QDSP_adecAdpcmActive2;
        adec_data_is_needed = QDSP_adecAdpcmDataIsNeeded2;
        break;

      case 3:
        adec_active         = QDSP_adecAdpcmActive3;
        adec_data_is_needed = QDSP_adecAdpcmDataIsNeeded3;
        break;
  }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */

      case 0:
      default:
        adec_active         = QDSP_adecAdpcmActive0;
        adec_data_is_needed = QDSP_adecAdpcmDataIsNeeded0;
        channel              = 0;
        break;
      }
      ret_val = (qdsp_read(adec_active) != 0) &
                (qdsp_read(adec_data_is_needed) != 0);
        break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED || QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED*/

      default:
        break;
    }

  return ret_val;
}
#endif /* FEATURE_GASYNTH_INTERFACE */

/* <EJECT> */
/*===========================================================================

INTERNAL FUNCTION SWAP

DESCRIPTION
  This function swaps bytes.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  NONE

===========================================================================*/
void swap(
  uint8 *src_ptr,  /* source buffer                           */
  uint8 *dst_ptr,  /* destination buffer                      */
  int   num_words  /* number of words to swap                 */
)
{
  uint8 tbyte;

  num_words++;
  while(--num_words) {
    tbyte      = *src_ptr++;
    *dst_ptr++ = *src_ptr++;
    *dst_ptr++ = tbyte;
  }
}

#ifdef FEATURE_VOC_DTMF_DETECT
/* <EJECT> */
/*===========================================================================

FUNCTION
  qdsp_cmd_dtmf_detect_processing

DESCRIPTION
  This function reads the DTMF detection bits from the vocoder
  and executes the callback associated with dtmf detection.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  NONE

===========================================================================*/
void qdsp_cmd_dtmf_detect_processing() {
  uint16                              dtmf_tx_detect;
  uint16                              dtmf_rx_detect;
  qdsp_cmd_dtmf_detected_status_type  rx_status;
  qdsp_cmd_dtmf_detected_status_type  tx_status;


  if(qdsp_cmd_dtmf_detect_cb != NULL) {
    dtmf_tx_detect = qdsp_read(QDSP_dspMessageBuf);
    dtmf_rx_detect = qdsp_read_offset(QDSP_dspMessageBuf, 1);
    switch(dtmf_tx_detect) {
      case 0x11:
        tx_status = QDSP_CMD_DTMF_DETECTED_1;
        break;
      case 0x21:
        tx_status = QDSP_CMD_DTMF_DETECTED_2;
        break;
      case 0x41:
        tx_status = QDSP_CMD_DTMF_DETECTED_3;
        break;
      case 0x81:
        tx_status = QDSP_CMD_DTMF_DETECTED_A;
        break;
      case 0x12:
        tx_status = QDSP_CMD_DTMF_DETECTED_4;
        break;
      case 0x22:
        tx_status = QDSP_CMD_DTMF_DETECTED_5;
        break;
      case 0x42:
        tx_status = QDSP_CMD_DTMF_DETECTED_6;
        break;
      case 0x82:
        tx_status = QDSP_CMD_DTMF_DETECTED_B;
        break;
      case 0x14:
        tx_status = QDSP_CMD_DTMF_DETECTED_7;
        break;
      case 0x24:
        tx_status = QDSP_CMD_DTMF_DETECTED_8;
        break;
      case 0x44:
        tx_status = QDSP_CMD_DTMF_DETECTED_9;
        break;
      case 0x84:
        tx_status = QDSP_CMD_DTMF_DETECTED_C;
        break;
      case 0x18:
        tx_status = QDSP_CMD_DTMF_DETECTED_STAR;
        break;
      case 0x28:
        tx_status = QDSP_CMD_DTMF_DETECTED_0;
        break;
      case 0x48:
        tx_status = QDSP_CMD_DTMF_DETECTED_POUND;
        break;
      case 0x88:
        tx_status = QDSP_CMD_DTMF_DETECTED_D;
        break;
      default:
        tx_status = QDSP_CMD_DTMF_DETECTED_NONE;
        break;
    }
    switch(dtmf_rx_detect) {
      case 0x11:
        rx_status = QDSP_CMD_DTMF_DETECTED_1;
        break;
      case 0x21:
        rx_status = QDSP_CMD_DTMF_DETECTED_2;
        break;
      case 0x41:
        rx_status = QDSP_CMD_DTMF_DETECTED_3;
        break;
      case 0x81:
        rx_status = QDSP_CMD_DTMF_DETECTED_A;
        break;
      case 0x12:
        rx_status = QDSP_CMD_DTMF_DETECTED_4;
        break;
      case 0x22:
        rx_status = QDSP_CMD_DTMF_DETECTED_5;
        break;
      case 0x42:
        rx_status = QDSP_CMD_DTMF_DETECTED_6;
        break;
      case 0x82:
        rx_status = QDSP_CMD_DTMF_DETECTED_B;
        break;
      case 0x14:
        rx_status = QDSP_CMD_DTMF_DETECTED_7;
        break;
      case 0x24:
        rx_status = QDSP_CMD_DTMF_DETECTED_8;
        break;
      case 0x44:
        rx_status = QDSP_CMD_DTMF_DETECTED_9;
        break;
      case 0x84:
        rx_status = QDSP_CMD_DTMF_DETECTED_C;
        break;
      case 0x18:
        rx_status = QDSP_CMD_DTMF_DETECTED_STAR;
        break;
      case 0x28:
        rx_status = QDSP_CMD_DTMF_DETECTED_0;
        break;
      case 0x48:
        rx_status = QDSP_CMD_DTMF_DETECTED_POUND;
        break;
      case 0x88:
        rx_status = QDSP_CMD_DTMF_DETECTED_D;
        break;
      default:
        rx_status = QDSP_CMD_DTMF_DETECTED_NONE;
        break;
    }
    qdsp_cmd_dtmf_detect_cb(rx_status, tx_status);
    qdsp_write(QDSP_dspMessageReg, 0);
  }
}
#endif /* FEATURE_VOC_DTMF_DETECT */

/* <EJECT> */
#ifdef FEATURE_VOC_PCM_INTERFACE
/*===========================================================================

FUNCTION qdsp_cmd_register_pcm_input_client

DESCRIPTION
  Use this function to register a callback to feed PCM data on the RX input
  path to the vocoder.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  NONE

===========================================================================*/
void qdsp_cmd_register_pcm_input_client(
  qdsp_cmd_pcm_interface_type        interface,
  qdsp_cmd_pcm_interface_attrib_type *pcm_attrib,
  qdsp_cmd_pcm_client_input_fn_type  client_func
)
{
  switch (interface) {
    case QDSP_PCM_INTERFACE_RX_INPUT:
      qdsp_pcm_rx_input_func = client_func;
      qdsp_pcm_rx_input_pending_attrib = pcm_attrib;
      break;

    case QDSP_PCM_INTERFACE_TX_INPUT:
      qdsp_pcm_tx_input_func = client_func;
      qdsp_pcm_tx_input_pending_attrib = pcm_attrib;
      break;

    case QDSP_PCM_INTERFACE_RX_OUTPUT:
    case QDSP_PCM_INTERFACE_TX_OUTPUT:
    default:
      MSG_HIGH("Invalid PCM input interface type", 0, 0, 0);
      break;
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_register_pcm_output_client

DESCRIPTION
  Use this function to register a callbacks to get PCM output from the vocoder.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  NONE

===========================================================================*/
void qdsp_cmd_register_pcm_output_client(
  qdsp_cmd_pcm_interface_type         interface,
  qdsp_cmd_pcm_interface_attrib_type *pcm_attrib,
  qdsp_cmd_pcm_client_output_fn_type  client_func
)
{
  switch (interface) {
    case QDSP_PCM_INTERFACE_RX_OUTPUT:
      qdsp_pcm_rx_output_func = client_func;
      qdsp_pcm_rx_output_pending_attrib = pcm_attrib;
      break;

    case QDSP_PCM_INTERFACE_TX_OUTPUT:
      qdsp_pcm_tx_output_func = client_func;
      qdsp_pcm_tx_output_pending_attrib = pcm_attrib;
      break;

    case QDSP_PCM_INTERFACE_RX_INPUT:
    case QDSP_PCM_INTERFACE_TX_INPUT:
    default:
      MSG_HIGH("Invalid PCM output interface type", 0, 0, 0);
      break;
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_compare_pcm_attrib

DESCRIPTION
  Compare PCM attributes to see if they are compatible.  chan_id is not
compared.

DEPENDENCIES
  None

RETURN VALUE
  TRUE or FALSE

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_compare_pcm_attrib(
  const qdsp_cmd_pcm_interface_attrib_type *attrib_n,
  const qdsp_cmd_pcm_interface_attrib_type *attrib_m
)
{
  int cnt;
  uint16 sum;


  if (attrib_n == attrib_m)
  {
    return TRUE;
  }


  if ((attrib_n == NULL) || (attrib_m == NULL))
  {
    return FALSE;
  }


  /* chan_id not compared */

  if ((attrib_n->intf_dsc.sample_rate != attrib_m->intf_dsc.sample_rate)
      || (attrib_n->intf_dsc.frame_len != attrib_m->intf_dsc.frame_len))
  {
    return FALSE;
  }


  if ((attrib_n->interleave_dsc == NULL)
      || (attrib_n->interleave_dsc->num_interleave == 0)
      || (attrib_n->interleave_dsc->interleave_tbl == NULL))
  {
    if ((attrib_m->interleave_dsc == NULL)
        || (attrib_m->interleave_dsc->num_interleave == 0)
        || (attrib_m->interleave_dsc->interleave_tbl == NULL))
    {
      return TRUE;
    }

    sum = 0;
    for (cnt=0;cnt < attrib_m->interleave_dsc->num_interleave;cnt++)
    {
      sum += attrib_m->interleave_dsc->interleave_tbl[cnt].interleave_len;
    }

    return (sum==0)? TRUE : FALSE;
  }


  sum = 0;
  for (cnt=0;cnt < attrib_n->interleave_dsc->num_interleave;cnt++)
  {
    sum += attrib_n->interleave_dsc->interleave_tbl[cnt].interleave_len;
  }

  if (sum==0)
  {
    if ((attrib_m->interleave_dsc == NULL)
        || (attrib_m->interleave_dsc->num_interleave == 0)
        || (attrib_m->interleave_dsc->interleave_tbl == NULL))
    {
      return TRUE;
    }

    sum = 0;
    for (cnt=0;cnt < attrib_m->interleave_dsc->num_interleave;cnt++)
    {
      sum += attrib_m->interleave_dsc->interleave_tbl[cnt].interleave_len;
    }

    return (sum==0)? TRUE : FALSE;
  }



  if ((attrib_m->interleave_dsc == NULL)
      || (attrib_m->interleave_dsc->num_interleave
          != attrib_n->interleave_dsc->num_interleave)
      || (attrib_m->interleave_dsc->interleave_tbl == NULL))
  {
    return FALSE;
  }


  for (cnt=0;cnt < attrib_n->interleave_dsc->num_interleave;cnt++)
  {
    if ((attrib_m->interleave_dsc->interleave_tbl[cnt].interleave_id
         != attrib_n->interleave_dsc->interleave_tbl[cnt].interleave_id)
        || (attrib_m->interleave_dsc->interleave_tbl[cnt].interleave_len
            != attrib_n->interleave_dsc->interleave_tbl[cnt].interleave_len))
    {
      return FALSE;
    }
  }


  return TRUE;
}


/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_copy_pcm_attrib

DESCRIPTION
  Copy all PCM attribute content from one to another except chan_id
  If copy failed, destination content would not be polluted.

DEPENDENCIES
  None

RETURN VALUE
  qdsp_cmd_status_type

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_copy_pcm_attrib(
  qdsp_cmd_pcm_interface_attrib_type *dst,
  const qdsp_cmd_pcm_interface_attrib_type *src,
  boolean overwrite
)
{
  int cnt;


  if (src==NULL || dst==NULL)
  {
    return QDSP_CMD_FAILED;
  }


  if ((src->interleave_dsc != NULL)
      && (src->interleave_dsc->num_interleave > 0)
      && (src->interleave_dsc->interleave_tbl != NULL))
  {
    if ((dst->interleave_dsc == NULL)
        || (dst->interleave_dsc->interleave_tbl == NULL))
    {
      return QDSP_CMD_FAILED;
    }

    if (overwrite==FALSE)
    {
      return QDSP_CMD_SUCCESS;
    }

    dst->interleave_dsc->num_interleave = src->interleave_dsc->num_interleave;

    for (cnt=0;cnt < src->interleave_dsc->num_interleave;cnt++)
    {
      memcpy((byte*)(dst->interleave_dsc->interleave_tbl + cnt),
             (byte*)(src->interleave_dsc->interleave_tbl + cnt),
             sizeof(qdsp_cmd_pcm_interleave_attrib_type));
    }
  }
  else
  {
    if (overwrite==FALSE)
    {
      return QDSP_CMD_SUCCESS;
    }

    if (dst->interleave_dsc != NULL)
    {
      dst->interleave_dsc->num_interleave = 0;
    }
  }


  dst->intf_dsc.sample_rate = src->intf_dsc.sample_rate;
  dst->intf_dsc.frame_len = src->intf_dsc.frame_len;

  return QDSP_CMD_SUCCESS;
}


/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_init_pcm_current_attribs

DESCRIPTION
  Initialize PCM attributes whenever codec configuration is issued.

DEPENDENCIES
  None

RETURN VALUE
  qdsp_cmd_status_type

SIDE EFFECTS
  qdsp_pcm_rx_input_current_attrib
  qdsp_pcm_rx_output_current_attrib
  qdsp_pcm_tx_output_current_attrib
  qdsp_pcm_tx_input_current_attrib

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_init_pcm_current_attribs(
	                 qdsp_cmd_pcm_sample_rate_type default_frame_rate)
{
  static qdsp_cmd_pcm_interleave_attrib_type
    qdsp_pcm_rx_output_curr_interleave_attrib[10];
  static qdsp_cmd_pcm_interleave_tbl_type qdsp_pcm_rx_output_curr_interleave_tbl
    = {0, qdsp_pcm_rx_output_curr_interleave_attrib};

  static qdsp_cmd_pcm_interleave_attrib_type
    qdsp_pcm_tx_output_curr_interleave_attrib[10];
  static qdsp_cmd_pcm_interleave_tbl_type qdsp_pcm_tx_output_curr_interleave_tbl
    = {0, qdsp_pcm_tx_output_curr_interleave_attrib};

  static qdsp_cmd_pcm_interleave_attrib_type
    qdsp_pcm_rx_input_curr_interleave_attrib[10];
  static qdsp_cmd_pcm_interleave_tbl_type qdsp_pcm_rx_input_curr_interleave_tbl
    = {0, qdsp_pcm_rx_input_curr_interleave_attrib};

  static qdsp_cmd_pcm_interleave_attrib_type
    qdsp_pcm_tx_input_curr_interleave_attrib[10];
  static qdsp_cmd_pcm_interleave_tbl_type qdsp_pcm_tx_input_curr_interleave_tbl
    = {0, qdsp_pcm_tx_input_curr_interleave_attrib};

  const qdsp_cmd_pcm_interface_attrib_type *rxout_default_attrib=NULL;
  const qdsp_cmd_pcm_interface_attrib_type *txout_default_attrib=NULL;
  const qdsp_cmd_pcm_interface_attrib_type *rxin_default_attrib=NULL;
  const qdsp_cmd_pcm_interface_attrib_type *txin_default_attrib=NULL;


  INTLOCK();     /* to prevent race condition from PCM isr */

  qdsp_pcm_rx_output_current_attrib.interleave_dsc
    = &qdsp_pcm_rx_output_curr_interleave_tbl;
  qdsp_pcm_tx_output_current_attrib.interleave_dsc
    = &qdsp_pcm_tx_output_curr_interleave_tbl;
  qdsp_pcm_rx_input_current_attrib.interleave_dsc
    = &qdsp_pcm_rx_input_curr_interleave_tbl;
  qdsp_pcm_tx_input_current_attrib.interleave_dsc
    = &qdsp_pcm_tx_input_curr_interleave_tbl;


  rxout_default_attrib = &qdsp_cmd_pcm_nb_mono_attrib;
  rxin_default_attrib = &qdsp_cmd_pcm_nb_mono_attrib;
  txout_default_attrib = &qdsp_cmd_pcm_nb_mono_attrib;
  txin_default_attrib = &qdsp_cmd_pcm_nb_mono_attrib;

#ifdef QDSP_pcmat8khzEnable
  if ((uint32*)QDSP_pcmat8khzEnable != QDSP_NOP_ADDRESS)
  {
     switch(default_frame_rate)
     {
       /* Default frame rate is chosen based on device and image
       * selection. Device takes priority on the rate for dsp
       */
       case QDSP_CMD_PCM_SAMPLE_RATE_8000 :
         qdsp_write(QDSP_pcmat8khzEnable, 0xffff);
         break;
       case QDSP_CMD_PCM_SAMPLE_RATE_16000 :
         qdsp_write(QDSP_pcmat8khzEnable, 0x0000);
         break;
    }
    if (qdsp_read(QDSP_pcmat8khzEnable) == 0)
    {
      rxout_default_attrib = &qdsp_cmd_pcm_wb_mono_attrib;
      rxin_default_attrib = &qdsp_cmd_pcm_wb_mono_attrib;
      txout_default_attrib = &qdsp_cmd_pcm_wb_mono_attrib;
      txin_default_attrib = &qdsp_cmd_pcm_wb_mono_attrib;
    }
  }
#endif  /* QDSP_pcmat8khzEnable */

#ifdef FEATURE_AVS_CRYSTAL_SPEECH
  if (qdsp_cmd_get_ec_gen_id() == QDSP_CMD_EC_GEN_CRYSTAL_SPEECH)
  {
    txout_default_attrib
    = (txout_default_attrib == &qdsp_cmd_pcm_nb_mono_attrib)?
      &qdsp_cmd_pcm_nb_stereo_attrib : &qdsp_cmd_pcm_wb_stereo_attrib;

    txin_default_attrib
    = (txin_default_attrib == &qdsp_cmd_pcm_nb_mono_attrib)?
      &qdsp_cmd_pcm_nb_stereo_attrib : &qdsp_cmd_pcm_wb_stereo_attrib;
  }
#endif


  qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_rx_output_current_attrib,
                           rxout_default_attrib, TRUE);
  qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_tx_output_current_attrib,
                           txout_default_attrib, TRUE);
  qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_rx_input_current_attrib,
                           rxin_default_attrib, TRUE);
  qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_tx_input_current_attrib,
                           txin_default_attrib, TRUE);

  qdsp_pcm_rx_output_current_attrib.intf_dsc.chan_id
    = QDSP_PCM_INTERFACE_RX_OUTPUT;
  qdsp_pcm_tx_output_current_attrib.intf_dsc.chan_id
    = QDSP_PCM_INTERFACE_TX_OUTPUT;
  qdsp_pcm_rx_input_current_attrib.intf_dsc.chan_id
    = QDSP_PCM_INTERFACE_RX_INPUT;
  qdsp_pcm_tx_input_current_attrib.intf_dsc.chan_id
    = QDSP_PCM_INTERFACE_TX_INPUT;

  INTFREE();


  return QDSP_CMD_SUCCESS;
}


/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_pcm_attrib_supported

DESCRIPTION
  Check if the current image supports requested PCM attribute.  Only
vocoder images are valid at present.

DEPENDENCIES
  None

RETURN VALUE
  TRUE or FALSE

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_pcm_attrib_supported(
  const qdsp_cmd_pcm_interface_attrib_type *attrib
)
{
  if (attrib==NULL)
  {
    return FALSE;
  }


  /* interleave table not checked */

  if (attrib->intf_dsc.sample_rate == 8000)
  {
    if (attrib->intf_dsc.frame_len != 320)
    {
      return FALSE;
    }

    if ((attrib->interleave_dsc != NULL)
        && (attrib->interleave_dsc->num_interleave > 1)
        && (attrib->interleave_dsc->interleave_tbl != NULL))
    {
      return FALSE;
    }

#ifdef FEATURE_AVS_CRYSTAL_SPEECH
    if (qdsp_cmd_get_ec_gen_id() == QDSP_CMD_EC_GEN_CRYSTAL_SPEECH)
    {
      if ((attrib->intf_dsc.chan_id == QDSP_PCM_INTERFACE_TX_OUTPUT)
          || (attrib->intf_dsc.chan_id == QDSP_PCM_INTERFACE_TX_INPUT))
      {
        return FALSE;
      }
    }
#endif  /* FEATURE_AVS_CRYSTAL_SPEECH */

    return TRUE;
  }


  if (attrib->intf_dsc.sample_rate == 16000)
  {
    if (attrib->intf_dsc.frame_len != 640)
    {
      return FALSE;
    }

#ifdef FEATURE_AVS_CRYSTAL_SPEECH
    if (qdsp_cmd_get_ec_gen_id() == QDSP_CMD_EC_GEN_CRYSTAL_SPEECH)
    {
      if ((attrib->intf_dsc.chan_id == QDSP_PCM_INTERFACE_TX_OUTPUT)
          || (attrib->intf_dsc.chan_id == QDSP_PCM_INTERFACE_TX_INPUT))
      {
        if ((attrib->interleave_dsc == NULL)
            || (attrib->interleave_dsc->num_interleave != 2)
            || (attrib->interleave_dsc->interleave_tbl == NULL))
        {
          return FALSE;
        }

        return TRUE;
      }
    }
#endif  /* FEATURE_AVS_CRYSTAL_SPEECH */

#ifdef QDSP_pcmat8khzEnable
    if ((uint32*)QDSP_pcmat8khzEnable != QDSP_NOP_ADDRESS)
    {
      if ((attrib->interleave_dsc == NULL)
          || (attrib->interleave_dsc->num_interleave <= 1)
          || (attrib->interleave_dsc->interleave_tbl == NULL))
      {
        return TRUE;
      }
    }
#endif

    return FALSE;
  }


  if (attrib->intf_dsc.sample_rate == 32000)
  {
    if (attrib->intf_dsc.frame_len != 1024)
    {
      return FALSE;
    }

#ifdef FEATURE_AVS_CRYSTAL_SPEECH
    if (qdsp_cmd_get_ec_gen_id() == QDSP_CMD_EC_GEN_CRYSTAL_SPEECH)
    {
      if ((attrib->intf_dsc.chan_id == QDSP_PCM_INTERFACE_TX_OUTPUT)
          || (attrib->intf_dsc.chan_id == QDSP_PCM_INTERFACE_TX_INPUT))
      {
        if ((attrib->interleave_dsc != NULL)
            && (attrib->interleave_dsc->num_interleave == 2)
            && (attrib->interleave_dsc->interleave_tbl != NULL))
        {
#ifdef QDSP_pcmat8khzEnable
          if ((uint32*)QDSP_pcmat8khzEnable != QDSP_NOP_ADDRESS)
          {
            return TRUE;
          }
#endif  /* QDSP_pcmat8khzEnable */
        }
      }
    }
#endif  /* FEATURE_AVS_CRYSTAL_SPEECH */

    return FALSE;
  }


  return FALSE;
}


/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_config_pcm_attrib

DESCRIPTION
  Configure a particular PCM attribute and update impacted interface modes.
This function cannot be used to enable or disable a particular tap point.
De-registering an attribute is for record purposes only, it unlocks the
corresponding active tapping point to allow activating other pending attributes.
NULL attribute will reset internal record of active tapping points.

DEPENDENCIES
  None

RETURN VALUE
  SUCCESS or FAILURE

SIDE EFFECTS
  qdsp_pcm_rx_input_current_attrib
  qdsp_pcm_rx_output_current_attrib
  qdsp_pcm_tx_output_current_attrib
  qdsp_pcm_tx_input_current_attrib

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_config_pcm_attrib(
  qdsp_cmd_pcm_interface_attrib_type *attrib,
  boolean register_op
)
{
  static uint32 active_taps = 0;
  uint32 check_taps = 0xffffffff;
  qdsp_cmd_pcm_interface_attrib_type *current_attrib = NULL;


  if (attrib==NULL)
  {
    active_taps = 0;
    return QDSP_CMD_SUCCESS;
  }


  switch (attrib->intf_dsc.chan_id)
  {
    case QDSP_PCM_INTERFACE_RX_OUTPUT:
      current_attrib = &qdsp_pcm_rx_output_current_attrib;
      check_taps = ~((uint32)1 << QDSP_PCM_INTERFACE_RX_OUTPUT);
      break;

    case QDSP_PCM_INTERFACE_TX_OUTPUT:
      current_attrib = &qdsp_pcm_tx_output_current_attrib;
      check_taps = ~((uint32)1 << QDSP_PCM_INTERFACE_TX_OUTPUT);
      break;

    case QDSP_PCM_INTERFACE_RX_INPUT:
      current_attrib = &qdsp_pcm_rx_input_current_attrib;
      check_taps = ~((uint32)1 << QDSP_PCM_INTERFACE_RX_INPUT);
      break;

    case QDSP_PCM_INTERFACE_TX_INPUT:
      current_attrib = &qdsp_pcm_tx_input_current_attrib;
      check_taps = ~((uint32)1 << QDSP_PCM_INTERFACE_TX_INPUT);
      break;

    default:
      current_attrib = &qdsp_pcm_rx_output_current_attrib;
      break;
  }


  if (register_op==FALSE)
  {
    active_taps &= check_taps;
    return QDSP_CMD_SUCCESS;
  }


  if (qdsp_cmd_pcm_attrib_supported(attrib) == FALSE)
  {
    return QDSP_CMD_FAILED;
  }


  if (qdsp_cmd_compare_pcm_attrib(attrib, current_attrib) == TRUE)
  {
    active_taps |= ~check_taps;
    return QDSP_CMD_SUCCESS;
  }


  if ((active_taps & check_taps) != 0)
  {
    return QDSP_CMD_FAILED;
  }


  /* check if copying could fail */
  if (qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_rx_output_current_attrib, attrib,
                               FALSE)
      != QDSP_CMD_SUCCESS)
  {
    return QDSP_CMD_FAILED;
  }

  if (qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_tx_output_current_attrib, attrib,
                               FALSE)
      != QDSP_CMD_SUCCESS)
  {
    return QDSP_CMD_FAILED;
  }

  if (qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_rx_input_current_attrib, attrib,
                               FALSE)
      != QDSP_CMD_SUCCESS)
  {
    return QDSP_CMD_FAILED;
  }

  if (qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_tx_input_current_attrib, attrib,
                               FALSE)
      != QDSP_CMD_SUCCESS)
  {
    return QDSP_CMD_FAILED;
  }


  /* Changing PCM attribute */
#ifdef QDSP_pcmat8khzEnable
  if ((uint32*)QDSP_pcmat8khzEnable != QDSP_NOP_ADDRESS)
  {
    if ((attrib->intf_dsc.sample_rate == 16000)
        && ((attrib->interleave_dsc == NULL)
            || (attrib->interleave_dsc->num_interleave <= 1)
            || (attrib->interleave_dsc->interleave_tbl == NULL))
       )
    {
      qdsp_write(QDSP_pcmat8khzEnable, 0x0000);
    }
    else if (attrib->intf_dsc.sample_rate == 32000)
         {
           qdsp_write(QDSP_pcmat8khzEnable, 0x0000);
         }
         else
         {
           qdsp_write(QDSP_pcmat8khzEnable, 0xffff);
         }
  }
#endif


  /* Update current attributes record */
  qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_rx_output_current_attrib, attrib, TRUE);
  qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_tx_output_current_attrib, attrib, TRUE);
  qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_rx_input_current_attrib, attrib, TRUE);
  qdsp_cmd_copy_pcm_attrib(&qdsp_pcm_tx_input_current_attrib, attrib, TRUE);


  /* Lock active tap point */
  active_taps |= ~check_taps;


  return QDSP_CMD_SUCCESS;
}


/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_update_pcm_attribs

DESCRIPTION
  Configure PCM interface attributes

DEPENDENCIES
  Called in atom execution to prevent attribute out of sync. with PCM samples.

LIMITATION
  If this interface is requesting attribute change, it could pre-empt
PCM interrupt causing new attribute out-of-sync with old/current PCM samples
until new PCM samples with new attributes are available.  No fix for this
at present.  One way is to setup static signal of when attribute change is
invoked, when PCM interrupt sees the signal set, it always drops the first
PCM frame.  This is assuming that DSP takes max. 1 frame to change attribute.
Another possibility is to DSP providing attribute along with PCM data.
  The same problem could happen if attribute change is originated from
PCM isr and it takes >=1 frame for PCM samples with new attribute to arrive.
  More complexities when pending attribute keeps toggling between NULL and
new attribute.  Requests for default attributes should be served without
interruption to PCM samples availability, same as no attribute change.

RETURN VALUE
  mode bit set to 1: PCM interface busy, requested attrib cannot be served
                   : default attrib provided.
  mode bit set to 0: requested attrib available.

SIDE EFFECTS
  qdsp_pcm_rx_input_attrib
  qdsp_pcm_rx_output_attrib
  qdsp_pcm_tx_output_attrib
  qdsp_pcm_tx_input_attrib

===========================================================================*/
uint32 qdsp_cmd_update_pcm_attribs(void)
{
  uint32 attrib_busy=0;


  if (qdsp_cmd_pcm_rx_output_enabled == 0)
  {
    qdsp_cmd_config_pcm_attrib(&qdsp_pcm_rx_output_current_attrib, FALSE);
    qdsp_pcm_rx_output_attrib = NULL;
  }
  else
  {
    if (qdsp_pcm_rx_output_pending_attrib == NULL)
    {
      qdsp_cmd_config_pcm_attrib(&qdsp_pcm_rx_output_current_attrib, FALSE);
    }
    else
    {
      if (qdsp_cmd_config_pcm_attrib(qdsp_pcm_rx_output_pending_attrib, TRUE)
          != QDSP_CMD_SUCCESS)
      {
        attrib_busy |= (1 << QDSP_PCM_INTERFACE_RX_OUTPUT);
      }
    }

    qdsp_pcm_rx_output_attrib = &qdsp_pcm_rx_output_current_attrib;
  }


  if (qdsp_cmd_pcm_tx_output_enabled == 0)
  {
    qdsp_cmd_config_pcm_attrib(&qdsp_pcm_tx_output_current_attrib, FALSE);
    qdsp_pcm_tx_output_attrib = NULL;
  }
  else
  {
    if (qdsp_pcm_tx_output_pending_attrib == NULL)
    {
      qdsp_cmd_config_pcm_attrib(&qdsp_pcm_tx_output_current_attrib, FALSE);
    }
    else
    {
      if (qdsp_cmd_config_pcm_attrib(qdsp_pcm_tx_output_pending_attrib, TRUE)
          != QDSP_CMD_SUCCESS)
      {
        attrib_busy |= (1 << QDSP_PCM_INTERFACE_TX_OUTPUT);
      }
    }

    qdsp_pcm_tx_output_attrib = &qdsp_pcm_tx_output_current_attrib;
  }


  if (qdsp_cmd_pcm_rx_input_enabled == 0)
  {
    qdsp_cmd_config_pcm_attrib(&qdsp_pcm_rx_input_current_attrib, FALSE);
    qdsp_pcm_rx_input_attrib = NULL;
  }
  else
  {
    if (qdsp_pcm_rx_input_pending_attrib == NULL)
    {
      qdsp_cmd_config_pcm_attrib(&qdsp_pcm_rx_input_current_attrib, FALSE);
    }
    else
    {
      if (qdsp_cmd_config_pcm_attrib(qdsp_pcm_rx_input_pending_attrib, TRUE)
          != QDSP_CMD_SUCCESS)
      {
        attrib_busy |= (1 << QDSP_PCM_INTERFACE_RX_INPUT);
      }
    }

    qdsp_pcm_rx_input_attrib = &qdsp_pcm_rx_input_current_attrib;
  }


  if (qdsp_cmd_pcm_tx_input_enabled == 0)
  {
    qdsp_cmd_config_pcm_attrib(&qdsp_pcm_tx_input_current_attrib, FALSE);
    qdsp_pcm_tx_input_attrib = NULL;
  }
  else
  {
    if (qdsp_pcm_tx_input_pending_attrib == NULL)
    {
      qdsp_cmd_config_pcm_attrib(&qdsp_pcm_tx_input_current_attrib, FALSE);
    }
    else
    {
      if (qdsp_cmd_config_pcm_attrib(qdsp_pcm_tx_input_pending_attrib, TRUE)
          != QDSP_CMD_SUCCESS)
      {
        attrib_busy |= (1 << QDSP_PCM_INTERFACE_TX_INPUT);
      }
    }

    qdsp_pcm_tx_input_attrib = &qdsp_pcm_tx_input_current_attrib;
  }


  return attrib_busy;
}


/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_set_pcm_modes

DESCRIPTION
  Sends commands to DSP to enable/disable PCM interfaces.

DEPENDENCIES
  Clients must register a callback for the PCM interfaces enabled (if any).

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_pcm_rx_input_enabled
  qdsp_pcm_rx_output_enabled
  qdsp_pcm_tx_output_enabled
  qdsp_pcm_tx_input_enabled

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_pcm_modes(
  uint32 pending_mode, /* New PCM mode     */
  qdsp_cmd_pcm_client_type pcm_client_id
)
{
  INTLOCK();     /* preventing race condition from isr */

  if (pending_mode & (1 << QDSP_PCM_INTERFACE_RX_OUTPUT))
  {
    qdsp_cmd_pcm_rx_output_enabled |= (1 << pcm_client_id) ;
  }
  else
  {
    qdsp_cmd_pcm_rx_output_enabled &= ~((uint32)1 << pcm_client_id);
  }

  if (pending_mode & (1 << QDSP_PCM_INTERFACE_TX_OUTPUT))
  {
    qdsp_cmd_pcm_tx_output_enabled |= (1 << pcm_client_id) ;
  }
  else
  {
    qdsp_cmd_pcm_tx_output_enabled &= ~((uint32)1 << pcm_client_id);
  }

  if (pending_mode & (1 << QDSP_PCM_INTERFACE_RX_INPUT))
  {
      qdsp_cmd_pcm_rx_input_enabled |= (1 << pcm_client_id) ;
  }
  else
  {
    qdsp_cmd_pcm_rx_input_enabled &= ~((uint32)1 << pcm_client_id);
  }

  if (pending_mode & (1 << QDSP_PCM_INTERFACE_TX_INPUT))
  {
#ifdef FEATURE_AVS_CRYSTAL_SPEECH
    if (qdsp_cmd_get_ec_gen_id() != QDSP_CMD_EC_GEN_CRYSTAL_SPEECH)
#endif
      qdsp_cmd_pcm_tx_input_enabled |= (1 << pcm_client_id) ;
  }
  else
  {
    qdsp_cmd_pcm_tx_input_enabled &= ~((uint32)1 << pcm_client_id);
  }

  /* configure PCM attributes before activating PCM interface */
  qdsp_cmd_update_pcm_attribs();

  INTFREE();

  if (qdsp_cmd_pcm_rx_output_enabled != 0)
  {
    qdsp_write(QDSP_rxPcmRdEnable, QDSP_CMD_ENABLE_VOC_PCM_INT_V);
  }
  else
  {
    qdsp_write(QDSP_rxPcmRdEnable, QDSP_CMD_DISABLE_VOC_PCM_INT_V);
  }

  if (qdsp_cmd_pcm_tx_output_enabled != 0)
  {
    qdsp_write(QDSP_txPcmRdEnable, QDSP_CMD_ENABLE_VOC_PCM_INT_V);
  }
  else
  {
    qdsp_write(QDSP_txPcmRdEnable, QDSP_CMD_DISABLE_VOC_PCM_INT_V);
  }

  if (qdsp_cmd_pcm_rx_input_enabled != 0)
  {
    qdsp_write(QDSP_rxPcmWrEnable, QDSP_CMD_ENABLE_VOC_PCM_INT_V);
  }
  else
  {
    qdsp_write(QDSP_rxPcmWrEnable, QDSP_CMD_DISABLE_VOC_PCM_INT_V);
  }

  if (qdsp_cmd_pcm_tx_input_enabled != 0)
  {
    qdsp_write(QDSP_txPcmWrEnable, QDSP_CMD_ENABLE_VOC_PCM_INT_V);
  }
  else
  {
    qdsp_write(QDSP_txPcmWrEnable, QDSP_CMD_DISABLE_VOC_PCM_INT_V);
  }


  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
/*===========================================================================

INTERNAL FUNCTION qdsp_cmd_process_pcm_data

DESCRIPTION
  ISR to process Vocoder PCM data.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void qdsp_cmd_process_pcm_data(void)
{
#ifdef FEATURE_PCM_PKT_LOG
  LOG_TX_PCM_PACKET_C_type *pcm_pkt_tx_log_ptr;
  LOG_RX_PCM_PACKET_C_type *pcm_pkt_rx_log_ptr;

  static uint32 pcm_log_status = 0 ;
#endif /*FEATURE_PCM_PKT_LOG*/

#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */

#ifdef FEATURE_PCM_PKT_LOG
  if (log_status(LOG_TX_PCM_PACKET_C)&&(!(pcm_log_status &
                                    (1 << QDSP_PCM_INTERFACE_TX_OUTPUT))))  {
    pcm_log_status |= (1 << QDSP_PCM_INTERFACE_TX_OUTPUT) ;
  }
  else if (!(log_status(LOG_TX_PCM_PACKET_C))&&((pcm_log_status &
                                     (1 << QDSP_PCM_INTERFACE_TX_OUTPUT))))  {
    pcm_log_status &= ~(1 << QDSP_PCM_INTERFACE_TX_OUTPUT);
  }

  if (log_status(LOG_RX_PCM_PACKET_C)&&(!(pcm_log_status &
                                     (1 << QDSP_PCM_INTERFACE_RX_OUTPUT))))  {
    pcm_log_status |= (1 << QDSP_PCM_INTERFACE_RX_OUTPUT) ;
  }
  else if (!(log_status(LOG_RX_PCM_PACKET_C))&&((pcm_log_status &
                                    (1 << QDSP_PCM_INTERFACE_RX_OUTPUT))))   {
    pcm_log_status &= ~(1 << QDSP_PCM_INTERFACE_RX_OUTPUT);
  }

  qdsp_cmd_set_pcm_modes(pcm_log_status,QDSP_CMD_PCM_CLIENT_LOG);
#endif /*FEATURE_PCM_PKT_LOG*/

  /* RX PCM Input */
  if (qdsp_cmd_pcm_rx_input_enabled && qdsp_read(QDSP_rxPcmWrReg)) {

#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */
    /* Data is available; Get it from the Client */
    if(qdsp_pcm_rx_input_func != NULL) {
      if (qdsp_pcm_rx_input_func(qdsp_cmd_pcm_data_buffer,
                                 qdsp_pcm_rx_input_attrib)
          == QDSP_PCM_DATA_STATUS_AVAILABLE) {

        /* Pass it to the DSP */
        qdsp_block_write(QDSP_rxPcmWrBuf, 0, qdsp_cmd_pcm_data_buffer,
           (qdsp_pcm_rx_input_attrib->intf_dsc.frame_len >> 1), FALSE);
      }
    }
    qdsp_write(QDSP_rxPcmWrReg, 0);
    /* else the client does not have a packet to write */
  }

  /* TX PCM Input */
  if (qdsp_cmd_pcm_tx_input_enabled && qdsp_read(QDSP_txPcmWrReg)) {
#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */
    /* Data is available; Get it from the Client */
    if (qdsp_pcm_tx_input_func != NULL) {
      if (qdsp_pcm_tx_input_func(qdsp_cmd_pcm_data_buffer,
                                 qdsp_pcm_tx_input_attrib)
          == QDSP_PCM_DATA_STATUS_AVAILABLE) {

        /* Pass it to the DSP */
        qdsp_block_write(QDSP_txPcmWrBuf, 0, qdsp_cmd_pcm_data_buffer,
          (qdsp_pcm_tx_input_attrib->intf_dsc.frame_len >> 1), FALSE);
      }
    }
    qdsp_write(QDSP_txPcmWrReg, 0);
    /* else the client does not have a packet to write */
  }

  /* TX PCM Output */
  if (qdsp_cmd_pcm_tx_output_enabled && qdsp_read(QDSP_txPcmRdReg)) {
    /* Data is available; Get it from the DSP */
    qdsp_block_read(QDSP_txPcmRdBuf, 0, qdsp_cmd_pcm_data_buffer,
      (qdsp_pcm_tx_output_attrib->intf_dsc.frame_len >> 1), FALSE);

#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */

#ifdef FEATURE_PCM_PKT_LOG
    pcm_pkt_tx_log_ptr
    = (LOG_TX_PCM_PACKET_C_type *) log_alloc(LOG_TX_PCM_PACKET_C, \
                sizeof(LOG_TX_PCM_PACKET_C_type) - 1
                + (qdsp_pcm_tx_output_attrib->intf_dsc.frame_len));

    if (pcm_pkt_tx_log_ptr!=NULL) {
      pcm_pkt_tx_log_ptr->length
      = qdsp_pcm_tx_output_attrib->intf_dsc.frame_len;
      memcpy((byte*)(pcm_pkt_tx_log_ptr->tx_pkt),
             (byte*)qdsp_cmd_pcm_data_buffer, pcm_pkt_tx_log_ptr->length);
      log_commit(pcm_pkt_tx_log_ptr);
    }
#endif /*FEATURE_PCM_PKT_LOG*/

    if (qdsp_pcm_tx_output_func != NULL) {
      /* Pass it to the Client */
      qdsp_pcm_tx_output_func(qdsp_cmd_pcm_data_buffer,
                              qdsp_pcm_tx_output_attrib);
    }
    qdsp_write(QDSP_txPcmRdReg, 0);
  }

  /* RX PCM Output */
  if (qdsp_cmd_pcm_rx_output_enabled && qdsp_read(QDSP_rxPcmRdReg)) {
    /* Data is available; Get it from the DSP */
    qdsp_block_read(QDSP_rxPcmRdBuf, 0, qdsp_cmd_pcm_data_buffer,
      (qdsp_pcm_rx_output_attrib->intf_dsc.frame_len >> 1), FALSE);
#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */

#ifdef FEATURE_PCM_PKT_LOG
    pcm_pkt_rx_log_ptr
    = (LOG_RX_PCM_PACKET_C_type *) log_alloc(LOG_RX_PCM_PACKET_C, \
                sizeof(LOG_RX_PCM_PACKET_C_type) - 1
                + (qdsp_pcm_rx_output_attrib->intf_dsc.frame_len));

    if (pcm_pkt_rx_log_ptr!=NULL) {
      pcm_pkt_rx_log_ptr->length
      = qdsp_pcm_rx_output_attrib->intf_dsc.frame_len;
      memcpy((byte*)(pcm_pkt_rx_log_ptr->rx_pkt),
             (byte*)qdsp_cmd_pcm_data_buffer, pcm_pkt_rx_log_ptr->length);
      log_commit(pcm_pkt_rx_log_ptr);
    }
#endif /*FEATURE_PCM_PKT_LOG*/

    if (qdsp_pcm_rx_output_func != NULL) {
      /* Pass it to the Client */
      qdsp_pcm_rx_output_func(qdsp_cmd_pcm_data_buffer,
                              qdsp_pcm_rx_output_attrib);
    }
    qdsp_write(QDSP_rxPcmRdReg, 0);
  }

#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */

  /* check if there are any attributes change */
  qdsp_cmd_update_pcm_attribs();
}
#endif /* FEATURE_VOC_PCM_INTERFACE */

#ifdef FEATURE_QDJ_TIMEWARP
/* <EJECT> */
/*===========================================================================

FUNCTION
  qdsp_cmd_set_timewarp

DESCRIPTION
  This function will record the timewarp factor for the current frame.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_set_timewarp(
  boolean  enable,
  uint16   factor
) {
  qdsp_cmd_time_warp_enabled = enable;
  qdsp_cmd_time_warp_factor = factor;
}

#ifdef MSMAUD_VOC_4GV_VOIP
#error code not present
#endif /* MSMAUD_VOC_4GV_VOIP */

/* <EJECT> */
#ifdef MSMAUD_VOC_4GV_WB_VOIP
/*===========================================================================

FUNCTION
  qdsp_cmd_set_4gv_wb_timewarp

DESCRIPTION
  This function will record the timewarp phase factors for the current frame.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_set_4gv_wb_timewarp(
  boolean  enable,
  uint16   run_length,
  uint16   phase_offset
) {
  qdsp_cmd_4gv_wb_time_warp_parm.phase_match_enable = enable;
  qdsp_cmd_4gv_wb_time_warp_parm.run_length = run_length;
  qdsp_cmd_4gv_wb_time_warp_parm.phase_offset = phase_offset;
}
#endif /* MSMAUD_VOC_4GV_WB_VOIP */

/* <EJECT> */
/*===========================================================================

FUNCTION
  qdsp_cmd_timewarp

DESCRIPTION
  This function programs the timewarp factor to the DSP.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_timewarp()
{
#if defined(QDSP_IMAGE_VOC_EVRC_DEFINED)            || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED)           || \
    defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED)      || \
    defined(QDSP_IMAGE_4GV_DEFINED)                 || \
    defined(QDSP_IMAGE_4GV_WB_DEFINED)              || \
    defined(QDSP_IMAGE_4GV_WB_VOIP_DEFINED)         || \
    defined(QDSP_IMAGE_4GV_VOIP_DEFINED)
  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_VOC_EVRC_DEFINED)
    case QDSP_IMAGE_VOC_EVRC:
#endif /* defined(QDSP_IMAGE_VOC_EVRC_DEFINED) */
#if defined(QDSP_IMAGE_VOC_COMBO_DEFINED)
    case QDSP_IMAGE_VOC_COMBO:
#endif /* defined(QDSP_IMAGE_VOC_COMBO_DEFINED) */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#if defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED)
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif /* defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED) */
#if defined(QDSP_IMAGE_4GV_DEFINED)
    case QDSP_IMAGE_4GV:
#endif /* defined(QDSP_IMAGE_4GV_DEFINED) */
#if defined(QDSP_IMAGE_4GV_WB_DEFINED)
    case QDSP_IMAGE_4GV_WB:
#endif /* defined(QDSP_IMAGE_4GV_WB_DEFINED) */
#if defined(QDSP_IMAGE_4GV_VOIP_DEFINED)
    case QDSP_IMAGE_4GV_VOIP:
#endif /* defined(QDSP_IMAGE_4GV_VOIP_DEFINED) */
#if defined(QDSP_IMAGE_4GV_WB_VOIP_DEFINED)
    case QDSP_IMAGE_4GV_WB_VOIP:
#endif /* defined(QDSP_IMAGE_4GV_WB_VOIP_DEFINED) */
      if (qdsp_cmd_time_warp_enabled == TRUE)
      {
        qdsp_write(QDSP_rxTimeWarpEnable, 0xffff);

        /* write the warp factor to the DSP */
        qdsp_write(QDSP_rxTimeWarpExpLen, qdsp_cmd_time_warp_factor );
      } else {
        /* Disable timewarping */
        qdsp_write(QDSP_rxTimeWarpEnable, 0x0);
      }
      break;
    default:
      break;
  }
#endif /* defined(QDSP_IMAGE_VOC_EVRC_DEFINED)        ||
          defined(QDSP_IMAGE_VOC_COMBO_DEFINED)       ||
          defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED)  ||
          defined(QDSP_IMAGE_4GV_DEFINED)             ||
          defined(QDSP_IMAGE_4GV_VOIP_DEFINED)         ||
          defined(QDSP_IMAGE_4GV_WB_DEFINED)           ||
          defined(QDSP_IMAGE_4GV_WB_VOIP_DEFINED)
        */
#ifdef MSMAUD_VOC_4GV_VOIP
#error code not present
#endif /* MSMAUD_VOC_4GV_VOIP */

#ifdef MSMAUD_VOC_4GV_WB_VOIP
  if((qdsp_voc_mode == QDSP_VOC_MODE_4GV_WB_VOIP_V) &&
      qdsp_cmd_time_warp_enabled == TRUE) {
    qdsp_write(QDSP_rxPhaseMatchEnable,
               qdsp_cmd_4gv_wb_time_warp_parm.phase_match_enable);
    qdsp_write(QDSP_rxRunLength, qdsp_cmd_4gv_wb_time_warp_parm.run_length);
    qdsp_write(QDSP_rxPhaseOffset, qdsp_cmd_4gv_wb_time_warp_parm.phase_offset);
    MSG_LOW("Timewarp output: %d",qdsp_read(QDSP_rxTimeWarpOutLen),0,0);
  }
#endif /* MSMAUD_VOC_4GV_WB_VOIP */
}
#endif /* FEATURE_QDJ_TIMEWARP */
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_RX_FRAME

DESCRIPTION
  This function saves a frame of OTA data along with the frame information,
  those data and information will be used at the next QDSP2 decoder interrupt.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was completed.

SIDE EFFECTS
  qdsp_cmd_rx_packet contains the decoder frame.
  Update qdsp_cmd_dec_frame_rate, qdsp_cmd_dec_packet_length.
  Set qdsp_cmd_dec_semaphore_flag.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_rx_frame (
  uint8 frame_rate,     /* vocoder frame rate                      */
  uint8 *data_ptr            /* pointer to vocoder packet data          */
)
{
  word  packet_length;          /* length of packet                        */
  qdsp_cmd_status_type  ret_val;     /* return status of packet exchange    */

  byte qrate_cnt;  /* quarter rate variables */
  byte i;

  /* Diagnostic receive frame count */
  qdsp_cmd_rx_frame_count++;

  /* Diagnostic receive frame rate count */
  switch (frame_rate) {
     case QDSP_RATE_EIGHTH_V:
        qdsp_rx_8++;
        break;
     case QDSP_RATE_QUARTER_V:
        qdsp_rx_4++;
        break;
     case QDSP_RATE_HALF_V:
        qdsp_rx_2++;
        break;
     case QDSP_RATE_FULL_V:
        qdsp_rx_1++;
        break;
    case QDSP_RATE_BLANK_V:
        qdsp_rx_0++;
        break;
    case QDSP_RATE_ERASURE_V:
        qdsp_rx_e++;
        break;
     default:
        break;
  }

#ifdef FEATURE_VOC_PACKET_INTERFACE
  if (qdsp_cmd_fl_packet_func != NULL) {
    /* Accept the frame only if the packet interface is not in use */
    return QDSP_CMD_SUCCESS;
  }
#endif /* FEATURE_VOC_PACKET_INTERFACE */

  /* make sure we have a valid frame rate.  Otherwise, force to an    */
  /* erasure.                                                         */
  if ((frame_rate <= QDSP_RATE_FULL_V)  &&
                                        ((frame_rate > QDSP_RATE_BLANK_V) ||
                          (frame_rate == QDSP_RATE_BLANK_V)) )
  {
    /* Determine how much data we want to send for this frame rate    */
    packet_length = QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(frame_rate);
  }
  else
  {               /* not a valid frame rate so force an erasure       */
    frame_rate = QDSP_RATE_ERASURE_V;
    packet_length = 0;
  }

  /* Protect 13k decoder from 1/4 rate frames (map them to ERASURES) */
  if (qdsp_voc_mode == QDSP_VOC_MODE_IS733_V)
  {
    /* VOC_DEBUG_MSG ("    - do 13k 1/4 rate protection. ", 0, 0, 0); */

    qdsp_cmd_rate_array[qdsp_cmd_rate_index++] = frame_rate;

    if (qdsp_cmd_rate_index == 8)
    {
      qdsp_cmd_rate_index = 0;
    }

    if (qdsp_cmd_qrate_enable == FALSE)
    {
      qrate_cnt = 0;

      /* count the number of 1/4 rate frames in the last 8 frames */
      for (i=0;i<8;i++)
      {
        /* count number of 1/4 rate frames in the last 8 */
        if (qdsp_cmd_rate_array[i] == QDSP_RATE_QUARTER_V)
        {
          qrate_cnt += 1;
        }
      }

      /* if 3 out of 8 frames are quarter rate then allow quarter rate for
      ** the duration of the call (if feature is not disabled)
      */
      if (qrate_cnt >= 3)
      {
        qdsp_cmd_qrate_enable = TRUE;
      }
    }

    if ((frame_rate == QDSP_RATE_QUARTER_V) && (!(qdsp_cmd_qrate_enable)
                             || qdsp_cmd_no_qrate))
    {
      /* debug message */
      /* VOC_DEBUG_MSG("1/4 rate packet ERASED",0,0,0); */

      /* recast rate */
      frame_rate = QDSP_RATE_ERASURE_V;
    }

  } /* (qdsp_voc_mode == QDSP_VOC_MODE_IS733_V) - 1/4 rate protect */


  qdsp_cmd_dec_frame_rate = frame_rate;

  qdsp_cmd_dec_packet_length = packet_length;


  /* pass packet data to DSP but first do byte swapping               */
  if (packet_length != 0)
  {
    swap(data_ptr, (byte *)qdsp_cmd_rx_packet, packet_length);
  }

#ifdef FEATURE_VOICE_RECORD

  /* If we are recording forward link or both
  */
  if ((qdsp_cmd_rec_dir == QDSP_CMD_REC_FORWARD) ||
      (qdsp_cmd_rec_dir == QDSP_CMD_REC_BOTH))
  {
    if (packet_length != 0) {
      /* Use correct starting address to copy the frames from.
      */
      memcpy ((uint8 *) qdsp_cmd_temp_packet, data_ptr, packet_length * 2);
    }

    qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_FORWARD, frame_rate, packet_length,
                          qdsp_cmd_temp_packet);

  }

#endif /* FEATURE_VOICE_RECORD */

  qdsp_cmd_dec_semaphore_flag = 1;

  ret_val = QDSP_CMD_SUCCESS;

  return(ret_val);
}

/* <EJECT> */
#ifdef FEATURE_VOC_PACKET_INTERFACE
/*===========================================================================

FUNCTION QDSP_CMD_PROCESS_RX_FRAME

DESCRIPTION
  This function saves a frame of OTA data along with the frame information,
  to the DSP buffers.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
 None

SIDE EFFECTS
  qdsp_cmd_rx_packet contains the decoder frame.
  Update qdsp_cmd_dec_frame_rate, qdsp_cmd_dec_packet_length.

===========================================================================*/
void qdsp_cmd_process_rx_frame (
  uint16 frame_rate,     /* vocoder frame rate                      */
  uint8  *data_ptr       /* pointer to vocoder packet data          */
)
{
  word  packet_length;          /* length of packet                        */
  byte qrate_cnt;  /* quarter rate variables */
  byte i;

  /* Diagnostic receive frame count */
  qdsp_cmd_rx_frame_count++;

  /* Diagnostic receive frame rate count */
  switch (frame_rate) {
     case QDSP_RATE_EIGHTH_V:
        qdsp_rx_8++;
        break;
     case QDSP_RATE_QUARTER_V:
        qdsp_rx_4++;
        break;
     case QDSP_RATE_HALF_V:
        qdsp_rx_2++;
        break;
     case QDSP_RATE_FULL_V:
        qdsp_rx_1++;
        break;
     case QDSP_RATE_BLANK_V:
        qdsp_rx_0++;
        break;
     case QDSP_RATE_ERASURE_V:
        qdsp_rx_e++;
        break;
     default:
        break;
  }
  /* make sure we have a valid frame rate.  Otherwise, force to an    */
  /* erasure.                                                         */
  if ((frame_rate <= QDSP_RATE_FULL_V)  &&
                                        ((frame_rate > QDSP_RATE_BLANK_V) ||
                          (frame_rate == QDSP_RATE_BLANK_V)) )
  {
    /* Determine how much data we want to send for this frame rate    */
    packet_length = QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(frame_rate);
  }
  else
  {               /* not a valid frame rate so force an erasure       */
    frame_rate = QDSP_RATE_ERASURE_V;
    packet_length = 0;
  }

  /* Protect 13k decoder from 1/4 rate frames (map them to ERASURES) */
  if (qdsp_voc_mode == QDSP_VOC_MODE_IS733_V)
  {
    /* VOC_DEBUG_MSG ("    - do 13k 1/4 rate protection. ", 0, 0, 0); */

    qdsp_cmd_rate_array[qdsp_cmd_rate_index++] = frame_rate;

    if (qdsp_cmd_rate_index == 8)
    {
      qdsp_cmd_rate_index = 0;
    }

    if (qdsp_cmd_qrate_enable == FALSE)
    {
      qrate_cnt = 0;

      /* count the number of 1/4 rate frames in the last 8 frames */
      for (i=0;i<8;i++)
      {
        /* count number of 1/4 rate frames in the last 8 */
        if (qdsp_cmd_rate_array[i] == QDSP_RATE_QUARTER_V)
        {
          qrate_cnt += 1;
        }
      }

      /* if 3 out of 8 frames are quarter rate then allow quarter rate for
      ** the duration of the call (if feature is not disabled)
      */
      if (qrate_cnt >= 3)
      {
        qdsp_cmd_qrate_enable = TRUE;
      }
    }

    if ((frame_rate == QDSP_RATE_QUARTER_V) && (!(qdsp_cmd_qrate_enable)
                             || qdsp_cmd_no_qrate))
    {
      /* debug message */
      /* VOC_DEBUG_MSG("1/4 rate packet ERASED",0,0,0); */

      /* recast rate */
      frame_rate = QDSP_RATE_ERASURE_V;
    }

  } /* (qdsp_voc_mode == QDSP_VOC_MODE_IS733_V) - 1/4 rate protect */


  qdsp_cmd_dec_frame_rate = frame_rate;

  qdsp_cmd_dec_packet_length = packet_length;


  /* pass packet data to DSP but first do byte swapping               */
  if (packet_length != 0)
  {
    swap(data_ptr, (byte *)qdsp_cmd_rx_packet, packet_length);
    MSG_MED("qdsp_cmd_dec_packet_length=0x%x",
                                        qdsp_cmd_dec_packet_length, 0, 0);
  }

#ifdef FEATURE_VOICE_RECORD

  /* If we are recording forward link or both
  */
  if ((qdsp_cmd_rec_dir == QDSP_CMD_REC_FORWARD) ||
      (qdsp_cmd_rec_dir == QDSP_CMD_REC_BOTH))
  {
    if (packet_length != 0) {
      /* Use correct starting address to copy the frames from.
      */
      memcpy ((uint8 *) qdsp_cmd_temp_packet, data_ptr, packet_length * 2);
    }

    qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_FORWARD, frame_rate, packet_length,
                          qdsp_cmd_temp_packet);

  }

#endif /* FEATURE_VOICE_RECORD */
}
#endif /* FEATURE_VOC_PACKET_INTERFACE */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_TX_FRAME

DESCRIPTION
  This function gets a frame of OTA data along with the frame information which
  was saved on the previous QDSP2 encoder interrupt, and sets the maximum and
  minimum frame rates for the next QDSP2 encoder frame.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  A value of voc_rate_type indicating whether the command was done.

SIDE EFFECTS
  Clear qdsp_cmd_enc_semaphore_flag.
  Set qdsp_cmd_min_frame_rate.
  Set qdsp_cmd_max_frame_rate.

===========================================================================*/
uint16 qdsp_cmd_tx_frame (
  uint16 max_rate,               /* max vocoder rate                */
  uint16 min_rate,               /* min vocoder rate                */
  uint8  **data_ptr              /* pointer to packet data          */
)
{
  uint16 frame_rate;                    /* frame rate of Tx packet       */
  static byte data_buf[ 34 ];           /* data buffer for data pointer  */
  static byte voc_qdsp2_eighth_rate_null[] = {0xFF, 0xFF, 0xFF};

  /* Diagnostic transmit frame counters */
  qdsp_cmd_tx_frame_count++;

  *data_ptr = data_buf;

  if (
#ifdef FEATURE_VOC_PACKET_INTERFACE
      /* If the packet interface is in use, then give the traditional
      ** interface caller 1/8 NULL frames. This will ensure that the packet
      ** interface operates correctly.
      */
      (qdsp_cmd_rl_packet_func != NULL) ||
#endif /* FEATURE_VOC_PACKET_INTERFACE */
      /* If semaphore flag is 0 then DSP has not set flag yet */
      (qdsp_cmd_enc_semaphore_flag == 0) )
  {
    /* Force frame to 1/8 NULL                 */
    *data_ptr = voc_qdsp2_eighth_rate_null;
    frame_rate = QDSP_RATE_EIGHTH_V;

    /* Diagnostic encoder not ready counters */
    qdsp_cmd_enc_miss_count++;
  }
  else /* if (qdsp_cmd_enc_semaphore != 0) */
  {
    /* Diagnostic encoder ready counters */
    qdsp_cmd_enc_ready_count++;

    frame_rate = qdsp_cmd_enc_frame_rate;

    /* Diagnostic transmit frame rate counters */
    switch (frame_rate) {
      case QDSP_RATE_EIGHTH_V:
        qdsp_tx_8++;
        break;
      case QDSP_RATE_QUARTER_V:
        qdsp_tx_4++;
        break;
      case QDSP_RATE_HALF_V:
        qdsp_tx_2++;
        break;
      case QDSP_RATE_FULL_V:
        qdsp_tx_1++;
        break;
      default:
        break;
    }

    if (qdsp_cmd_enc_packet_length != 0)
    {
      /* swap bytes of source buffer and stick in desitation buffer    */
      swap((byte *)qdsp_cmd_tx_packet, data_buf, qdsp_cmd_enc_packet_length);
    }

    /* Clear flag to indicate that the encoder packet is used
    */
    qdsp_cmd_enc_semaphore_flag = 0;

  } /* end if (qdsp_cmd_enc_semaphore == 0) */

  /* Save the minimum and maximum rate settings - to be set by by the isr
  */
  qdsp_cmd_min_frame_rate = min_rate;
  qdsp_cmd_max_frame_rate = max_rate;

  return( frame_rate );
}

/* <EJECT> */
#if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_EFR)

/*===========================================================================

FUNCTION qdsp_cmd_gsm_tx_packet

DESCRIPTION
  This function gets a frame of data from the GSM vocoders encoder.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  qdsp_cmd_gsm_frame_type: return one of the following values -
    QDSP_GSM_SID         : speech flag = 0, FR or EFR mode
    QDSP_GSM_SPEECH_GOOD : speech flag = 1, FR or EFR mode
    QDSP_AMR_SPEECH_GOOD : AMR mode encoder frame type
    QDSP_AMR_SID_FIRST
    QDSP_AMR_SID_UPDATE
    QDSP_AMR_NO_DATA

  qdsp_cmd_gsm_frame_rate_type: GSM encoder rate information

  qdsp_cmd_status_type: indicate whether the command was completed.

SIDE EFFECTS
  Codec mode for the next packet will be configured if it is in AMR mode.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_gsm_tx_packet
(
  uint16 *data_ptr,                            /* pointer to packet data */
  qdsp_cmd_gsm_frame_type *gsm_frame_type,
  qdsp_cmd_gsm_frame_rate_type *gsm_frame_rate,
  qdsp_cmd_gsm_frame_rate_type amr_next_frame_rate         /* AMR only */
)
{
 if ((data_ptr==NULL) || (gsm_frame_type==NULL) || (gsm_frame_rate==NULL))
 {
  return QDSP_CMD_FAILED;
 }


 if (qdsp_cmd_enc_semaphore_flag == 0)
 {
    /* statistics */
    qdsp_cmd_gsm_enc_miss_cnt++;
                          /* times when encoder packets not available */
 }

 /* Encoder packet ready */
 memcpy((byte*)data_ptr, (byte*)qdsp_cmd_tx_packet,
        (QDSP_CMD_GSM_PACKET_LENGTH << 1));

 *gsm_frame_type = qdsp_cmd_gsm_enc_frame_id;
 *gsm_frame_rate = qdsp_cmd_gsm_enc_frame_rate;

 qdsp_cmd_enc_semaphore_flag = 0;         /* handshaking */

 qdsp_cmd_gsm_voc_enc_pkt_cnt++;          /* statistics */

#ifdef MSMAUD_VOC_AMR
 if (qdsp_voc_mode == QDSP_VOC_MODE_AMR_V)
   if (qdsp_cmd_set_amr_codec_mode(amr_next_frame_rate) != QDSP_CMD_SUCCESS)
   {
    return QDSP_CMD_FAILED;
   }
#endif /* MSMAUD_VOC_AMR */


 return QDSP_CMD_SUCCESS;
}   /* qdsp_cmd_gsm_tx_packet */


/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_gsm_rx_packet

DESCRIPTION
  This function sends a frame of data to the GSM vocoder's decoder.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was completed.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_gsm_rx_packet
(
  uint16 *data_ptr,                       /* pointer to packet data */
  qdsp_cmd_gsm_frame_type gsm_frame_id,   /* packet frame type */
  qdsp_cmd_gsm_frame_rate_type amr_frame_rate,     /* AMR only */
  boolean taf                    /* time alignment flag: not used for AMR */
)
{
 /* Packet Format Verification */
 if (data_ptr==NULL)
 {
    ERR("Decoder data packet empty.", 0, 0, 0);
    return QDSP_CMD_FAILED;
 }

#ifdef MSMAUD_VOC_AMR
 if (qdsp_voc_mode == QDSP_VOC_MODE_AMR_V)
 {
    if ((gsm_frame_id < QDSP_AMR_SPEECH_GOOD)
        || (gsm_frame_id > QDSP_AMR_NO_DATA))
    {
       ERR("Invalid AMR decoder frame type: %x", gsm_frame_id, 0, 0);
       return QDSP_CMD_FAILED;
    }

    if ((amr_frame_rate < QDSP_AMR_RATE_475)
        || (amr_frame_rate > QDSP_AMR_RATE_1220))
    {
       ERR("Invalid AMR decoder frame rate: %x", amr_frame_rate, 0, 0);
       return QDSP_CMD_FAILED;
    }
 }
 else
#endif /* MSMAUD_VOC_AMR */
 if ((gsm_frame_id < QDSP_GSM_SID) || (gsm_frame_id > QDSP_GSM_BFI))
      {
         ERR("Invalid GSM decoder frame type: %x", gsm_frame_id, 0, 0);
         return QDSP_CMD_FAILED;
      }


 memcpy((byte*)qdsp_cmd_rx_packet, (byte*)data_ptr,
        (QDSP_CMD_GSM_PACKET_LENGTH << 1));
 qdsp_cmd_gsm_dec_frame_id = gsm_frame_id;
 qdsp_cmd_gsm_dec_frame_rate = amr_frame_rate;
                                   /* ignored for GSM FR and EFR modes */
 qdsp_cmd_gsm_dec_taf = ((taf==TRUE)? QDSP_GSM_RX_TAF_M : 0x0000);


 /* handshaking and statistics */
 if (qdsp_cmd_dec_semaphore_flag != 0)
 {
    qdsp_cmd_gsm_dec_lost_cnt++;
                      /* received packets overridden and not decoded */
 }

 qdsp_cmd_dec_semaphore_flag = 1;                 /* handshaking */

 qdsp_cmd_gsm_voc_dec_pkt_cnt++;                  /* statistics */


 return QDSP_CMD_SUCCESS;
}    /* qdsp_cmd_gsm_rx_packet */


#endif  /* MSMAUD_VOC_AMR || MSMAUD_VOC_FR || MSMAUD_VOC_EFR */


/* <EJECT> */
#ifdef FEATURE_VOICE_PLAYBACK
/*===========================================================================

FUNCTION QDSP_CMD_GET_VP_RX_FRAME_WRAP

DESCRIPTION
  This function gets the next vocoder frame on the Rx queue and does AV
  sync functionality.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_get_vp_rx_frame_wrap (
  uint16 *rate,
  uint16 **frame
) {
  uint16 packet_length;

  if((qdsp_cmd_vp_paused == FALSE) && (qdsp_cmd_get_vp_rx_frame != NULL)) {
    qdsp_cmd_get_vp_rx_frame(rate, frame);
    packet_length = qdsp_cmd_get_voc_pkt_len(qdsp_voc_mode,*rate,
                                             QDSP_CMD_PKT_DIR_RX);
/* This check is for AMR byte based count  */
#ifdef MSMAUD_VOC_AMR_COMMON
    if(qdsp_voc_mode == QDSP_VOC_MODE_AMR_V) {
      packet_length +=1;
    }
#endif
#ifdef MSMAUD_VOC_AMR_WB_COMMON
    if(qdsp_voc_mode == QDSP_VOC_MODE_AMR_WB_V) {
      packet_length +=1;
    }
#endif
#ifdef MSMAUD_VOC_4GV
    if(qdsp_voc_mode == QDSP_VOC_MODE_4GV_V) {
      packet_length +=1;
    }
#endif  /* MSMAUD_VOC_4GV */
/* this is requied to adjust no of bytes(av_sync) for QCELP files */
#ifdef MSMAUD_VOC_IS733
    if(qdsp_voc_mode == QDSP_VOC_MODE_IS733_V) {
      packet_length +=1;
    }
#endif  /* MSMAUD_VOC_IS733 */

    qdsp_cmd_av_sync_info.av_sync_bytes_counter += packet_length;
#ifdef FEATURE_AUDIO_FORMAT
    qdsp_cmd_do_av_sync();
#endif /* FEATURE_AUDIO_FORMAT */
    return(TRUE);
  } else {
#if defined(MSMAUD_VOC_AMR_COMMON) && defined(FEATURE_AMR_REC_HOMING_SEQUENCE)
   if (qdsp_voc_mode == QDSP_VOC_MODE_AMR_V)
   {
	 /* Avoid out of bound array access */
	 if(qdsp_cmd_gsm_dec_frame_rate > QDSP_AMR_RATE_1220)
	 {
	   MSG_ERROR("Invalid AMR framerate: %d", qdsp_cmd_gsm_dec_frame_rate, 0, 0);
	   return(FALSE);
	 }
    memcpy(qdsp_cmd_silence_frame,qdsp_cmd_amr_homing_sequences[qdsp_cmd_gsm_dec_frame_rate],17* sizeof(uint16));
    *frame = qdsp_cmd_silence_frame;
    }
#endif/* defined(MSMAUD_VOC_AMR_COMMON)&&defined(FEATURE_AMR_REC_HOMING_SEQUENCE) */

    return(FALSE);
  }
}
#endif /* FEATURE_VOICE_PLAYBACK */

/* <EJECT> */
#if defined(MSMAUD_VOC_1X_COMMON) || defined(QDSP_IMAGE_VRBC_DEFINED)
/*==========================================================================
 FUNCTION qdsp_cmd_dec_semaphore_flag_set

DESCRIPTION
  This function sets the decoder semaphorere flag according
  to downlink data status

DEPENDENCIES
  None

RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/  
void qdsp_cmd_dec_semaphore_flag_set(boolean flag)
{
  qdsp_cmd_dec_semaphore_flag = (flag == TRUE) ? 1 : 0;
}

/*===========================================================================

FUNCTION QDSP_CMD_VOC_QDSP2_ISR

DESCRIPTION
  This function processes the vocoders encoder and decoder interrupts.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_voc_qdsp2_isr ( void )
{
  uint16 enc_semaphore_flag;  /* flag indicating if packet can be read   */
  uint16 dec_semaphore_flag;  /* flag indicating if packet can be read   */

#if defined(QDSP_vp3ParamsReg)
#error code not present
#endif /*QDSP_vp3ParamsReg*/

#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */

#ifdef FEATURE_VOICE_PLAYBACK
  uint16 packet_length;
  static boolean play_vp_on_both = FALSE;
  static uint16 *rx_tx_packet;
  uint16 frame_rate;
#endif /* FEATURE_VOICE_PLAYBACK */

#if defined(FEATURE_ACP) || defined(FEATURE_VOC_DTMF_DETECT)
  uint16 dsp_msg_type;        /* flag indicating dsp message type        */

  dsp_msg_type = qdsp_read(QDSP_dspMessageReg);
#endif /* defined(FEATURE_ACP) || defined(FEATURE_VOC_DTMF_DETECT) */

#ifdef QDSP_PACKET_SNIFFER
  log_voc_type   *qdsp_rx_log_ptr;
  log_voc_type   *qdsp_tx_log_ptr;
  boolean         pkt_swap_flag = FALSE;
  void            *voc_data = NULL;
  uint16          voc_pack_len = 0;
#endif /* QDSP_PACKET_SNIFFER */

#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
#ifdef FEATURE_VOC_DTMF_DETECT
  if ( dsp_msg_type == QDSP_CMD_DTMF_DETECT_MSG ) {
    /* Semaphore is cleared in this function */
    qdsp_cmd_dtmf_detect_processing();
    return;
  }
#endif /* FEATURE_VOC_DTMF_DETECT */


#if defined(QDSP_vp3ParamsReg)
#error code not present
#endif /*QDSP_vp3ParamsReg*/


  enc_semaphore_flag = qdsp_read(QDSP_encPacketReg);
  dec_semaphore_flag = qdsp_read(QDSP_decPacketReg);

  /* Diagnostic vocoder interrupt counters */
  qdsp_cmd_voc_isr_count++;

#ifdef FEATURE_VOC_ADPCM
  if ((qdsp_cmd_voc_adpcm_is_supported() == TRUE)            &&
      (qdsp_read(QDSP_adpcmPacketReg)    != 0)               &&
      (qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED)) {
    if (qdsp_cmd_voc_adpcm_send_frame() == TRUE) {
      qdsp_write(QDSP_adpcmPacketReg, 0);
    }
  }
#endif /* FEATURE_VOC_ADPCM */

  /* Check whether this is an encoder interrupt */
  if ( enc_semaphore_flag != 0 )
  {
    /* Diagnostic encoder ready counters */
    qdsp_cmd_enc_isr_ready_count++;

#ifdef FEATURE_VOICE_PLAYBACK
    if((qdsp_cmd_vp_tx_playing)&&
       (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_BOTH) &&
       (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_TX)
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
      )
    {
      play_vp_on_both =
      qdsp_cmd_get_vp_tx_frame(&qdsp_cmd_enc_frame_rate, &rx_tx_packet);

      /* Set packet length to expected length based on rate          */
      qdsp_cmd_enc_packet_length =
      QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_enc_frame_rate);

      if (qdsp_cmd_enc_packet_length != 0)
      {
        swap((byte *)rx_tx_packet, (byte *)qdsp_cmd_tx_packet,
                                           qdsp_cmd_enc_packet_length);
      }
    }
    else
#endif /* FEATURE_VOICE_PLAYBACK */
    {
      /* Read the frame rate from the DSP                */
      qdsp_cmd_enc_frame_rate = qdsp_read(QDSP_encPacketRate);

      /* Set packet length to expected length based on rate          */
      qdsp_cmd_enc_packet_length =
      QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_enc_frame_rate);

      qdsp_block_read(QDSP_encPacketBuf, 0,
                      qdsp_cmd_tx_packet,
                      qdsp_cmd_enc_packet_length, FALSE);
#ifdef FEATURE_VOICE_RECORD
      /* If we are recording, only record the valid frames.
      */
      if (((qdsp_cmd_rec_dir == QDSP_CMD_REC_REVERSE) ||
           (qdsp_cmd_rec_dir == QDSP_CMD_REC_BOTH)
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
          ) && (qdsp_cmd_enc_frame_rate >= qdsp_cmd_rec_min_frame_rate) &&
               (qdsp_cmd_enc_frame_rate <= qdsp_cmd_rec_max_frame_rate))
      {
        swap((byte *)qdsp_cmd_tx_packet, (byte *)qdsp_cmd_temp_packet,
                                          qdsp_cmd_enc_packet_length);

#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
        {
          qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_REVERSE, qdsp_cmd_enc_frame_rate,
                       qdsp_cmd_enc_packet_length, qdsp_cmd_temp_packet);
        }
      }
#endif /* FEATURE_VOICE_RECORD */
    }

    /* Host clears the semaphore flag when read                        */
    qdsp_write(QDSP_encPacketReg, 0); /* Clear the semaphore */

    /* Diagnostic QDSP encoder frame rate counters */
    switch (qdsp_cmd_enc_frame_rate) {
       case QDSP_RATE_EIGHTH_V:
          qdsp_cmd_tx_8++;
          break;
       case QDSP_RATE_QUARTER_V:
          qdsp_cmd_tx_4++;
          break;
       case QDSP_RATE_HALF_V:
          qdsp_cmd_tx_2++;
          break;
       case QDSP_RATE_FULL_V:
          qdsp_cmd_tx_1++;
          break;
       default:
          break;
    }

    qdsp_write(QDSP_encMaxRate, qdsp_cmd_max_frame_rate);
    qdsp_write(QDSP_encMinRate, qdsp_cmd_min_frame_rate);
    qdsp_cmd_enc_semaphore_flag = 1;

#ifdef FEATURE_VOC_PACKET_INTERFACE
    if (qdsp_cmd_rl_packet_func != NULL)
    {
      /* Diagnostic transmit frame counters */
      qdsp_cmd_tx_frame_count++;

      if (qdsp_cmd_enc_packet_length != 0)
      {
        /* Diagnostic encoder ready counters */
        qdsp_cmd_enc_ready_count++;

        /* byte swap each uint16 word */
        swap((byte *)qdsp_cmd_tx_packet,
             (byte *)qdsp_cmd_tx_packet,
             qdsp_cmd_enc_packet_length);
      }

      /* Pass data to Packet Client */
      qdsp_cmd_rl_packet_func((uint8*)qdsp_cmd_tx_packet,
                              qdsp_cmd_enc_frame_rate,
                              qdsp_cmd_enc_packet_length*2);

      /* Clear flag to indicate that the encoder packet is used
      */
      qdsp_cmd_enc_semaphore_flag = 0;
    }
#endif /* FEATURE_VOC_PACKET_INTERFACE */

#ifdef QDSP_PACKET_SNIFFER

    qdsp_tx_log_ptr = (log_voc_type *) log_alloc (LOG_VOC_REV_C,
                                                       sizeof(log_voc_type));
    if (qdsp_tx_log_ptr != NULL) {

      if (qdsp_cmd_rl_packet_func != NULL){

        /* ADSP is big-endian. ARM is little-endian,
                                            hence the BE->LE conversion */
        if (qdsp_cmd_enc_packet_length != 0) {
          swap((uint8 *)qdsp_cmd_tx_packet, (uint8 *)qdsp_tx_log_ptr->data,
                                               qdsp_cmd_enc_packet_length);
        }
      }
      else {
        /* log vocoder packet */
        memcpy( (uint8 *)qdsp_tx_log_ptr->data, (uint8 *)qdsp_cmd_tx_packet,
                                             qdsp_cmd_enc_packet_length * 2);
      }
      qdsp_tx_log_ptr->rate = qdsp_cmd_enc_frame_rate;
      qdsp_tx_log_ptr->revlink = TRUE;

      log_commit((log_voc_type *) qdsp_tx_log_ptr);
    }
#endif /*QDSP_PACKET_SNIFFER*/

  } /* end if ( enc_semaphore_flag != 0 ) */

  /* Check whether this is a decoder interrupt */
  if ( dec_semaphore_flag != 0 )
  {
#ifdef FEATURE_VOC_PACKET_INTERFACE
    if (qdsp_cmd_fl_packet_func !=NULL)
    {
      qdsp_cmd_fl_packet_func();
    }
#endif /* FEATURE_VOC_PACKET_INTERFACE */

    /* Diagnostic decoder ready counters */
    qdsp_cmd_dec_isr_ready_count++;

#ifdef FEATURE_VOICE_PLAYBACK
    if (( qdsp_cmd_dec_semaphore_flag == 0 ) &&
        ( !qdsp_cmd_vp_rx_playing )          &&
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
        ( !play_vp_on_both )
       )
#else /* #ifndef FEATURE_VOICE_PLAYBACK */
    /* If we didn't get a decoder packet */
    if ( qdsp_cmd_dec_semaphore_flag == 0 )
#endif /* FEATURE_VOICE_PLAYBACK */
    {
#ifdef FEATURE_VOICE_PLAYBACK
      if (qdsp_cmd_vp_incall_mux)
      {
        qdsp_write(QDSP_secondDecPacketRate, QDSP_RATE_ERASURE_V);
      }
#endif /* FEATURE_VOICE_PLAYBACK */

      qdsp_cmd_dec_frame_rate = QDSP_RATE_ERASURE_V;
      qdsp_cmd_dec_packet_length = 0 ;

      qdsp_write(QDSP_decPacketRate, qdsp_cmd_dec_frame_rate);

      /* Host clears the count to indicate a valid packet is
         available for DSP */
      qdsp_write(QDSP_decPacketReg, 0);

      /* Diagnostic OTA miss counters */
      qdsp_cmd_dec_miss_count++;

#ifdef QDSP_PACKET_SNIFFER
        pkt_swap_flag = FALSE;
        voc_data =  &qdsp_cmd_rx_packet;
        voc_pack_len  = qdsp_cmd_dec_packet_length;
#endif /* QDSP_PACKET_SNIFFER */
    }
    else
    {
      /* Diagnostic decoder ready counters */
      qdsp_cmd_dec_ready_count++;

#ifdef FEATURE_VOICE_PLAYBACK
      if (qdsp_cmd_vp_incall_mux && !qdsp_cmd_second_dec_configured)
      {
        qdsp_cmd_second_dec_configured = TRUE;
        qdsp_write(QDSP_secondDecoderConfig, qdsp_cmd_second_dec_config);
        if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_RX)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
        }
        else if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_TX)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
          qdsp_write(QDSP_memoPlaybackTxMux,
                     QDSP_CMD_SECOND_DEC_TX_MUX_ENA_V);
        }
        else if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
          qdsp_write(QDSP_memoPlaybackTxMux,
                     QDSP_CMD_SECOND_DEC_TX_MUX_ENA_V);
        }
        qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
      } else if (!qdsp_cmd_vp_incall_mux && qdsp_cmd_second_dec_configured) {
        qdsp_cmd_second_dec_configured = FALSE;
        qdsp_write(QDSP_secondDecoderConfig,
                   QDSP_CMD_SECOND_DEC_CONFIG_NONE);
        qdsp_write(QDSP_decoderMemoPlaybackMux,
                   QDSP_CMD_SECOND_DEC_RX_MUX_DIS_V);
        qdsp_write(QDSP_memoPlaybackTxMux,
                   QDSP_CMD_SECOND_DEC_TX_MUX_DIS_V);
      }

      if (play_vp_on_both)
      {
        play_vp_on_both = FALSE;

        if ((qdsp_cmd_enc_frame_rate == QDSP_RATE_EIGHTH_V) &&
            ((qdsp_voc_mode == QDSP_VOC_MODE_IS127_V)
#ifdef MSMAUD_VOC_IS127_VOIP
             || (qdsp_voc_mode == QDSP_VOC_MODE_IS127_VOIP_V)
#endif
            ) &&
            (qdsp_cmd_tx_packet[0]   == 0xffff)) {
          frame_rate    = QDSP_RATE_ERASURE_V;
          packet_length = 0;
        } else {
          frame_rate    = qdsp_cmd_enc_frame_rate;
          packet_length = qdsp_cmd_enc_packet_length;
        }

        /* semaphore was not 0 so write out encoder frame rate
        ** to decoder packet rate
        */
        qdsp_write(QDSP_decPacketRate, frame_rate);

        qdsp_cmd_dec_frame_rate = frame_rate;

#ifdef QDSP_PACKET_SNIFFER
        pkt_swap_flag = FALSE;
        voc_data =  &qdsp_cmd_tx_packet;
        voc_pack_len  = packet_length;
#endif /* QDSP_PACKET_SNIFFER */

	/*
        ** output encoder packet data to DSP decoder buffer
        */
        qdsp_block_write(QDSP_decPacketBuf, 0, qdsp_cmd_tx_packet,
                         packet_length, FALSE);
      }
      else if ((qdsp_cmd_vp_rx_playing)
               ||((qdsp_cmd_vp_tx_playing) &&
                  ((qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH) ||
                   (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_TX)))
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
              )
      {
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
        if ((qdsp_cmd_vp_tx_playing) &&
            ((qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH) ||
             (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_TX)))
        {
          (void) qdsp_cmd_get_vp_tx_frame( &frame_rate, &rx_tx_packet );
        }
        else
        {
          (void) qdsp_cmd_get_vp_rx_frame_wrap( &frame_rate, &rx_tx_packet );
        }

        /* make sure we have a valid frame rate.  Otherwise, force   */
        /* to an erasure.                                            */
        if ((frame_rate > QDSP_RATE_FULL_V) ||
            ((frame_rate    == QDSP_RATE_EIGHTH_V) &&
             ((qdsp_voc_mode == QDSP_VOC_MODE_IS127_V)
#ifdef MSMAUD_VOC_IS127_VOIP
              || (qdsp_voc_mode == QDSP_VOC_MODE_IS127_VOIP_V)
#endif
             ) &&
             (((byte *)rx_tx_packet)[0] == 0xff) &&
             (((byte *)rx_tx_packet)[1] == 0xff)))
        {        /* not a valid frame rate so force an erasure       */
          frame_rate    = QDSP_RATE_ERASURE_V;
          packet_length = 0;
        } else {
          /* Determine how much data we want to send for this frame  */
          /* rate                                                    */
          packet_length = QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(frame_rate);
        }

        if (qdsp_cmd_vp_incall_mux)
        {
          /* semaphore was not 0 so write out frame rate
          ** to decoder packet rate
          */
          qdsp_write(QDSP_secondDecPacketRate, frame_rate);

          qdsp_cmd_sec_dec_frame_rate = frame_rate;

          /*
          ** output packet data to DSP decoder buffer
          */

          qdsp_block_write(QDSP_secondDecPacketBuf, 0, rx_tx_packet,
                           packet_length, TRUE);
        }
        else
        {
          /* semaphore was not 0 so write out frame rate
          ** to decoder packet rate
          */
          qdsp_write(QDSP_decPacketRate, frame_rate);

          qdsp_cmd_dec_frame_rate = frame_rate;

          /*
          ** output packet data to DSP decoder buffer
          */

#ifdef QDSP_PACKET_SNIFFER
          pkt_swap_flag = TRUE;
          voc_data =  rx_tx_packet;
          voc_pack_len  = packet_length;
#endif /*QDSP_PACKET_SNIFFER*/

          qdsp_block_write(QDSP_decPacketBuf, 0, rx_tx_packet,
                           packet_length, TRUE);
        }
      }
      /* Don't transfer packets to RX when playback is paused.
      ** Prevent different format packets go into vocoder.
      */
      else if ((qdsp_cmd_vp_paused) && (!qdsp_cmd_vp_incall_mux_pause) &&
               (qdsp_cmd_vp_direction == QDSP_CMD_VP_RX)) {


       qdsp_cmd_dec_frame_rate = QDSP_RATE_ERASURE_V;
       qdsp_cmd_dec_packet_length  = 0;

        /* Playback is paused and we are not doing an incall mux. We need
        to write erasure to primary decoder */
        qdsp_write(QDSP_decPacketRate, qdsp_cmd_dec_frame_rate);
        /* Host clears the count to indicate a valid packet is
           available for DSP */
        qdsp_write(QDSP_decPacketReg, 0);

#ifdef QDSP_PACKET_SNIFFER
        pkt_swap_flag = FALSE;
        voc_data =  &qdsp_cmd_rx_packet;
        voc_pack_len  = qdsp_cmd_dec_packet_length;
#endif /*QDSP_PACKET_SNIFFER*/

      }
      if ((!qdsp_cmd_vp_rx_playing && !qdsp_cmd_vp_tx_playing) ||
          ((qdsp_cmd_vp_tx_playing || qdsp_cmd_vp_rx_playing) &&
            qdsp_cmd_vp_incall_mux))
      {
       if (qdsp_cmd_vp_paused && qdsp_cmd_vp_incall_mux_pause)
       {
         /* We are paused but we were doing an incall mux and so
         voice call is still on, we need to disable comfort noise */
         qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
       }
        /* semaphore was not 0 so write out frame rate */
        qdsp_write(QDSP_decPacketRate, qdsp_cmd_dec_frame_rate);

#ifdef QDSP_PACKET_SNIFFER
        pkt_swap_flag = FALSE;
        voc_data =  &qdsp_cmd_rx_packet;
        voc_pack_len  = qdsp_cmd_dec_packet_length;
#endif /*QDSP_PACKET_SNIFFER*/

        /* output packet data to DSP */
        qdsp_block_write(QDSP_decPacketBuf, 0,
                         qdsp_cmd_rx_packet,
                         qdsp_cmd_dec_packet_length, FALSE);
      }

#else /* #ifndef FEATURE_VOICE_PLAYBACK */

      /* semaphore was not 0 so write out frame rate            */
      qdsp_write(QDSP_decPacketRate, qdsp_cmd_dec_frame_rate);

#ifdef QDSP_PACKET_SNIFFER
      pkt_swap_flag = FALSE;
      voc_data =  &qdsp_cmd_rx_packet;
      voc_pack_len  = qdsp_cmd_dec_packet_length;
#endif /*QDSP_PACKET_SNIFFER*/

      /* output packet data to DSP                                */
      qdsp_block_write(QDSP_decPacketBuf, 0,
                       qdsp_cmd_rx_packet,
                       qdsp_cmd_dec_packet_length, FALSE);

#endif /* FEATURE_VOICE_PLAYBACK */

#ifdef FEATURE_QDJ_TIMEWARP
      /* Set timewarp parameters before writing the decode data to the DSP */
      qdsp_cmd_timewarp();
#endif /* FEATURE_QDJ_TIMEWARP */

      /* Host decrements the count to indicate a valid packet is
         available for DSP */
      qdsp_write(QDSP_decPacketReg, 0);

      qdsp_cmd_dec_semaphore_flag = 0;

      /* Diagnostic vocoder decoder frame rate counters */
      switch (qdsp_cmd_dec_frame_rate) {
         case QDSP_RATE_EIGHTH_V:
            qdsp_cmd_rx_8++;
            break;
         case QDSP_RATE_QUARTER_V:
            qdsp_cmd_rx_4++;
            break;
         case QDSP_RATE_HALF_V:
            qdsp_cmd_rx_2++;
            break;
         case QDSP_RATE_FULL_V:
            qdsp_cmd_rx_1++;
            break;
         case QDSP_RATE_BLANK_V:
            qdsp_cmd_rx_0++;
            break;
         case QDSP_RATE_ERASURE_V:
            qdsp_cmd_rx_e++;
            break;
         default:
            break;
      }
    } /* end if ( qdsp_cmd_dec_semaphore_flag = 0 ) */

#ifdef QDSP_PACKET_SNIFFER

      qdsp_rx_log_ptr = (log_voc_type *) log_alloc (LOG_VOC_FOR_C,
                                                    sizeof(log_voc_type));
      if (qdsp_rx_log_ptr != NULL) {

        /* ADSP is big-endian. ARM is little-endian ,
                                       hence the BE->LE conversion */
        if ((voc_pack_len != 0) && (pkt_swap_flag == TRUE)) {
          swap((uint8 *)voc_data, (uint8 *)qdsp_rx_log_ptr->data,
                                                       voc_pack_len);
        }
        else {
          /* log vocoder packet */
          memcpy( (uint8 *)qdsp_rx_log_ptr->data,(uint8 *)voc_data,
                                                    voc_pack_len * 2);
        }
        qdsp_rx_log_ptr->rate = qdsp_cmd_dec_frame_rate;
        qdsp_rx_log_ptr->revlink = FALSE;

        log_commit((log_voc_type *) qdsp_rx_log_ptr);
      }
#endif /*QDSP_PACKET_SNIFFER*/

  } /* end if ( dec_semaphore_flag != 0 ) */

#ifdef FEATURE_VOC_PCM_INTERFACE
  qdsp_cmd_process_pcm_data();
#endif /* FEATURE_VOC_PCM_INTERFACE */

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)

#if defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)
  switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
      if (qdsp_cmd_adec_int_cb_ptr != NULL) {
        /* If msg type is non-zero, we have an interrupt pending */
        if (qdsp_read(QDSP_adecDataHostStickyInt) != 0) {

          MSG_ERROR("adec isr",0,0,0);
          /* Tell vocoder task to return the next set of data */
          qdsp_cmd_adec_int_cb_ptr();
        }
      }
      break;
  } /* switch */

#ifdef FEATURE_AUDIO_FORMAT
  qdsp_cmd_do_av_sync();
#endif /* FEATURE_AUDIO_FORMAT */

#ifdef FEATURE_AUDFMT_SPECTRUM_ANALYZER
  qdsp_cmd_do_spectrum_analyzer();
#endif /* FEATURE_AUDFMT_SPECTRUM_ANALYZER */

#endif /* QDSP_IMAGE_VOC_MP3_DEFINED || QDSP_IMAGE_VOC_EVRC_MP3_DEFINED ||
          QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */

#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */

#if defined(FEATURE_TTY) && defined(FEATURE_TTY_ACTIVITY_STATUS)
  /* Update the TTY activity status flags */
  if ( (qdsp_tty_mode == QDSP_TTY_ENA_V) &&
       ((enc_semaphore_flag != 0) || (dec_semaphore_flag != 0)) &&
       (qdsp_tty_update_status_func != NULL) ) {
    static byte num_interrupts = 0;

    num_interrupts++;
    if (num_interrupts >= QDSP_CMD_TTY_UPDATE_NUM_INTS) {
      boolean enc_active, dec_active;

      num_interrupts = 0;
      enc_active = (qdsp_read(QDSP_ttyEncFlag) > 1) ? TRUE: FALSE;
      dec_active = (qdsp_read(QDSP_ttyWriteFlag) > 1)? TRUE: FALSE;

      /* Update the TTY LEDs only if the status has changed from the previous
         state */
      if (enc_active != qdsp_tty_prev_enc_state ||
          dec_active != qdsp_tty_prev_dec_state) {
        qdsp_tty_prev_enc_state = enc_active;
        qdsp_tty_prev_dec_state = dec_active;
        qdsp_tty_update_status_func(enc_active, dec_active);
      }
    }
  }
#endif /* defined(FEATURE_TTY) && defined(FEATURE_TTY_ACTIVITY_STATUS) */
} /* qdsp_cmd_voc_qdsp2_isr() */

#endif  /* MSMAUD_VOC_1X_COMMON || QDSP_IMAGE_VRBC_DEFINED */

#ifdef FEATURE_MM_REC
/*===========================================================================

FUNCTION QDSP_CMD_MM_REC_CONFIG

DESCRIPTION
  This function will send a command to the DSP to configure the multi media
  recording processing

DEPENDENCIES
  This command is only valid when the DSP is in audio entry state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS

  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_mm_rec_config (
  qdsp_cmd_mm_rec_format_type rec_format,/* Current encoder format            */
  qdsp_cmd_mm_rec_fn_type     cb_func    /* Callback for QDSP to request data */
)
{
  if(cb_func == NULL) {
    qdsp_cmd_mm_rec_frame_fn = NULL;
  } else {
    qdsp_cmd_mm_rec_frame_fn = (qdsp_cmd_mm_rec_fn_type)cb_func;
    qdsp_cmd_mm_rec_format   = rec_format;

    /* Reset qdsp read/write count
     */
    qdsp_cmd_mm_rec_read_cnt  = 0;
    qdsp_cmd_mm_rec_write_cnt = 0;
    qdsp_cmd_mm_rec_isr_count = 0;

    qdsp_cmd_mm_rec_frame_cnt_prev = 0;
    qdsp_cmd_cnt_wrap_around       = FALSE;

    /* Reset read count in QDSP */
    qdsp_cmd_mm_rec_update_read_count(qdsp_cmd_mm_rec_read_cnt);
  }

  return QDSP_CMD_SUCCESS;
}

/*===========================================================================

FUNCTION qdsp_cmd_mm_rec_qdsp2_isr

DESCRIPTION
  This function processes the vocoders encoder and decoder interrupts.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_mm_rec_qdsp2_isr (void)
{
  uint16 enc_semaphore_flag;  /* flag indicating if packet can be read   */

  enc_semaphore_flag = qdsp_read(QDSP_encPacketReg);

#ifdef FEATURE_GRAPH_ADPCM
  if(qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED) {
    qdsp_cmd_graph_adpcm_send_frame();
  }
#endif /* FEATURE_GRAPH_ADPCM */

  /* Diagnostic vocoder interrupt counters */
  qdsp_cmd_mm_rec_isr_count++;

  /* Check whether this is an encoder interrupt */
  if (enc_semaphore_flag != 0) {

    /* Diagnostic encoder ready counters */
    qdsp_cmd_enc_isr_ready_count++;

    if (qdsp_cmd_mm_rec_frame_fn != NULL) {
      qdsp_cmd_mm_rec_frame_fn();
    }

    /* Host clears the semaphore flag when read                        */
    qdsp_write(QDSP_encPacketReg, 0); /* Clear the semaphore */

  } /* end if (enc_semaphore_flag != 0) */

} /* qdsp_cmd_mm_rec_qdsp2_isr() */
#endif /* FEATURE_MM_REC */

/* <EJECT> */
#ifdef FEATURE_GRAPH_ADPCM
/*===========================================================================

FUNCTION QDSP_CMD_GRAPH_ADPCM_SEND_FRAME

DESCRIPTION
  This function sends an ADPCM frame to graphics image.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_graph_adpcm_send_frame (void)
{
  uint32 tlong;
  uint16 frame_size        = QDSP_CMD_ADEC_FRAME_SIZE;
  uint16 samples_per_frame = 505;

#if defined(QDSP_IMAGE_VFE_BAYER_DEFINED)   || \
    defined(QDSP_IMAGE_VFE_YCBCR_DEFINED)   || \
    defined(QDSP_IMAGE_QCAMCORDER_DEFINED)  || \
    defined(QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED)
  switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */
      frame_size        = QDSP_CMD_ADPCM_ADEC_FRAME_SIZE;
      samples_per_frame = 1017;
      break;

    default:
      break;
  }
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED || QDSP_IMAGE_VFE_YCBCR_DEFINED
          QDSP_IMAGE_QCAMCORDER        || QDSP_IMAGE_QCAMCORDER_AACENC  || QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED*/

  if(qdsp_read(QDSP_decPacketReg) != 0) {
    /* Verify that there is one whole frame to send to DSP */
    if((qdsp_cmd_adpcm_adec_info.buf_length +
                     qdsp_cmd_adpcm_adec_info.tmp_buf_length) >= frame_size) {

      if(qdsp_cmd_adpcm_adec_info.tmp_buf_length != 0) {
        /* If temp buffer has odd number of bytes do adjustment */
        if(qdsp_cmd_adpcm_adec_info.tmp_buf_length & 0x1) {
          qdsp_cmd_adpcm_adec_info.tmp_buf
                    [qdsp_cmd_adpcm_adec_info.tmp_buf_length] =
                                        *qdsp_cmd_adpcm_adec_info.buf_ptr;
          qdsp_cmd_adpcm_adec_info.buf_index++;
          qdsp_cmd_adpcm_adec_info.tmp_buf_length++;
          qdsp_cmd_adpcm_adec_info.buf_length--;
        }

        tlong = frame_size - qdsp_cmd_adpcm_adec_info.tmp_buf_length;

        qdsp_block_write(QDSP_decPacketBuf, 0,
                         (uint16*) qdsp_cmd_adpcm_adec_info.tmp_buf,
                         qdsp_cmd_adpcm_adec_info.tmp_buf_length/2, FALSE);
      } else {
        tlong = frame_size;
      }
      if (qdsp_cmd_adpcm_adec_info.buf_ptr != NULL) {
        qdsp_block_write(QDSP_decPacketBuf,
                         qdsp_cmd_adpcm_adec_info.tmp_buf_length/2,
                         (uint16*) &qdsp_cmd_adpcm_adec_info.buf_ptr
                         [qdsp_cmd_adpcm_adec_info.buf_index],
                         tlong/2, FALSE);

        qdsp_cmd_adpcm_adec_info.buf_index      += tlong;
        qdsp_cmd_adpcm_adec_info.buf_length     -= tlong;
      }
      qdsp_cmd_adpcm_adec_info.tmp_buf_length  = 0;

      qdsp_write(QDSP_decPacketRate, samples_per_frame);
      qdsp_write(QDSP_decPacketReg, 0);
    }

    /* Check if less than one frame of data remaining in buffers */
    if((qdsp_cmd_adpcm_adec_info.buf_length +
                    qdsp_cmd_adpcm_adec_info.tmp_buf_length) <= frame_size) {
      if(qdsp_cmd_adpcm_adec_info.buf_length != 0) {
        memcpy(&(qdsp_cmd_adpcm_adec_info.tmp_buf
                             [qdsp_cmd_adpcm_adec_info.tmp_buf_length]),
               &qdsp_cmd_adpcm_adec_info.buf_ptr
               [qdsp_cmd_adpcm_adec_info.buf_index],
               qdsp_cmd_adpcm_adec_info.buf_length);

        qdsp_cmd_adpcm_adec_info.tmp_buf_length +=
                                   qdsp_cmd_adpcm_adec_info.buf_length;

        qdsp_cmd_adpcm_adec_info.buf_length      = 0;
        qdsp_cmd_adpcm_adec_info.buf_index       = 0;

#ifdef FEATURE_GASYNTH_INTERFACE
        qdsp_cmd_adpcm_adec_info.free_ptr = qdsp_cmd_adpcm_adec_info.buf_ptr;
        if (qdsp_cmd_adpcm_adec_info.next_ptr != NULL) {
          qdsp_cmd_adpcm_adec_info.buf_ptr =
            qdsp_cmd_adpcm_adec_info.next_ptr;
          qdsp_cmd_adpcm_adec_info.buf_length =
            qdsp_cmd_adpcm_adec_info.next_length;
          qdsp_cmd_adpcm_adec_info.next_ptr = NULL;
        } else {
          qdsp_cmd_adpcm_adec_info.buf_ptr = NULL;
        }
#endif /* FEATURE_GASYNTH_INTERFACE */
      }
      if(qdsp_cmd_adec_int_cb_ptr != NULL) {
        /* Tell vocoder task to return the next set of data */
        qdsp_cmd_adec_int_cb_ptr();
      }
    }
  }
}
#endif /* FEATURE_GRAPH_ADPCM */

/* <EJECT> */
#ifdef FEATURE_VOC_ADPCM
/*===========================================================================

FUNCTION QDSP_CMD_VOC_ADPCM_IS_SUPPORTED

DESCRIPTION
  This function returns true if vocoder-adpcm is supported under the currently
  loaded image, and false otherwise.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_voc_adpcm_is_supported (void)
{
  boolean ret_val = FALSE;

  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_VOC_DEFINED)          || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED)    || \
    defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED) || \
    defined(QDSP_IMAGE_VOC_EVRC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_E90_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_E90_DEFINED) || \
    defined(QDSP_IMAGE_VOC_QTV_DEFINED)      || \
    defined(QDSP_IMAGE_FR_DEFINED)           || \
    defined(QDSP_IMAGE_EFR_DEFINED)          || \
    defined(QDSP_IMAGE_AMR_DEFINED)          || \
    defined(QDSP_IMAGE_AMR_WB_DEFINED)       || \
    defined(QDSP_IMAGE_HR_DEFINED)

#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif /* QDSP_IMAGE_VOC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif /* QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif /* QDSP_IMAGE_VOC_EVRC_DEFINED */
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif /* QDSP_IMAGE_VOC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif /* QDSP_IMAGE_VOC_EVRC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_FR_DEFINED */
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_EFR_DEFINED */
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif /* QDSP_IMAGE_AMR_DEFINED */
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif /* QDSP_IMAGE_AMR_WB_DEFINED */
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif /* QDSP_IMAGE_HR_DEFINED */

      ret_val = TRUE;
      break;
#endif /* QDSP_IMAGE_VOC_DEFINED          || \
          QDSP_IMAGE_VOC_EVRC_DEFINED     || \
          QDSP_IMAGE_VOC_E90_DEFINED      || \
          QDSP_IMAGE_VOC_EVRC_E90_DEFINED || \
          QDSP_IMAGE_VOC_QTV_DEFINED      || \
          QDSP_IMAGE_FR_DEFINED           || \
          QDSP_IMAGE_EFR_DEFINED          || \
          QDSP_IMAGE_AMR_DEFINED          || \
          QDSP_IMAGE_AMR_WB_DEFINED       || \
          QDSP_IMAGE_HR_DEFINED */

    default:
      break;
  }

  return ret_val;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_VOC_ADPCM_SEND_FRAME

DESCRIPTION
  This function sends an ADPCM frame to vocoder image.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_voc_adpcm_send_frame (void)
{
  uint32 tlong;
  uint16 frame_size        = QDSP_CMD_ADEC_FRAME_SIZE;
  uint16 samples_per_frame = 505;
  boolean ret_val          = FALSE;

  if ((qdsp_cmd_adpcm_status != QDSP_CMD_ADPCM_MODE_ENABLED) ||
      (qdsp_read(QDSP_adpcmPacketReg) == 0)) {

    return ret_val;
  }

  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_VOC_DEFINED)            || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED) || \
    defined(QDSP_IMAGE_VOC_EVRC_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_E90_DEFINED)        || \
    defined(QDSP_IMAGE_VOC_EVRC_E90_DEFINED)   || \
    defined(QDSP_IMAGE_VOC_QTV_DEFINED)        || \
    defined(QDSP_IMAGE_FR_DEFINED)             || \
    defined(QDSP_IMAGE_EFR_DEFINED)            || \
    defined(QDSP_IMAGE_AMR_DEFINED)            || \
    defined(QDSP_IMAGE_AMR_WB_DEFINED)         || \
    defined(QDSP_IMAGE_HR_DEFINED)

#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif /* QDSP_IMAGE_VOC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif /* QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif /* QDSP_IMAGE_VOC_EVRC_DEFINED */
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif /* QDSP_IMAGE_VOC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif /* QDSP_IMAGE_VOC_EVRC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_FR_DEFINED */
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_EFR_DEFINED */
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif /* QDSP_IMAGE_AMR_DEFINED */
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif /* QDSP_IMAGE_AMR_WB_DEFINED */
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif /* QDSP_IMAGE_HR_DEFINED */

      frame_size        = QDSP_CMD_ADPCM_ADEC_FRAME_SIZE;
      samples_per_frame = 1017;
      break;
#endif /* QDSP_IMAGE_VOC_DEFINED          || \
          QDSP_IMAGE_VOC_EVRC_DEFINED     || \
          QDSP_IMAGE_VOC_E90_DEFINED      || \
          QDSP_IMAGE_VOC_EVRC_E90_DEFINED || \
          QDSP_IMAGE_VOC_QTV_DEFINED      || \
          QDSP_IMAGE_FR_DEFINED           || \
          QDSP_IMAGE_EFR_DEFINED          || \
          QDSP_IMAGE_AMR_DEFINED          || \
          QDSP_IMAGE_AMR_WB_DEFINED       || \
          QDSP_IMAGE_HR_DEFINED */

    default:
      break;
  }

  /* Verify that there is one whole frame to send to DSP */
  if((qdsp_cmd_adpcm_adec_info.buf_length +
                   qdsp_cmd_adpcm_adec_info.tmp_buf_length) >= frame_size) {

    if (qdsp_cmd_adpcm_adec_info.tmp_buf_length != 0) {
      /* If temp buffer has odd number of bytes do adjustment */
      if (qdsp_cmd_adpcm_adec_info.tmp_buf_length & 0x1) {
        qdsp_cmd_adpcm_adec_info.tmp_buf
                  [qdsp_cmd_adpcm_adec_info.tmp_buf_length] =
                                      *qdsp_cmd_adpcm_adec_info.buf_ptr;
        qdsp_cmd_adpcm_adec_info.buf_index++;
        qdsp_cmd_adpcm_adec_info.tmp_buf_length++;
        qdsp_cmd_adpcm_adec_info.buf_length--;
      }

      tlong = frame_size - qdsp_cmd_adpcm_adec_info.tmp_buf_length;

      if (qdsp_cmd_adpcm_data == FALSE) {

        qdsp_cmd_adpcm_data = TRUE;
      }

      qdsp_block_write(QDSP_adpcmPacketBuf, 0,
                       (uint16*) qdsp_cmd_adpcm_adec_info.tmp_buf,
                       qdsp_cmd_adpcm_adec_info.tmp_buf_length/2, FALSE);
      ret_val = TRUE;

    } else {
      tlong = frame_size;
    }

    if (qdsp_cmd_adpcm_data == FALSE) {

      qdsp_cmd_adpcm_data = TRUE;
    }

    if (qdsp_cmd_adpcm_adec_info.buf_ptr != NULL) {
    qdsp_block_write(QDSP_adpcmPacketBuf,
                     qdsp_cmd_adpcm_adec_info.tmp_buf_length/2,
                       (uint16*) &qdsp_cmd_adpcm_adec_info.buf_ptr[
                                  qdsp_cmd_adpcm_adec_info.buf_index],
                     tlong/2, FALSE);
      ret_val = TRUE;

      qdsp_cmd_adpcm_adec_info.buf_index      += tlong;
      qdsp_cmd_adpcm_adec_info.buf_length     -= tlong;
    }
    qdsp_cmd_adpcm_adec_info.tmp_buf_length  = 0;
    qdsp_write(QDSP_adpcmPacketRate, samples_per_frame);
  }

  /* Check if less than one frame of data remaining in buffers */
  if ((qdsp_cmd_adpcm_adec_info.buf_length +
                   qdsp_cmd_adpcm_adec_info.tmp_buf_length) <= frame_size) {

    if (qdsp_cmd_adpcm_adec_info.buf_length != 0) {

      memcpy(&(qdsp_cmd_adpcm_adec_info.tmp_buf
                           [qdsp_cmd_adpcm_adec_info.tmp_buf_length]),
             &qdsp_cmd_adpcm_adec_info.buf_ptr[
                 qdsp_cmd_adpcm_adec_info.buf_index],
             qdsp_cmd_adpcm_adec_info.buf_length);

      qdsp_cmd_adpcm_adec_info.tmp_buf_length +=
                           qdsp_cmd_adpcm_adec_info.buf_length;

      qdsp_cmd_adpcm_adec_info.buf_length = 0;
      qdsp_cmd_adpcm_adec_info.buf_index  = 0;
#ifdef FEATURE_GASYNTH_INTERFACE
      qdsp_cmd_adpcm_adec_info.free_ptr = qdsp_cmd_adpcm_adec_info.buf_ptr;
      if (qdsp_cmd_adpcm_adec_info.next_ptr != NULL) {
          qdsp_cmd_adpcm_adec_info.buf_ptr =
                        qdsp_cmd_adpcm_adec_info.next_ptr;
          qdsp_cmd_adpcm_adec_info.buf_length =
                        qdsp_cmd_adpcm_adec_info.next_length;
          qdsp_cmd_adpcm_adec_info.next_ptr = NULL;
      } else {
        qdsp_cmd_adpcm_adec_info.buf_ptr = NULL;
      }
#endif /* FEATURE_GASYNTH_INTERFACE */
    }

    if (qdsp_cmd_adec_int_cb_ptr != NULL) {
      /* Tell vocoder task to return the next set of data */
      qdsp_cmd_adec_int_cb_ptr();
    }
  }

  return (ret_val);
}
#endif /* FEATURE_VOC_ADPCM */

/* <EJECT> */
#ifdef FEATURE_GRAPH_AUDIO
/*===========================================================================

FUNCTION QDSP_CMD_GRAPH_1X_DEC_ISR

DESCRIPTION
  This function processes the audio EVRC/QCELP decoder interrupts for
  graphics images.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_graph_1x_dec_isr( void )
{
#ifdef FEATURE_VOICE_PLAYBACK
  uint16 packet_length;
  uint16 *packet;
  uint16 frame_rate;
  if (qdsp_read(QDSP_decPacketReg) != 0)
  {
    if (qdsp_cmd_vp_rx_playing) {
      (void) qdsp_cmd_get_vp_rx_frame_wrap( &frame_rate, &packet );

      /* Determine how much data we want to send for this frame
      ** rate
      */
      packet_length = QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(frame_rate);

      /* semaphore was not 0 so write out frame rate
      ** to decoder packet rate
      */
      qdsp_write(QDSP_decPacketRate, frame_rate);

      /* output packet data to DSP decoder buffer
      */
      qdsp_block_write(QDSP_decPacketBuf, 0, packet, packet_length,
                       TRUE);

      /* Host decrements the count to indicate a valid packet is
      ** available for DSP
      */
      qdsp_write(QDSP_decPacketReg, 0);
    }
  }
#endif /* FEATURE_VOICE_PLAYBACK */
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GRAPH_1X_ENC_ISR

DESCRIPTION
  This function processes the audio EVRC/QCELP encoder interrupts for
  graphics images.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_graph_1x_enc_isr( void )
{
#ifdef FEATURE_VOICE_RECORD

  uint16 packet_length;
  uint16 frame_rate;
  if ( qdsp_read(QDSP_encPacketReg) != 0 ) {
    if((qdsp_cmd_rec_dir == QDSP_CMD_REC_REVERSE) &&
       (qdsp_cmd_rec_frame_fn != NULL)) {
      frame_rate    = qdsp_read(QDSP_encPacketRate);

      /* Drop frames that are out of the desired frame rate range
      */
      if ((frame_rate >= qdsp_cmd_rec_min_frame_rate) &&
          (frame_rate <= qdsp_cmd_rec_max_frame_rate)) {
        packet_length = QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(frame_rate);

        qdsp_block_read(QDSP_encPacketBuf, 0, qdsp_cmd_temp_packet,
                        packet_length, TRUE);
        qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_REVERSE, frame_rate,
                              packet_length, qdsp_cmd_temp_packet);
      }

      qdsp_write(QDSP_encPacketReg, 0);
    }
  }
#endif
}

/* <EJECT> */
#ifdef MSMAUD_VOC_AMR_COMMON
/*===========================================================================

FUNCTION QDSP_CMD_GRAPH_AMR_DEC_ISR

DESCRIPTION
  This function processes the audio AMR decoder interrupts for graphics images.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_graph_amr_dec_isr( void )
{
#ifdef FEATURE_VOICE_PLAYBACK
  uint16                       packet_length;
  uint16                       *rx_tx_packet;
  uint16                       frame_rate;
  qdsp_cmd_gsm_frame_type      gsm_frame_id;
  qdsp_cmd_gsm_frame_rate_type gsm_frame_rate;

  if (qdsp_read(QDSP_decPacketReg) != 0) {
    if (qdsp_cmd_vp_rx_playing) {
       (void) qdsp_cmd_get_vp_rx_frame_wrap( &frame_rate, &rx_tx_packet );

      /* Extract frame rate, ID from dec flag */
      gsm_frame_id = (qdsp_cmd_gsm_frame_type)
                                ((frame_rate & QDSP_AMR_FRAME_TYPE_M) | 0xff);
      gsm_frame_rate = (qdsp_cmd_gsm_frame_rate_type)
                                       (frame_rate & QDSP_AMR_CODEC_MODE_M);

      /* Determine packet length based on frame type */
      switch(gsm_frame_id) {
        case QDSP_AMR_SPEECH_GOOD:
        case QDSP_AMR_SPEECH_DEGRADED:
        case QDSP_AMR_ONSET:
          /* Set packet length to expected length based on rate */
          packet_length = QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(gsm_frame_rate);
          break;
        case QDSP_AMR_SID_FIRST:
        case QDSP_AMR_SID_UPDATE:
          packet_length = PACKET_SIZE_AMR_SID;
          break;
        case QDSP_AMR_SPEECH_BAD:
        case QDSP_AMR_SID_BAD:
        case QDSP_AMR_NO_DATA:
        default:
          packet_length = PACKET_SIZE_AMR_BAD;
          break;
      }

      frame_rate = ((uint16)gsm_frame_id & QDSP_AMR_FRAME_TYPE_M) |
                   ((uint16)gsm_frame_rate & QDSP_AMR_CODEC_MODE_M);
      /* semaphore was not 0 so write out frame rate
      ** to decoder packet rate
      */
      qdsp_write(QDSP_decPacketRate, frame_rate);

      /* output packet data to DSP decoder buffer
      */
      qdsp_block_write(QDSP_decPacketBuf, 0, rx_tx_packet, packet_length,
                       TRUE);

      /* Host decrements the count to indicate a valid packet is
      ** available for DSP
      */
      qdsp_write(QDSP_decPacketReg, 0);
    }
  }
#endif /* FEATURE_VOICE_PLAYBACK */
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GRAPH_AMR_ENC_ISR

DESCRIPTION
  This function processes the audio AMR encoder interrupts for graphics images.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_graph_amr_enc_isr( void )
{
#ifdef FEATURE_VOICE_RECORD
  uint16 packet_length;
  uint16 frame_rate;
  qdsp_cmd_gsm_frame_rate_type gsm_frame_rate;
  qdsp_cmd_gsm_frame_type enc_frame_id;

  if ( qdsp_read(QDSP_encPacketReg) != 0 ) {
    if((qdsp_cmd_rec_dir == QDSP_CMD_REC_REVERSE) &&
       (qdsp_cmd_rec_frame_fn != NULL)) {
      frame_rate    = qdsp_read(QDSP_encPacketRate);
      gsm_frame_rate = (qdsp_cmd_gsm_frame_rate_type)
                                      (frame_rate & QDSP_AMR_CODEC_MODE_M);

      switch (frame_rate & QDSP_AMR_FRAME_TYPE_M)
      {
        case QDSP_AMR_TX_SPEECH_V :
          enc_frame_id  = QDSP_AMR_SPEECH_GOOD;
          packet_length = QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(gsm_frame_rate);
          break;

        case QDSP_AMR_TX_SID_FIRST_V :
          enc_frame_id  = QDSP_AMR_SID_FIRST;
          packet_length = PACKET_SIZE_AMR_SID;
          break;

        case QDSP_AMR_TX_SID_UPDATE_V :
          enc_frame_id  = QDSP_AMR_SID_UPDATE;
          packet_length = PACKET_SIZE_AMR_SID;
          break;

        case QDSP_AMR_TX_NO_DATA_V :
          enc_frame_id = QDSP_AMR_NO_DATA;
          packet_length = PACKET_SIZE_AMR_BAD;
          break;

        default :
          /* default to QDSP_AMR_NO_DATA */
          enc_frame_id = QDSP_AMR_NO_DATA;
          packet_length = 0;
          break;
      }

      if ((gsm_frame_rate >= qdsp_cmd_rec_min_frame_rate) &&
          (gsm_frame_rate <= qdsp_cmd_rec_max_frame_rate)) {

        qdsp_block_read(QDSP_encPacketBuf, 0, qdsp_cmd_temp_packet,
                        packet_length, TRUE);
        qdsp_cmd_rec_frame_fn
          (
            QDSP_CMD_REC_REVERSE,
            ( gsm_frame_rate | (enc_frame_id & QDSP_AMR_FRAME_TYPE_M)),
            packet_length,
            qdsp_cmd_temp_packet
          );
      }

      qdsp_write(QDSP_encPacketReg, 0);
    }
  }
#endif /* FEATURE_VOICE_RECORD*/
}
#endif /* MSMAUD_VOC_AMR_COMMON */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GRAPH_AUDIO_ENC_ISR

DESCRIPTION
  This function processes the audio decoder interrupts for graphics images.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_graph_audio_enc_isr ( void )
{

  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_MP4E_13K_DEFINED) || \
    defined(QDSP_IMAGE_MP4E_EVRC_DEFINED)
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef FEATURE_GRAPH_ADPCM
      if(qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED) {
        qdsp_cmd_graph_adpcm_send_frame();
      }
#endif /* FEATURE_GRAPH_ADPCM */
      qdsp_cmd_graph_1x_enc_isr();
      break;
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED || QDSP_IMAGE_MP4E_EVRC_DEFINED */


#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
#ifdef FEATURE_GRAPH_ADPCM
      if(qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED) {
        qdsp_cmd_graph_adpcm_send_frame();
      }
#endif /* FEATURE_GRAPH_ADPCM */
      qdsp_cmd_graph_amr_enc_isr();
      break;
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */

#if defined(QDSP_IMAGE_MP4E_DEFINED)       || \
    defined(QDSP_IMAGE_MP4E_BAYER_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED)
#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
#endif /* QDSP_IMAGE_QCAMCORDER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#ifdef FEATURE_GRAPH_ADPCM
      if(qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED) {
        qdsp_cmd_graph_adpcm_send_frame();
      }
#endif /* FEATURE_GRAPH_ADPCM */
      if((qdsp_voc_mode == QDSP_VOC_MODE_IS733_V) ||
         (qdsp_voc_mode == QDSP_VOC_MODE_IS127_V)) {
        qdsp_cmd_graph_1x_enc_isr();
      }
#ifdef MSMAUD_VOC_AMR_COMMON
      else if (qdsp_voc_mode == QDSP_VOC_MODE_AMR_V) {
        qdsp_cmd_graph_amr_enc_isr();
      }
#endif /* MSMAUD_VOC_AMR_COMMON */
      break;
#endif /* QDSP_IMAGE_MP4E_DEFINED || QDSP_IMAGE_MP4E_BAYER_DEFINED */

    default:
      MSG_ERROR("Undefined image %d",qdsp_cmd_image_select,0,0);
      break;
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GRAPH_AUDIO_DEC_ISR

DESCRIPTION
  This function processes the audio decoder interrupts for graphics images.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_graph_audio_dec_isr ( void )
{

/* A2DP support for for NB-AMR */
#if defined (FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
    /* Process arm post process interrupt */
    qdsp_cmd_arm_pp_isr();
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

  switch(qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_VFE_BAYER_DEFINED) || \
    defined(QDSP_IMAGE_VFE_YCBCR_DEFINED)
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
#endif
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
#endif
#ifdef FEATURE_GRAPH_ADPCM
      if(qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED) {
        qdsp_cmd_graph_adpcm_send_frame();
      }
#endif /* FEATURE_GRAPH_ADPCM */
      break;
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED || QDSP_IMAGE_VFE_BAYER_DEFINED */

#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
#ifdef FEATURE_GRAPH_ADPCM
      if(qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED) {
        qdsp_cmd_graph_adpcm_send_frame();
      }
#endif /* FEATURE_GRAPH_ADPCM */
      qdsp_cmd_graph_1x_dec_isr();
      break;
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */

#if defined(QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED) || \
    defined(QDSP_IMAGE_QTV_DEFINED)||\
    defined(QDSP_IMAGE_QTV_VOC_H264_DEFINED) ||\
    defined(QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED)
#ifdef QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED
    case QDSP_IMAGE_MP4D_AMR_EVRC_V13K:
#endif
#ifdef QDSP_IMAGE_QTV_DEFINED
    case QDSP_IMAGE_QTV:
#endif
#ifdef QDSP_IMAGE_QTV_VOC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED
#error code not present
#endif
      if((qdsp_voc_mode == QDSP_VOC_MODE_IS733_V) ||
#ifdef MSMAUD_VOC_4GV
         (qdsp_voc_mode == QDSP_VOC_MODE_4GV_V) ||
#endif  /* MSMAUD_VOC_4GV */
         (qdsp_voc_mode == QDSP_VOC_MODE_IS127_V)) {
        qdsp_cmd_graph_1x_dec_isr();
      }
#ifdef MSMAUD_VOC_AMR_COMMON
      else if (qdsp_voc_mode == QDSP_VOC_MODE_AMR_V) {
        qdsp_cmd_graph_amr_dec_isr();
      }
#endif /* MSMAUD_VOC_AMR_COMMON */

#ifdef QDSP_idleMeterIsrMssg
	 /*check for the qdsp interrupt variable and  print qdsp variables
	   minidlecount and avgidle count....calculate the adsp utilisation \
	   variables adn print..*/
	  if (qdsp_read(QDSP_idleMeterIsrMssg) == 1)
      {
		 int maxidlevar,avgidlevar;
		 float worstadspvar,avgadspvar;
		 uint32 minvar =  qdsp_read(QDSP_minIdleCount);
		 uint32 avgvar =  qdsp_read(QDSP_avgIdleCount);
		 /* printing the qdsp idlemetering count variables */
		 MSG_HIGH("Idle Metering: minIdleCount = %u, avgIdleCount = %u", \
				  minvar, avgvar,0);
		 /* calculation to find adsp utilisation */
		 worstadspvar =  minvar/((qdsp_read(QDSP_idleMeterScaleFactor)+1) \
			             *(float)65536);
		 avgadspvar =	 avgvar/((qdsp_read(QDSP_idleMeterScaleFactor)+1) \
			            *(float)65536);
		 maxidlevar = (1-worstadspvar)*100;
		 avgidlevar = (1-avgadspvar)*100;
		 /* printing the adsp utilisation values */
		 MSG_HIGH( \
		 "ADSP Utilzation in percentage:Worst Case = %d,Average = %d\n", \
		  maxidlevar ,avgidlevar,0);
         /* disable the qdsp interrupt variable */
		 qdsp_write(QDSP_idleMeterIsrMssg, 0);
      }
#endif // #ifdef QDSP_idleMeterIsrMssg
      break;
#endif /* QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED */

    default:
      MSG_ERROR("Undefined image %d",qdsp_cmd_image_select,0,0);
      break;
  }
} /* qdsp_cmd_graph_audio_qdsp2_isr() */
#endif /* FEATURE_GRAPH_AUDIO */

/* <EJECT> */
#if defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_EFR)
#error code not present
#endif  /* MSMAUD_VOC_FR || MSMAUD_VOC_EFR */

/* <EJECT> */
#if defined(MSMAUD_VOC_AMR_WB) || defined(MSMAUD_VOC_AMR) \
    || defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_FR)  \
    || defined(MSMAUD_VOC_HR)

/*===========================================================================

FUNCTION QDSP_CMD_EFW2DFW

DESCRIPTION
  This function modifies the encFlagWord to make it a decFlagWord.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
uint16 qdsp_cmd_efw2dfw(uint16 efw)
{
  uint16 dfw = 0;

  switch (qdsp_voc_mode)
  {
#if defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_FR)
#error code not present
#endif /* defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_FR) */

#ifdef MSMAUD_VOC_HR
    case QDSP_VOC_MODE_GSM_HR_V:
      dfw = efw & (QDSP_GSM_HR_RX_SP_M | QDSP_GSM_RX_BFI_M);
      break;
#endif  /* MSMAUD_VOC_HR */

#ifdef MSMAUD_VOC_AMR
    case QDSP_VOC_MODE_AMR_V:
      /* Convert frame type, codec mode */
      switch (efw & QDSP_AMR_FRAME_TYPE_M)
      {
        case QDSP_AMR_TX_SPEECH_V:
          dfw = QDSP_AMR_RX_SPEECH_GOOD_V;
          break;
        case QDSP_AMR_TX_SID_FIRST_V:
          dfw = QDSP_AMR_RX_SID_FIRST_V;
          break;
        case QDSP_AMR_TX_SID_UPDATE_V:
          dfw = QDSP_AMR_RX_SID_UPDATE_V;
          break;
        case QDSP_AMR_TX_NO_DATA_V:
        default:
          dfw = QDSP_AMR_RX_NO_DATA_V;
          break;
      }
      dfw |= (efw & QDSP_AMR_CODEC_MODE_M);
      break;
#endif  /* MSMAUD_VOC_AMR */

#ifdef MSMAUD_VOC_AMR_WB_COMMON
    case QDSP_VOC_MODE_AMR_WB_V:
      /* Convert frame type, codec mode */
      switch (efw & QDSP_AMR_WB_FRAME_TYPE_M)
      {
        case QDSP_AMR_WB_TX_SPEECH_V:
          dfw = QDSP_AMR_WB_RX_SPEECH_GOOD_V;
          break;
        case QDSP_AMR_WB_TX_SID_FIRST_V:
          dfw = QDSP_AMR_WB_RX_SID_FIRST_V;
          break;
        case QDSP_AMR_WB_TX_SID_UPDATE_V:
          dfw = QDSP_AMR_WB_RX_SID_UPDATE_V;
          break;
        case QDSP_AMR_WB_TX_NO_DATA_V:
        default:
          dfw = QDSP_AMR_WB_RX_NO_DATA_V;
          break;
      }
      dfw |= (efw & QDSP_AMR_WB_CODEC_MODE_M);
      break;
#endif  /* MSMAUD_VOC_AMR_WB_COMMON */
  }
  return(dfw);
}

#endif  /* MSMAUD_VOC_AMR_WB || MSMAUD_VOC_AMR || MSMAUD_VOC_EFR
           || MSMAUD_VOC_FR || MSMAUD_VOC_HR */



/* <EJECT> */
#ifdef MSMAUD_VOC_AMR_WB_COMMON
/*===========================================================================

FUNCTION QDSP_CMD_AMR_WB_ENC_ISR

DESCRIPTION
  This function processes the AMR_WB vocoders encoder interrupts.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  rx_tx_packet_p : stored tx packet of voice playback
  vp_enc_flag_p : stored corresponding encFlagWord value
  play_vp_on_both_p : if voice playback on both encoder and decoder.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_amr_wb_enc_isr(uint16 **rx_tx_packet_p, uint16 *vp_enc_flag_p,
                             boolean *play_vp_on_both_p)
{
  uint16 enc_flag;
  uint16 amr_wb_packet_length = 0;

#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */


#ifdef FEATURE_VOICE_PLAYBACK
  if(qdsp_cmd_vp_tx_playing && (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_TX) &&
     (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_BOTH)){
    *play_vp_on_both_p
      = qdsp_cmd_get_vp_tx_frame(vp_enc_flag_p, rx_tx_packet_p);
    enc_flag = *vp_enc_flag_p;
  } else
#endif  /* FEATURE_VOICE_PLAYBACK */
  enc_flag = qdsp_read(QDSP_encFlagWord);

  /* Extract frame rate, ID from enc flag */
  qdsp_cmd_amr_wb_enc_frame_rate = (qdsp_cmd_amr_wb_frame_rate_type)
                                   (enc_flag & QDSP_AMR_WB_CODEC_MODE_M);

  /* Drop the first X packets from FR/EFR/HR/AMR_WB vocoders */
  if((qdsp_cmd_voc_enc_pkt_drop > 0)
#ifdef FEATURE_VOICE_PLAYBACK
     && !qdsp_cmd_vp_tx_playing
#endif /* FEATURE_VOICE_PLAYBACK */
     ) {
    qdsp_cmd_voc_enc_pkt_drop--;

    /* handshaking and statistics */
    qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

    /* Do not deliver a packet anywhere */
    return;
  } else {
    /* Otherwise, get ready to read the frame */
    switch(enc_flag & QDSP_AMR_WB_FRAME_TYPE_M) {
      case QDSP_AMR_WB_TX_SPEECH_V:
        qdsp_cmd_amr_wb_enc_frame_id = QDSP_AMR_WB_SPEECH_GOOD;
        /* Set packet length to expected length based on rate */
        amr_wb_packet_length
        = QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_amr_wb_enc_frame_rate);
        break;

      case QDSP_AMR_WB_TX_SID_FIRST_V:
        qdsp_cmd_amr_wb_enc_frame_id = QDSP_AMR_WB_SID_FIRST;
        amr_wb_packet_length = PACKET_SIZE_AMR_WB_SID;
        break;

      case QDSP_AMR_WB_TX_SID_UPDATE_V:
        qdsp_cmd_amr_wb_enc_frame_id = QDSP_AMR_WB_SID_UPDATE;
        amr_wb_packet_length = PACKET_SIZE_AMR_WB_SID;
        break;

      case QDSP_AMR_WB_TX_NO_DATA_V:
        qdsp_cmd_amr_wb_enc_frame_id = QDSP_AMR_WB_NO_DATA;
        amr_wb_packet_length = PACKET_SIZE_AMR_WB_BAD;
        break;

      default :
        ERR("Invalid AMR_WB encoder frame type, encFlagWord: %x",
            enc_flag, 0, 0);
        /* default to QDSP_AMR_WB_NO_DATA */
        qdsp_cmd_amr_wb_enc_frame_id = QDSP_AMR_WB_NO_DATA;
        amr_wb_packet_length = 0;
    }
  }

  /* prepare packet for TX */
#ifdef FEATURE_VOICE_PLAYBACK
 if(qdsp_cmd_vp_tx_playing && (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_TX) &&
     (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_BOTH)){
    if(amr_wb_packet_length != 0) {
      swap((byte *)(*rx_tx_packet_p),
           (byte *)qdsp_cmd_tx_packet,
           amr_wb_packet_length);
    }
  } else
#endif /* FEATURE_VOICE_PLAYBACK */
  {
    qdsp_block_read(QDSP_encPacketBuf, 0, qdsp_cmd_tx_packet,
                    amr_wb_packet_length, FALSE);

#ifdef FEATURE_VOICE_RECORD
    /* Only record valid frames */
    if(((qdsp_cmd_rec_dir == QDSP_CMD_REC_REVERSE) ||
        (qdsp_cmd_rec_dir == QDSP_CMD_REC_BOTH)) &&
       ((qdsp_cmd_amr_wb_enc_frame_rate >= qdsp_cmd_rec_min_frame_rate) &&
        (qdsp_cmd_amr_wb_enc_frame_rate <= qdsp_cmd_rec_max_frame_rate)))
    {
      swap((byte *)qdsp_cmd_tx_packet,
           (byte *)qdsp_cmd_temp_packet,
           amr_wb_packet_length);
      qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_REVERSE,
                    qdsp_cmd_amr_wb_enc_frame_rate |
                    (qdsp_cmd_amr_wb_enc_frame_id & QDSP_AMR_WB_FRAME_TYPE_M),
                    amr_wb_packet_length,
                    qdsp_cmd_temp_packet);
    }
#endif  /* FEATURE_VOICE_RECORD */
  }


  /* handshaking and statistics */
  qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

  qdsp_cmd_gsm_encoded_pkt_cnt++;

  /* unread encoded packet is overridden */
  if (qdsp_cmd_enc_semaphore_flag != 0)
  {
    qdsp_cmd_gsm_enc_lost_cnt++;
  }

  qdsp_cmd_enc_semaphore_flag = 1;       /* notify qdsp_cmd_amr_wb_tx_packet */


  /* Perform packet logging here */
#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */


#ifdef FEATURE_MVS
  if (amr_wb_uplink_func!=NULL)
  {
    qdsp_cmd_enc_semaphore_flag = 0;       /* acknowledged */

    amr_wb_uplink_func(qdsp_cmd_tx_packet,
                    qdsp_cmd_amr_wb_enc_frame_id,
                    qdsp_cmd_amr_wb_enc_frame_rate);
  }
#endif  /* FEATURE_MVS */
}  /* qdsp_cmd_amr_wb_enc_isr */


/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_AMR_WB_DEC_ISR

DESCRIPTION
  This function processes the AMR_WB vocoders decoder interrupts.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_amr_wb_dec_isr(uint16 *rx_tx_pkt, uint16 vp_enc_flag,
                             boolean vp_on_both)
{
  uint16 dec_flag;
  static qdsp_cmd_amr_wb_frame_rate_type amr_wb_last_dec_rate
                                         = QDSP_AMR_WB_RATE_0660;
  uint16 amr_wb_packet_length = 0;

  /* Variables to support mixing playback with voice */
#ifdef FEATURE_VOICE_PLAYBACK
  qdsp_cmd_amr_wb_frame_type temp_frame_id = QDSP_AMR_WB_NO_DATA;
  qdsp_cmd_amr_wb_frame_rate_type temp_frame_rate = QDSP_AMR_WB_RATE_0660;
  uint16 amr_wb_sec_dec_packet_length = 0;
  uint16 temp_packet_length = 0;
  static qdsp_cmd_amr_wb_frame_rate_type amr_wb_last_sec_dec_rate
                                         = QDSP_AMR_WB_RATE_0660;
  uint16 sec_dec_flag;
#endif /* FEATURE_VOICE_PLAYBACK */

#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */


#ifdef FEATURE_MVS
  if (amr_wb_downlink_func!=NULL)
  {
    amr_wb_downlink_func(qdsp_cmd_rx_packet,
                      &qdsp_cmd_amr_wb_dec_frame_id,
                      &qdsp_cmd_amr_wb_dec_frame_rate);

    amr_wb_packet_length = QDSP_CMD_AMR_WB_PACKET_LENGTH;
    qdsp_cmd_dec_semaphore_flag = 1;        /* decoding packet provided */
  }
#endif  /* FEATURE_MVS */


#ifdef FEATURE_VOICE_RECORD
  if(((qdsp_cmd_rec_dir == QDSP_CMD_REC_FORWARD) ||
      (qdsp_cmd_rec_dir == QDSP_CMD_REC_BOTH)) &&
     ((qdsp_cmd_amr_wb_dec_frame_rate >= QDSP_AMR_WB_RATE_0660) &&
      (qdsp_cmd_amr_wb_dec_frame_rate <= QDSP_AMR_WB_RATE_2385)))
  {
    /* Determine packet length based on frame type */
    switch(qdsp_cmd_amr_wb_dec_frame_id) {
      case QDSP_AMR_WB_SPEECH_GOOD:
      case QDSP_AMR_WB_SPEECH_DEGRADED:
      case QDSP_AMR_WB_SPEECH_BAD:
      case QDSP_AMR_WB_ONSET:
        /* Set packet length to expected length based on rate */
        amr_wb_packet_length =
          QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_amr_wb_dec_frame_rate);
      break;

      case QDSP_AMR_WB_SID_FIRST:
      case QDSP_AMR_WB_SID_UPDATE:
      case QDSP_AMR_WB_SID_BAD:
        amr_wb_packet_length = PACKET_SIZE_AMR_WB_SID;
      break;

      case QDSP_AMR_WB_NO_DATA:
      case QDSP_AMR_WB_SPEECH_LOST:
      default:
        amr_wb_packet_length = PACKET_SIZE_AMR_WB_BAD;
          break;
    }

    swap((byte *)qdsp_cmd_rx_packet,
         (byte *)qdsp_cmd_temp_packet,
         amr_wb_packet_length);

    qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_FORWARD,
                          qdsp_cmd_amr_wb_dec_frame_rate |
                          (qdsp_cmd_amr_wb_dec_frame_id & QDSP_AMR_WB_FRAME_TYPE_M),
                          amr_wb_packet_length,
                          qdsp_cmd_temp_packet);
  }
#endif /* FEATURE_VOICE_RECORD */


#ifdef FEATURE_VOICE_PLAYBACK
  if(vp_on_both){
    if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH)
    {
      qdsp_cmd_get_vp_tx_frame(&dec_flag, &rx_tx_pkt);
    }
    else
    {
      /* Ignore decoder flag word,
      ** convert encoder flag word into decoder flag word.
      */
      dec_flag = qdsp_cmd_efw2dfw(vp_enc_flag);
    }
  } else if (qdsp_cmd_vp_rx_playing) {
    /* Incoming frame rate is decoder formatted */
    qdsp_cmd_get_vp_rx_frame_wrap(&dec_flag, &rx_tx_pkt);
  } else if(qdsp_cmd_vp_tx_playing &&
          ((qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_TX) ||
          (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH))){
    qdsp_cmd_get_vp_tx_frame(&dec_flag, &rx_tx_pkt);

  } else if ((qdsp_cmd_vp_paused) && (!qdsp_cmd_vp_incall_mux_pause) &&
             (qdsp_cmd_vp_direction == QDSP_CMD_VP_RX)) {
    /* Playback is paused and we are not doing an incall mux. We need
    to write erasure to primary decoder */
    qdsp_cmd_amr_wb_dec_frame_id = QDSP_AMR_WB_TX_NO_DATA_V;
    qdsp_cmd_amr_wb_dec_frame_rate = amr_wb_last_dec_rate;
    amr_wb_packet_length = PACKET_SIZE_AMR_WB_BAD;
    qdsp_cmd_dec_semaphore_flag = 1;
  }

  if ((vp_on_both) || (qdsp_cmd_vp_rx_playing) || (qdsp_cmd_vp_incall_mux)) {

    if (qdsp_cmd_vp_incall_mux)
      {
      temp_frame_id = qdsp_cmd_amr_wb_dec_frame_id;
      temp_frame_rate = qdsp_cmd_amr_wb_dec_frame_rate;
      temp_packet_length = amr_wb_packet_length;
    }
    /* Extract frame rate, ID from dec flag */
    qdsp_cmd_amr_wb_dec_frame_id
      = (qdsp_cmd_amr_wb_frame_type)(dec_flag & QDSP_AMR_WB_FRAME_TYPE_M);
    qdsp_cmd_amr_wb_dec_frame_rate
      = (qdsp_cmd_amr_wb_frame_rate_type)(dec_flag & QDSP_AMR_WB_CODEC_MODE_M);

    /* Determine packet length based on frame type */
    switch(qdsp_cmd_amr_wb_dec_frame_id) {
      case QDSP_AMR_WB_SPEECH_GOOD:
      case QDSP_AMR_WB_SPEECH_DEGRADED:
      case QDSP_AMR_WB_SPEECH_BAD:
      case QDSP_AMR_WB_ONSET:
        /* Set packet length to expected length based on rate */
        amr_wb_packet_length =
          QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_amr_wb_dec_frame_rate);
          break;

      case QDSP_AMR_WB_SID_FIRST:
      case QDSP_AMR_WB_SID_UPDATE:
      case QDSP_AMR_WB_SID_BAD:
        amr_wb_packet_length = PACKET_SIZE_AMR_WB_SID;
          break;

      case QDSP_AMR_WB_NO_DATA:
      case QDSP_AMR_WB_SPEECH_LOST:
        default:
        amr_wb_packet_length = PACKET_SIZE_AMR_WB_BAD;
          break;
      }

    /* Swap bytes in the vocoder packet */

    if (qdsp_cmd_vp_incall_mux)
    {
      qdsp_cmd_amr_wb_sec_dec_frame_id = qdsp_cmd_amr_wb_dec_frame_id;
      qdsp_cmd_amr_wb_sec_dec_frame_rate = qdsp_cmd_amr_wb_dec_frame_rate;
      amr_wb_sec_dec_packet_length = amr_wb_packet_length;

      qdsp_cmd_amr_wb_dec_frame_id  = temp_frame_id;
      qdsp_cmd_amr_wb_dec_frame_rate = temp_frame_rate ;
      amr_wb_packet_length = temp_packet_length ;

      swap((byte *)rx_tx_pkt,
           (byte *)qdsp_cmd_sec_dec_rx_packet,
           amr_wb_sec_dec_packet_length);
  }
    else
    {
      swap((byte *)rx_tx_pkt, (byte *)qdsp_cmd_rx_packet, amr_wb_packet_length);
    }

    qdsp_cmd_dec_semaphore_flag = 1;
}
#endif /* FEATURE_VOICE_PLAYBACK */


  /* check if rx packet available yet */
  if (qdsp_cmd_dec_semaphore_flag == 0)
  {
    dec_flag = (uint16)(QDSP_AMR_WB_SPEECH_BAD & QDSP_AMR_WB_FRAME_TYPE_M)
               | (uint16)(amr_wb_last_dec_rate & QDSP_AMR_WB_CODEC_MODE_M);

    qdsp_write(QDSP_decFlagWord, dec_flag);

    /* statistics */
#ifdef FEATURE_VOICE_PLAYBACK
    if(qdsp_cmd_vp_incall_mux)
    {
      dec_flag = (uint16)(QDSP_AMR_WB_SPEECH_BAD & QDSP_AMR_WB_FRAME_TYPE_M)
               | (uint16)(amr_wb_last_sec_dec_rate & QDSP_AMR_WB_CODEC_MODE_M);

      qdsp_write(QDSP_secondDecPacketRate, dec_flag);
    }
#endif /* FEATURE_VOICE_PLAYBACK */
    qdsp_cmd_gsm_dec_miss_cnt++;
                         /* times when rx packets are unavailable */
  }
  else
  {
#ifdef FEATURE_VOICE_PLAYBACK
    if (qdsp_cmd_vp_incall_mux)
    {
      if ((qdsp_cmd_amr_wb_sec_dec_frame_id < QDSP_AMR_WB_SPEECH_GOOD)
          || (qdsp_cmd_amr_wb_sec_dec_frame_id > QDSP_AMR_WB_ONSET))
      {
        ERR("Invalid AMR_WB decoder frame type for second decoder%x",
            (uint16)qdsp_cmd_amr_wb_sec_dec_frame_id, 0, 0);

        /* default to QDSP_AMR_WB_SPEECH_BAD */
        qdsp_cmd_amr_wb_sec_dec_frame_id = QDSP_AMR_WB_SPEECH_BAD;
      }
      if ((qdsp_cmd_amr_wb_sec_dec_frame_rate < QDSP_AMR_WB_RATE_0660)
          || (qdsp_cmd_amr_wb_sec_dec_frame_rate > QDSP_AMR_WB_RATE_2385))
      {
        ERR("Invalid AMR_WB decoder frame rate for second decoder %x",
            (uint16)qdsp_cmd_amr_wb_sec_dec_frame_rate, 0, 0);

        /* default to last AMR_WB decoder rate
           and set codec mode to QDSP_AMR_WB_SPEECH_BAD */
        qdsp_cmd_amr_wb_sec_dec_frame_rate = amr_wb_last_sec_dec_rate;
        qdsp_cmd_amr_wb_sec_dec_frame_id = QDSP_AMR_WB_SPEECH_BAD;
      }
      amr_wb_last_sec_dec_rate = qdsp_cmd_amr_wb_sec_dec_frame_rate;
      sec_dec_flag = ((uint16)qdsp_cmd_amr_wb_sec_dec_frame_id &
                      QDSP_AMR_WB_FRAME_TYPE_M) |
                      ((uint16)qdsp_cmd_amr_wb_sec_dec_frame_rate &
                       QDSP_AMR_WB_CODEC_MODE_M);

      if (!qdsp_cmd_second_dec_configured)
      {
        qdsp_cmd_second_dec_configured = TRUE;
        qdsp_write(QDSP_secondDecoderConfig, qdsp_cmd_second_dec_config);
        if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_RX)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
        }
        else if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_TX)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
          qdsp_write(QDSP_memoPlaybackTxMux,
                     QDSP_CMD_SECOND_DEC_TX_MUX_ENA_V);
        }
        else if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
          qdsp_write(QDSP_memoPlaybackTxMux,
                     QDSP_CMD_SECOND_DEC_TX_MUX_ENA_V);
        }
        qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
      }

      qdsp_write(QDSP_secondDecPacketRate, sec_dec_flag);

      /* ===== Providing packet data to QDSP ===== */
      qdsp_block_write(QDSP_secondDecPacketBuf, 0, qdsp_cmd_sec_dec_rx_packet,
                       amr_wb_sec_dec_packet_length, FALSE);
    }
    else if (qdsp_cmd_second_dec_configured)
    {
      qdsp_cmd_second_dec_configured = FALSE;
      qdsp_write(QDSP_secondDecoderConfig,
                 QDSP_CMD_SECOND_DEC_CONFIG_NONE);
      qdsp_write(QDSP_decoderMemoPlaybackMux,
                 QDSP_CMD_SECOND_DEC_RX_MUX_DIS_V);
      qdsp_write(QDSP_memoPlaybackTxMux,
                 QDSP_CMD_SECOND_DEC_TX_MUX_DIS_V);
    }
#endif /* FEATURE_VOICE_PLAYBACK */

    /* ===== Packet Format Verification ===== */
    if ((qdsp_cmd_amr_wb_dec_frame_id < QDSP_AMR_WB_SPEECH_GOOD)
        || (qdsp_cmd_amr_wb_dec_frame_id > QDSP_AMR_WB_ONSET))
    {
      ERR("Invalid AMR_WB decoder frame type %x",
          (uint16)qdsp_cmd_amr_wb_dec_frame_id, 0, 0);

      /* default to QDSP_AMR_WB_SPEECH_BAD */
      qdsp_cmd_amr_wb_dec_frame_id = QDSP_AMR_WB_SPEECH_BAD;
    }

    if ((qdsp_cmd_amr_wb_dec_frame_rate < QDSP_AMR_WB_RATE_0660)
        || (qdsp_cmd_amr_wb_dec_frame_rate > QDSP_AMR_WB_RATE_2385))
    {
      ERR("Invalid AMR_WB decoder frame rate %x",
          (uint16)qdsp_cmd_amr_wb_dec_frame_rate, 0, 0);

      /* default to last AMR_WB decoder rate
         and set codec mode to QDSP_AMR_WB_SPEECH_BAD */
      qdsp_cmd_amr_wb_dec_frame_rate = amr_wb_last_dec_rate;
      qdsp_cmd_amr_wb_dec_frame_id = QDSP_AMR_WB_SPEECH_BAD;
  }

    /* Record last AMR_WB decoder rate for erasure usage */
    amr_wb_last_dec_rate = qdsp_cmd_amr_wb_dec_frame_rate;

    dec_flag = ((uint16)qdsp_cmd_amr_wb_dec_frame_id
                & QDSP_AMR_WB_FRAME_TYPE_M)
               | ((uint16)qdsp_cmd_amr_wb_dec_frame_rate
                  & QDSP_AMR_WB_CODEC_MODE_M);

#ifdef FEATURE_VOICE_PLAYBACK
    if (qdsp_cmd_vp_paused && qdsp_cmd_vp_incall_mux_pause)
    {
      /* We are paused but we were doing an incall mux and so
      voice call is still on, we need to disable comfort noise */
      qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
}
#endif /* FEATURE_VOICE_PLAYBACK */

    qdsp_write(QDSP_decFlagWord, dec_flag);    /* write the final value */

    /* ===== Providing packet data to QDSP ===== */
    qdsp_block_write(QDSP_decPacketBuf, 0, qdsp_cmd_rx_packet,
                     amr_wb_packet_length, FALSE);
  }   /* if (qdsp_cmd_dec_semaphore_flag == 0) else */


  /* ===== handshaking & statistics ===== */
  qdsp_cmd_dec_semaphore_flag = 0;     /* notify qdsp_cmd_amr_wb_rx_packet */
  qdsp_write(QDSP_decPacketReg, 0);    /* notify QDSP firmware */

  qdsp_cmd_gsm_decoded_pkt_cnt++;


  /* Perform packet logging here */
#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */
}  /* qdsp_cmd_amr_wb_dec_isr */

#endif  /* MSMAUD_VOC_AMR_WB_COMMON */


/* <EJECT> */
#ifdef MSMAUD_VOC_AMR
/*===========================================================================

FUNCTION QDSP_CMD_AMR_ENC_ISR

DESCRIPTION
  This function processes the AMR vocoders encoder interrupts.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  rx_tx_packet_p : stored tx packet of voice playback
  vp_enc_flag_p : stored corresponding encFlagWord value
  play_vp_on_both_p : if voice playback on both encoder and decoder.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_amr_enc_isr(uint16 **rx_tx_packet_p, uint16 *vp_enc_flag_p,
                          boolean *play_vp_on_both_p)
{
  uint16 enc_flag;
  uint16 gsm_packet_length = 0;

#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */


#ifdef FEATURE_VOICE_PLAYBACK
  if(qdsp_cmd_vp_tx_playing && (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_TX) &&
     (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_BOTH)){
    *play_vp_on_both_p
      = qdsp_cmd_get_vp_tx_frame(vp_enc_flag_p, rx_tx_packet_p);
    enc_flag = *vp_enc_flag_p;
  } else
#endif  /* FEATURE_VOICE_PLAYBACK */
  enc_flag = qdsp_read(QDSP_encFlagWord);

  /* Extract frame rate, ID from enc flag */
  qdsp_cmd_gsm_enc_frame_rate = (qdsp_cmd_gsm_frame_rate_type)
                                (enc_flag & QDSP_AMR_CODEC_MODE_M);

  /* Drop the first X packets from FR/EFR/HR/AMR vocoders */
  if((qdsp_cmd_voc_enc_pkt_drop > 0)
#ifdef FEATURE_VOICE_PLAYBACK
     && !qdsp_cmd_vp_tx_playing
#endif /* FEATURE_VOICE_PLAYBACK */
     ) {
    qdsp_cmd_voc_enc_pkt_drop--;

    /* handshaking and statistics */
    qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

    /* Do not deliver a packet anywhere */
    return;
  } else {
    /* Otherwise, get ready to read the frame */
    switch(enc_flag & QDSP_AMR_FRAME_TYPE_M) {
      case QDSP_AMR_TX_SPEECH_V:
        qdsp_cmd_gsm_enc_frame_id = QDSP_AMR_SPEECH_GOOD;
        /* Set packet length to expected length based on rate */
        gsm_packet_length =
            QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_gsm_enc_frame_rate);
        break;

      case QDSP_AMR_TX_SID_FIRST_V:
        qdsp_cmd_gsm_enc_frame_id = QDSP_AMR_SID_FIRST;
        gsm_packet_length = PACKET_SIZE_AMR_SID;
        break;

      case QDSP_AMR_TX_SID_UPDATE_V:
        qdsp_cmd_gsm_enc_frame_id = QDSP_AMR_SID_UPDATE;
        gsm_packet_length = PACKET_SIZE_AMR_SID;
        break;

      case QDSP_AMR_TX_NO_DATA_V:
        qdsp_cmd_gsm_enc_frame_id = QDSP_AMR_NO_DATA;
        gsm_packet_length = PACKET_SIZE_AMR_BAD;
        break;

      default :
        ERR("Invalid AMR encoder frame type, encFlagWord: %x",
            enc_flag, 0, 0);
        /* default to QDSP_AMR_NO_DATA */
        qdsp_cmd_gsm_enc_frame_id = QDSP_AMR_NO_DATA;
        gsm_packet_length = 0;
    }
  }

  /* prepare packet for TX */
#ifdef FEATURE_VOICE_PLAYBACK
 if(qdsp_cmd_vp_tx_playing && (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_TX) &&
     (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_BOTH)){
    if(gsm_packet_length != 0) {
      swap((byte *)(*rx_tx_packet_p),
           (byte *)qdsp_cmd_tx_packet,
           gsm_packet_length);
    }
  } else
#endif /* FEATURE_VOICE_PLAYBACK */
  {
    qdsp_block_read(QDSP_encPacketBuf, 0, qdsp_cmd_tx_packet,
                    gsm_packet_length, FALSE);

#ifdef FEATURE_VOICE_RECORD
    /* Only record valid frames */
    if(((qdsp_cmd_rec_dir == QDSP_CMD_REC_REVERSE) ||
        (qdsp_cmd_rec_dir == QDSP_CMD_REC_BOTH)) &&
       ((qdsp_cmd_gsm_enc_frame_rate >= qdsp_cmd_rec_min_frame_rate) &&
        (qdsp_cmd_gsm_enc_frame_rate <= qdsp_cmd_rec_max_frame_rate)))
    {
#ifdef FEATURE_AMR_REC_HOMING_SEQUENCE
      /* If recording has just been resumed, insert a homing sequence
      ** in the recorded stream to avoid audio artifacts when recorded
      ** file is played back.
      */
      if (qdsp_cmd_reverse_recording_resumed) {

		/* Avoid out of bound array access */
		if(qdsp_cmd_gsm_enc_frame_rate > QDSP_AMR_RATE_1220)
		{
		  MSG_ERROR("Invalid AMR framerate: %d", qdsp_cmd_gsm_enc_frame_rate, 0, 0);
		}
		else
		{
          swap((byte *)qdsp_cmd_amr_homing_sequences[qdsp_cmd_gsm_enc_frame_rate],
               (byte *)qdsp_cmd_temp_packet,
                QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_gsm_enc_frame_rate));

          qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_REVERSE,
                                qdsp_cmd_gsm_enc_frame_rate |
                                QDSP_AMR_SPEECH_GOOD,
                                QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_gsm_enc_frame_rate),
                                qdsp_cmd_temp_packet);

          qdsp_cmd_reverse_recording_resumed = FALSE;
		}
      }
#endif /* FEATURE_AMR_REC_HOMING_SEQUENCE */

      swap((byte *)qdsp_cmd_tx_packet,
           (byte *)qdsp_cmd_temp_packet,
           gsm_packet_length);
      qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_REVERSE,
                            qdsp_cmd_gsm_enc_frame_rate |
                            (qdsp_cmd_gsm_enc_frame_id & QDSP_AMR_FRAME_TYPE_M),
                            gsm_packet_length,
                            qdsp_cmd_temp_packet);
    }
#endif  /* FEATURE_VOICE_RECORD */
  }


  /* handshaking and statistics */
  qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

  qdsp_cmd_gsm_encoded_pkt_cnt++;

  /* unread encoded packet is overridden */
  if (qdsp_cmd_enc_semaphore_flag != 0)
  {
    qdsp_cmd_gsm_enc_lost_cnt++;
  }

  qdsp_cmd_enc_semaphore_flag = 1;       /* notify qdsp_cmd_gsm_tx_packet */


  /* Perform packet logging here */
#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */


#ifdef FEATURE_MVS
  if (amr_uplink_func!=NULL)
  {
    qdsp_cmd_enc_semaphore_flag = 0;       /* acknowledged */

    amr_uplink_func(qdsp_cmd_tx_packet,
                    qdsp_cmd_gsm_enc_frame_id,
                    qdsp_cmd_gsm_enc_frame_rate);
  }
#endif  /* FEATURE_MVS */
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_AMR_DEC_ISR

DESCRIPTION
  This function processes the AMR vocoders decoder interrupts.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_amr_dec_isr(uint16 *rx_tx_pkt, uint16 vp_enc_flag,
                          boolean vp_on_both)
{
  uint16 dec_flag = 0;
  static qdsp_cmd_gsm_frame_rate_type amr_last_dec_rate = QDSP_AMR_RATE_475;
  uint16 gsm_packet_length = 0;

  /* Variables to support mixing playback with voice */
#ifdef FEATURE_VOICE_PLAYBACK
  qdsp_cmd_gsm_frame_type temp_frame_id = QDSP_AMR_NO_DATA;
  qdsp_cmd_gsm_frame_rate_type temp_frame_rate = QDSP_AMR_RATE_475;
  uint16 gsm_sec_dec_packet_length = 0;
  uint16 temp_packet_length = 0;
  static qdsp_cmd_gsm_frame_rate_type amr_last_sec_dec_rate = QDSP_AMR_RATE_475;
  uint16 sec_dec_flag;
#endif /* FEATURE_VOICE_PLAYBACK */

#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */


#ifdef FEATURE_MVS
  if (amr_downlink_func!=NULL)
  {
    amr_downlink_func(qdsp_cmd_rx_packet,
                      &qdsp_cmd_gsm_dec_frame_id,
                      &qdsp_cmd_gsm_dec_frame_rate);

    gsm_packet_length = QDSP_CMD_GSM_PACKET_LENGTH;
    qdsp_cmd_dec_semaphore_flag = 1;        /* decoding packet provided */
  }
#endif  /* FEATURE_MVS */


#ifdef FEATURE_VOICE_RECORD
  if(((qdsp_cmd_rec_dir == QDSP_CMD_REC_FORWARD) ||
      (qdsp_cmd_rec_dir == QDSP_CMD_REC_BOTH)) &&
     ((qdsp_cmd_gsm_dec_frame_rate >= QDSP_AMR_RATE_475) &&
      (qdsp_cmd_gsm_dec_frame_rate <= QDSP_AMR_RATE_1220)))
  {
    /* Determine packet length based on frame type */
    switch(qdsp_cmd_gsm_dec_frame_id) {
      case QDSP_AMR_SPEECH_GOOD:
      case QDSP_AMR_SPEECH_DEGRADED:
      case QDSP_AMR_SPEECH_BAD:
      case QDSP_AMR_ONSET:
        /* Set packet length to expected length based on rate */
        gsm_packet_length =
          QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_gsm_dec_frame_rate);
        break;

      case QDSP_AMR_SID_FIRST:
      case QDSP_AMR_SID_UPDATE:
      case QDSP_AMR_SID_BAD:
        gsm_packet_length = PACKET_SIZE_AMR_SID;
        break;

      case QDSP_AMR_NO_DATA:
      default:
        gsm_packet_length = PACKET_SIZE_AMR_BAD;
        break;
    }

#ifdef FEATURE_AMR_REC_HOMING_SEQUENCE
      /* If recording has just been resumed, insert a homing sequence
      ** in the recorded stream to avoid audio artifacts when recorded
      ** file is played back.
      */
      if (qdsp_cmd_forward_recording_resumed) {

        swap((byte *)qdsp_cmd_amr_homing_sequences[qdsp_cmd_gsm_dec_frame_rate],
             (byte *)qdsp_cmd_temp_packet,
             QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_gsm_dec_frame_rate));

        qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_FORWARD,
                              qdsp_cmd_gsm_dec_frame_rate |
                              QDSP_AMR_SPEECH_GOOD,
                              QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_gsm_dec_frame_rate),
                              qdsp_cmd_temp_packet);

        qdsp_cmd_forward_recording_resumed = FALSE;
      }
#endif /* FEATURE_AMR_REC_HOMING_SEQUENCE */

    swap((byte *)qdsp_cmd_rx_packet,
         (byte *)qdsp_cmd_temp_packet,
         gsm_packet_length);

    qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_FORWARD,
                          qdsp_cmd_gsm_dec_frame_rate |
                          (qdsp_cmd_gsm_dec_frame_id & QDSP_AMR_FRAME_TYPE_M),
                          gsm_packet_length,
                          qdsp_cmd_temp_packet);
  }
#endif /* FEATURE_VOICE_RECORD */


#ifdef FEATURE_VOICE_PLAYBACK
  if(vp_on_both){
    if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH)
    {
      qdsp_cmd_get_vp_tx_frame(&dec_flag, &rx_tx_pkt);
    }
    else
    {
      /* Ignore decoder flag word,
      ** convert encoder flag word into decoder flag word.
      */
      dec_flag = qdsp_cmd_efw2dfw(vp_enc_flag);
    }
  } else if (qdsp_cmd_vp_rx_playing) {
    /* Incoming frame rate is decoder formatted */
    qdsp_cmd_get_vp_rx_frame_wrap(&dec_flag, &rx_tx_pkt);
  } else if(qdsp_cmd_vp_tx_playing &&
          ((qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_TX) ||
          (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH))){
    qdsp_cmd_get_vp_tx_frame(&dec_flag, &rx_tx_pkt);

  } else if ((qdsp_cmd_vp_paused) && (!qdsp_cmd_vp_incall_mux_pause) &&
             (qdsp_cmd_vp_direction == QDSP_CMD_VP_RX)) {
    /* Playback is paused and we are not doing an incall mux. We need
    to write erasure to primary decoder */
    qdsp_cmd_gsm_dec_frame_id = QDSP_AMR_TX_NO_DATA_V;
    qdsp_cmd_gsm_dec_frame_rate = amr_last_dec_rate;
    gsm_packet_length = PACKET_SIZE_AMR_BAD;
    qdsp_cmd_dec_semaphore_flag = 1;
  }

  if ((vp_on_both) || (qdsp_cmd_vp_rx_playing) || (qdsp_cmd_vp_incall_mux)) {

    if (qdsp_cmd_vp_incall_mux)
    {
      temp_frame_id = qdsp_cmd_gsm_dec_frame_id;
      temp_frame_rate = qdsp_cmd_gsm_dec_frame_rate;
      temp_packet_length = gsm_packet_length;
    }
    /* Extract frame rate, ID from dec flag */
    qdsp_cmd_gsm_dec_frame_id
      = (qdsp_cmd_gsm_frame_type)((dec_flag & QDSP_AMR_FRAME_TYPE_M) | 0xff);
    qdsp_cmd_gsm_dec_frame_rate
      = (qdsp_cmd_gsm_frame_rate_type)(dec_flag & QDSP_AMR_CODEC_MODE_M);

    /* Determine packet length based on frame type */
    switch(qdsp_cmd_gsm_dec_frame_id) {
      case QDSP_AMR_SPEECH_GOOD:
      case QDSP_AMR_SPEECH_DEGRADED:
      case QDSP_AMR_SPEECH_BAD:
      case QDSP_AMR_ONSET:
        /* Set packet length to expected length based on rate */
        gsm_packet_length =
          QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS(qdsp_cmd_gsm_dec_frame_rate);
        break;

      case QDSP_AMR_SID_FIRST:
      case QDSP_AMR_SID_UPDATE:
      case QDSP_AMR_SID_BAD:
        gsm_packet_length = PACKET_SIZE_AMR_SID;
        break;

      case QDSP_AMR_NO_DATA:
      default:
        gsm_packet_length = PACKET_SIZE_AMR_BAD;
        break;
    }

    /* Swap bytes in the vocoder packet */

    if (qdsp_cmd_vp_incall_mux)
    {
      qdsp_cmd_gsm_sec_dec_frame_id = qdsp_cmd_gsm_dec_frame_id;
      qdsp_cmd_gsm_sec_dec_frame_rate = qdsp_cmd_gsm_dec_frame_rate;
      gsm_sec_dec_packet_length = gsm_packet_length;

      qdsp_cmd_gsm_dec_frame_id  = temp_frame_id;
      qdsp_cmd_gsm_dec_frame_rate = temp_frame_rate ;
      gsm_packet_length = temp_packet_length ;

      swap((byte *)rx_tx_pkt,
           (byte *)qdsp_cmd_sec_dec_rx_packet,
           gsm_sec_dec_packet_length);
    }
    else
    {
      swap((byte *)rx_tx_pkt, (byte *)qdsp_cmd_rx_packet, gsm_packet_length);
    }

    qdsp_cmd_dec_semaphore_flag = 1;
  }
#endif /* FEATURE_VOICE_PLAYBACK */


  /* check if rx packet available yet */
  if (qdsp_cmd_dec_semaphore_flag == 0)
  {
    dec_flag = (uint16)(QDSP_AMR_SPEECH_BAD & QDSP_AMR_FRAME_TYPE_M)
               | (uint16)(amr_last_dec_rate & QDSP_AMR_CODEC_MODE_M);

    qdsp_write(QDSP_decFlagWord, dec_flag);

    /* statistics */
#ifdef FEATURE_VOICE_PLAYBACK
    if(qdsp_cmd_vp_incall_mux)
    {
      dec_flag = (uint16)(QDSP_AMR_SPEECH_BAD & QDSP_AMR_FRAME_TYPE_M)
                 | (uint16)(amr_last_sec_dec_rate & QDSP_AMR_CODEC_MODE_M);

      qdsp_write(QDSP_secondDecPacketRate, dec_flag);
    }
#endif /* FEATURE_VOICE_PLAYBACK */
    qdsp_cmd_gsm_dec_miss_cnt++;
                         /* times when rx packets are unavailable */
  }
  else
  {
#ifdef FEATURE_VOICE_PLAYBACK
    if (qdsp_cmd_vp_incall_mux)
    {
      if ((qdsp_cmd_gsm_sec_dec_frame_id < QDSP_AMR_SPEECH_GOOD)
          || (qdsp_cmd_gsm_sec_dec_frame_id > QDSP_AMR_NO_DATA))
      {
        ERR("Invalid AMR decoder frame type for second decoder%x",
            (uint16)qdsp_cmd_gsm_sec_dec_frame_id, 0, 0);

        /* default to QDSP_AMR_SPEECH_BAD */
        qdsp_cmd_gsm_sec_dec_frame_id = QDSP_AMR_SPEECH_BAD;
      }
      if ((qdsp_cmd_gsm_sec_dec_frame_rate < QDSP_AMR_RATE_475)
          || (qdsp_cmd_gsm_sec_dec_frame_rate > QDSP_AMR_RATE_1220))
      {
        ERR("Invalid AMR decoder frame rate for second decoder %x",
            (uint16)qdsp_cmd_gsm_sec_dec_frame_rate, 0, 0);

        /* default to last AMR decoder rate
           and set codec mode to QDSP_AMR_SPEECH_BAD */
        qdsp_cmd_gsm_sec_dec_frame_rate = amr_last_sec_dec_rate;
        qdsp_cmd_gsm_sec_dec_frame_id = QDSP_AMR_SPEECH_BAD;
      }
      amr_last_sec_dec_rate = qdsp_cmd_gsm_sec_dec_frame_rate;
      sec_dec_flag = ((uint16)qdsp_cmd_gsm_sec_dec_frame_id &
                      QDSP_AMR_FRAME_TYPE_M) |
                      ((uint16)qdsp_cmd_gsm_sec_dec_frame_rate &
                       QDSP_AMR_CODEC_MODE_M);

      if (!qdsp_cmd_second_dec_configured)
      {
        qdsp_cmd_second_dec_configured = TRUE;
        qdsp_write(QDSP_secondDecoderConfig, qdsp_cmd_second_dec_config);
        if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_RX)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
        }
        else if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_TX)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
          qdsp_write(QDSP_memoPlaybackTxMux,
                     QDSP_CMD_SECOND_DEC_TX_MUX_ENA_V);
        }
        else if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
          qdsp_write(QDSP_memoPlaybackTxMux,
                     QDSP_CMD_SECOND_DEC_TX_MUX_ENA_V);
        }
        qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
      }

      qdsp_write(QDSP_secondDecPacketRate, sec_dec_flag);

      /* ===== Providing packet data to QDSP ===== */
      qdsp_block_write(QDSP_secondDecPacketBuf, 0, qdsp_cmd_sec_dec_rx_packet,
                       gsm_sec_dec_packet_length, FALSE);
    }
    else if (qdsp_cmd_second_dec_configured)
    {
      qdsp_cmd_second_dec_configured = FALSE;
      qdsp_write(QDSP_secondDecoderConfig,
                 QDSP_CMD_SECOND_DEC_CONFIG_NONE);
      qdsp_write(QDSP_decoderMemoPlaybackMux,
                 QDSP_CMD_SECOND_DEC_RX_MUX_DIS_V);
      qdsp_write(QDSP_memoPlaybackTxMux,
                 QDSP_CMD_SECOND_DEC_TX_MUX_DIS_V);
    }
#endif /* FEATURE_VOICE_PLAYBACK */

    /* ===== Packet Format Verification ===== */
    if ((qdsp_cmd_gsm_dec_frame_id < QDSP_AMR_SPEECH_GOOD)
        || (qdsp_cmd_gsm_dec_frame_id > QDSP_AMR_NO_DATA))
    {
      ERR("Invalid AMR decoder frame type %x",
          (uint16)qdsp_cmd_gsm_dec_frame_id, 0, 0);

      /* default to QDSP_AMR_SPEECH_BAD */
      qdsp_cmd_gsm_dec_frame_id = QDSP_AMR_SPEECH_BAD;
    }

    if ((qdsp_cmd_gsm_dec_frame_rate < QDSP_AMR_RATE_475)
        || (qdsp_cmd_gsm_dec_frame_rate > QDSP_AMR_RATE_1220))
    {
      ERR("Invalid AMR decoder frame rate %x",
          (uint16)qdsp_cmd_gsm_dec_frame_rate, 0, 0);

      /* default to last AMR decoder rate
         and set codec mode to QDSP_AMR_SPEECH_BAD */
      qdsp_cmd_gsm_dec_frame_rate = amr_last_dec_rate;
      qdsp_cmd_gsm_dec_frame_id = QDSP_AMR_SPEECH_BAD;
    }

    /* Record last AMR decoder rate for erasure usage */
    amr_last_dec_rate = qdsp_cmd_gsm_dec_frame_rate;

    dec_flag = ((uint16)qdsp_cmd_gsm_dec_frame_id
                & QDSP_AMR_FRAME_TYPE_M)
               | ((uint16)qdsp_cmd_gsm_dec_frame_rate
                  & QDSP_AMR_CODEC_MODE_M);

#ifdef FEATURE_VOICE_PLAYBACK
    if (qdsp_cmd_vp_paused && qdsp_cmd_vp_incall_mux_pause)
    {
      /* We are paused but we were doing an incall mux and so
      voice call is still on, we need to disable comfort noise */
      qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
    }
#endif /* FEATURE_VOICE_PLAYBACK */

    qdsp_write(QDSP_decFlagWord, dec_flag);    /* write the final value */

    /* ===== Providing packet data to QDSP ===== */
    qdsp_block_write(QDSP_decPacketBuf, 0, qdsp_cmd_rx_packet,
                     gsm_packet_length, FALSE);
  }   /* if (qdsp_cmd_dec_semaphore_flag == 0) else */


  /* ===== handshaking & statistics ===== */
  qdsp_cmd_dec_semaphore_flag = 0;     /* notify qdsp_cmd_gsm_rx_packet */
  qdsp_write(QDSP_decPacketReg, 0);    /* notify QDSP firmware */

  qdsp_cmd_gsm_decoded_pkt_cnt++;


  /* Perform packet logging here */
#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */
}

#endif  /* MSMAUD_VOC_AMR */

/* <EJECT> */
#ifdef MSMAUD_VOC_HR
/*===========================================================================

FUNCTION QDSP_CMD_GSM_HR_ENC_ISR

DESCRIPTION
  This function processes the GSM HR vocoders encoder interrupts.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_gsm_hr_enc_isr(uint16 **rx_tx_packet_p, uint16 *vp_enc_flag_p,
                             boolean *play_vp_on_both_p)
{
  uint16 enc_flag;
#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */
  uint16 gsm_packet_length;


  /* ===== Get frame type and frame rate ===== */
  enc_flag = qdsp_read(QDSP_encFlagWord);

#ifdef FEATURE_VOICE_PLAYBACK
 if(qdsp_cmd_vp_tx_playing && (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_TX) &&
     (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_BOTH)){
    *play_vp_on_both_p
      = qdsp_cmd_get_vp_tx_frame(vp_enc_flag_p, rx_tx_packet_p);
    enc_flag = *vp_enc_flag_p;
  }
#endif  /* FEATURE_VOICE_PLAYBACK */

  /* Drop the first X packets from FR/EFR/HR/AMR vocoders */
  if((qdsp_cmd_voc_enc_pkt_drop > 0)
#ifdef FEATURE_VOICE_PLAYBACK
     && !qdsp_cmd_vp_tx_playing
#endif /* FEATURE_VOICE_PLAYBACK */
    ) {
    qdsp_cmd_voc_enc_pkt_drop--;

    /* handshaking and statistics */
    qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

    /* Do not deliver a packet anywhere */
    return;
  } else {
    qdsp_cmd_gsm_enc_frame_id
    = ((enc_flag & QDSP_GSM_HR_TX_SP_M) == QDSP_GSM_HR_TX_SP_V)?
      QDSP_GSM_SPEECH_GOOD : QDSP_GSM_SID;
    qdsp_cmd_gsm_enc_err = enc_flag & QDSP_GSM_HR_TX_ER_M;
  }

  qdsp_cmd_gsm_enc_frame_rate = QDSP_GSM_HALF_RATE;
  /* Get the packet length */
  gsm_packet_length = get_gsm_packet_length(qdsp_cmd_gsm_enc_frame_id,
                                                   qdsp_cmd_gsm_enc_frame_rate);

  /* ===== Get packet data ===== */
#ifdef FEATURE_VOICE_PLAYBACK
  if(qdsp_cmd_vp_tx_playing && (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_TX) &&
     (qdsp_cmd_vp_incall_mux != QDSP_CMD_VP_MUX_BOTH)){
    if(gsm_packet_length != 0) {
      swap((byte *)(*rx_tx_packet_p),
           (byte *)qdsp_cmd_tx_packet,
           gsm_packet_length);
    }
  } else
#endif /* FEATURE_VOICE_PLAYBACK */
  {
    qdsp_block_read(QDSP_encPacketBuf, 0, qdsp_cmd_tx_packet,
                    gsm_packet_length, FALSE);

#ifdef FEATURE_VOICE_RECORD
    /* Only record valid frames */
    if((qdsp_cmd_rec_dir == QDSP_CMD_REC_REVERSE) ||
       (qdsp_cmd_rec_dir == QDSP_CMD_REC_BOTH))
    {
      swap((byte *)qdsp_cmd_tx_packet,
           (byte *)qdsp_cmd_temp_packet,
           gsm_packet_length);
      qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_REVERSE, qdsp_cmd_gsm_enc_frame_rate|qdsp_cmd_gsm_enc_frame_id,
                            gsm_packet_length, qdsp_cmd_temp_packet);
    }
#endif  /* FEATURE_VOICE_RECORD */
  }


  /* handshaking and statistics */
  qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

  qdsp_cmd_gsm_encoded_pkt_cnt++;

  /* unread encoded packet is overridden */
  if (qdsp_cmd_enc_semaphore_flag != 0)
  {
    qdsp_cmd_gsm_enc_lost_cnt++;
  }

  qdsp_cmd_enc_semaphore_flag = 1;       /* notify qdsp_cmd_gsm_tx_packet */


  /* Perform packet logging here */
#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */


#ifdef FEATURE_MVS
  if (hr_uplink_func!=NULL)
  {
    qdsp_cmd_enc_semaphore_flag = 0;       /* acknowledged */

    hr_uplink_func(qdsp_cmd_tx_packet,
                   qdsp_cmd_gsm_enc_frame_id,
                   ((qdsp_cmd_gsm_enc_err==0)? FALSE : TRUE));
  }
#endif  /* FEATURE_MVS */
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GSM_HR_DEC_ISR

DESCRIPTION
  This function processes the GSM HR vocoders decoder interrupts.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_gsm_hr_dec_isr(uint16 *rx_tx_pkt, uint16 vp_enc_flag,
                             boolean vp_on_both)
{
  uint16 dec_flag;
#ifdef FEATURE_MVS
  boolean taf = FALSE;
  boolean bfi = FALSE;
  boolean ufi = FALSE;
#endif /* FEATURE_MVS */
  uint16 gsm_packet_length;
#ifdef FEATURE_VOICE_PLAYBACK
  uint16 gsm_sec_dec_packet_length;
#endif  /* FEATURE_VOICE_PLAYBACK */

#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */

  qdsp_cmd_gsm_dec_taf = 0;
  qdsp_cmd_gsm_dec_bfi = 0;
  qdsp_cmd_gsm_dec_ufi = 0;

#ifdef FEATURE_MVS
  if (hr_downlink_func!=NULL)
  {
    hr_downlink_func(qdsp_cmd_rx_packet,
                     &qdsp_cmd_gsm_dec_frame_id,
                     &taf, &bfi, &ufi);

    /* Convert TAF */
    qdsp_cmd_gsm_dec_taf = ((taf==TRUE)? QDSP_GSM_RX_TAF_M : 0x0000);

    /* Convert BFI */
    qdsp_cmd_gsm_dec_bfi = ((bfi==TRUE)? QDSP_GSM_RX_BFI_M : 0x0000);

    /* Convert UFI */
    qdsp_cmd_gsm_dec_ufi = ((ufi==TRUE)? QDSP_GSM_RX_UFI_M : 0x0000);

    qdsp_cmd_dec_semaphore_flag = 1;        /* decoding packet provided */
  }
#endif  /* FEATURE_MVS */

  qdsp_cmd_gsm_dec_frame_rate = QDSP_GSM_HALF_RATE;
#ifdef FEATURE_VOICE_PLAYBACK
  qdsp_cmd_gsm_sec_dec_frame_rate = QDSP_GSM_HALF_RATE;
#endif
  /* Get the packet length */
  gsm_packet_length = get_gsm_packet_length(qdsp_cmd_gsm_dec_frame_id,
                                            qdsp_cmd_gsm_dec_frame_rate);

#ifdef FEATURE_VOICE_RECORD
  if((qdsp_cmd_rec_dir == QDSP_CMD_REC_FORWARD) ||
     (qdsp_cmd_rec_dir == QDSP_CMD_REC_BOTH))
  {
    /* In-call recording, packet was filled by MVS or equivalent */
    /* Frame rate was set above so we know it's good. */
    swap((byte *)qdsp_cmd_rx_packet,
         (byte *)qdsp_cmd_temp_packet,
         gsm_packet_length);

    qdsp_cmd_rec_frame_fn(QDSP_CMD_REC_FORWARD,
                          qdsp_cmd_gsm_dec_frame_rate |
                          qdsp_cmd_gsm_dec_frame_id,
                          gsm_packet_length,
                          qdsp_cmd_temp_packet);
  }
#endif /* FEATURE_VOICE_RECORD */


#ifdef FEATURE_VOICE_PLAYBACK
  if(vp_on_both){
    if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH)
    {
      qdsp_cmd_get_vp_tx_frame(&dec_flag, &rx_tx_pkt);
    }
    else
    {
      /* Ignore decoder flag word,
      ** convert encoder flag word into decoder flag word.
      ** Packet already available in rx_tx_pkt
      */
      dec_flag = (vp_enc_flag & QDSP_GSM_TX_SP_M) ? 0 : QDSP_GSM_RX_BFI_M;
    }
  } else if (qdsp_cmd_vp_rx_playing) {
    /* Incoming frame rate is decoder formatted */
    qdsp_cmd_get_vp_rx_frame_wrap(&dec_flag, &rx_tx_pkt);
  } else if(qdsp_cmd_vp_tx_playing &&
           ((qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_TX) ||
           (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH))){
    qdsp_cmd_get_vp_tx_frame(&dec_flag, &rx_tx_pkt);

  } else if ((qdsp_cmd_vp_paused) && (!qdsp_cmd_vp_incall_mux_pause) &&
             (qdsp_cmd_vp_direction == QDSP_CMD_VP_RX)) {
    /* send erasures to decoder */
    qdsp_cmd_gsm_dec_frame_id = QDSP_GSM_BFI;
    gsm_packet_length = PACKET_SIZE_GSM_BAD;
    qdsp_cmd_gsm_dec_taf = 0;
    qdsp_cmd_dec_semaphore_flag = 1;
  }

  if ((vp_on_both) || (qdsp_cmd_vp_rx_playing)) {
    /* Extract frame ID from dec flag */
    if(dec_flag & QDSP_GSM_RX_BFI_M) {
      if (qdsp_cmd_vp_incall_mux)
      {
        qdsp_cmd_gsm_sec_dec_frame_id = QDSP_GSM_BFI;
      }
      else
      {
        qdsp_cmd_gsm_dec_frame_id = QDSP_GSM_BFI;
      }
    } else {
      /* SID information is lost in the dec_flag, so all SIDs are flagged as
      ** SPEECH_GOOD here.  The vocoder will sort it out.
      */
      if (qdsp_cmd_vp_incall_mux)
      {
        qdsp_cmd_gsm_sec_dec_frame_id = QDSP_GSM_SPEECH_GOOD;
      }
      else
      {
        qdsp_cmd_gsm_dec_frame_id = QDSP_GSM_SPEECH_GOOD;
      }
    }
    qdsp_cmd_gsm_dec_taf = 0;
    qdsp_cmd_gsm_sec_dec_taf = 0;

    /* Get the packet length */
    if (qdsp_cmd_vp_incall_mux)
    {
      gsm_sec_dec_packet_length =
        get_gsm_packet_length(qdsp_cmd_gsm_sec_dec_frame_id,
                                              qdsp_cmd_gsm_sec_dec_frame_rate);
      /* Swap bytes in the vocoder packet */
      swap((byte *)rx_tx_pkt,
           (byte *)qdsp_cmd_sec_dec_rx_packet,
           gsm_sec_dec_packet_length);
    }
    else
    {
      gsm_packet_length = get_gsm_packet_length(qdsp_cmd_gsm_dec_frame_id,
                                                qdsp_cmd_gsm_dec_frame_rate);
      /* Swap bytes in the vocoder packet */
      swap((byte *)rx_tx_pkt,
           (byte *)qdsp_cmd_rx_packet,
           gsm_packet_length);
    }
    qdsp_cmd_dec_semaphore_flag = 1;
  }
#endif /* FEATURE_VOICE_PLAYBACK */

  /* check if rx packet available yet */
  if (qdsp_cmd_dec_semaphore_flag == 0)
  {
    dec_flag = (uint16)QDSP_GSM_RX_BFI_M;      /* erasure */

#ifdef FEATURE_VOICE_PLAYBACK
    if (qdsp_cmd_vp_incall_mux)
    {
      qdsp_write(QDSP_secondDecPacketRate, dec_flag);
    }
#endif  /* FEATURE_VOICE_PLAYBACK */
    qdsp_write(QDSP_decFlagWord, dec_flag);

    /* statistics */
    qdsp_cmd_gsm_dec_miss_cnt++;
                         /* times when rx packets are unavailable */
  }
  else
  {
#ifdef FEATURE_VOICE_PLAYBACK
    if (qdsp_cmd_vp_incall_mux)
    {
      /* ===== Packet Format Verification ===== */
      if ((qdsp_cmd_gsm_sec_dec_frame_id < QDSP_GSM_SID)
          || (qdsp_cmd_gsm_sec_dec_frame_id > QDSP_GSM_INVALID_SID))
      {
        ERR("Invalid GSM decoder frame type %x",
            (uint16)qdsp_cmd_gsm_sec_dec_frame_id, 0, 0);

        /* default to QDSP_GSM_BFI */
        qdsp_cmd_gsm_sec_dec_frame_id = QDSP_GSM_BFI;
      }

      switch (qdsp_cmd_gsm_sec_dec_frame_id)
      {
        case QDSP_GSM_SID :
          dec_flag = QDSP_GSM_HR_RX_SID_V;
          break;

        case QDSP_GSM_SPEECH_GOOD :
          dec_flag = QDSP_GSM_HR_RX_SP_V;
          break;

        case QDSP_GSM_INVALID_SID :
          dec_flag = QDSP_GSM_HR_RX_ISID_V;
          break;

        case QDSP_GSM_BFI :
        default :
          dec_flag = QDSP_GSM_HR_RX_SP_V;
          qdsp_cmd_gsm_sec_dec_bfi = QDSP_GSM_RX_BFI_M;
          break;
      }

      dec_flag |= (qdsp_cmd_gsm_sec_dec_taf & QDSP_GSM_RX_TAF_M)
                  | (qdsp_cmd_gsm_sec_dec_bfi & QDSP_GSM_RX_BFI_M)
                  | (qdsp_cmd_gsm_sec_dec_ufi & QDSP_GSM_RX_UFI_M);

      if (!qdsp_cmd_second_dec_configured)
      {
        qdsp_cmd_second_dec_configured = TRUE;
        qdsp_write(QDSP_secondDecoderConfig, qdsp_cmd_second_dec_config);
        if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_RX)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
        }
        else if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_TX)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
          qdsp_write(QDSP_memoPlaybackTxMux,
                     QDSP_CMD_SECOND_DEC_TX_MUX_ENA_V);
        }
        else if (qdsp_cmd_vp_incall_mux == QDSP_CMD_VP_MUX_BOTH)
        {
          qdsp_write(QDSP_decoderMemoPlaybackMux,
                     QDSP_CMD_SECOND_DEC_RX_MUX_ENA_V);
          qdsp_write(QDSP_memoPlaybackTxMux,
                     QDSP_CMD_SECOND_DEC_TX_MUX_ENA_V);
        }
        qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
      }

      qdsp_write(QDSP_secondDecPacketRate, dec_flag);

      /* ===== Providing packet data to QDSP ===== */
      qdsp_block_write(QDSP_secondDecPacketBuf, 0, qdsp_cmd_sec_dec_rx_packet,
                       QDSP_CMD_GSM_PACKET_LENGTH, FALSE);

    } else if (qdsp_cmd_second_dec_configured) {
      qdsp_cmd_second_dec_configured = FALSE;
      qdsp_write(QDSP_secondDecoderConfig,
                 QDSP_CMD_SECOND_DEC_CONFIG_NONE);
      qdsp_write(QDSP_decoderMemoPlaybackMux,
                 QDSP_CMD_SECOND_DEC_RX_MUX_DIS_V);
      qdsp_write(QDSP_memoPlaybackTxMux,
                 QDSP_CMD_SECOND_DEC_TX_MUX_DIS_V);
    }
#endif  /* FEATURE_VOICE_PLAYBACK */

    /* ===== Packet Format Verification ===== */
    if ((qdsp_cmd_gsm_dec_frame_id < QDSP_GSM_SID)
        || (qdsp_cmd_gsm_dec_frame_id > QDSP_GSM_INVALID_SID))
    {
      ERR("Invalid GSM decoder frame type %x",
          (uint16)qdsp_cmd_gsm_dec_frame_id, 0, 0);

      /* default to QDSP_GSM_BFI */
      qdsp_cmd_gsm_dec_frame_id = QDSP_GSM_BFI;
    }

    switch (qdsp_cmd_gsm_dec_frame_id)
    {
      case QDSP_GSM_SID :
        dec_flag = QDSP_GSM_HR_RX_SID_V;
        break;

      case QDSP_GSM_SPEECH_GOOD :
        dec_flag = QDSP_GSM_HR_RX_SP_V;
        break;

      case QDSP_GSM_INVALID_SID :
        dec_flag = QDSP_GSM_HR_RX_ISID_V;
        break;

      case QDSP_GSM_BFI :
      default :
        dec_flag = QDSP_GSM_HR_RX_SP_V;
        qdsp_cmd_gsm_dec_bfi = QDSP_GSM_RX_BFI_M;
        break;
    }

    dec_flag |= (qdsp_cmd_gsm_dec_taf & QDSP_GSM_RX_TAF_M)
                | (qdsp_cmd_gsm_dec_bfi & QDSP_GSM_RX_BFI_M)
                | (qdsp_cmd_gsm_dec_ufi & QDSP_GSM_RX_UFI_M);

#ifdef FEATURE_VOICE_PLAYBACK
    if (qdsp_cmd_vp_paused && qdsp_cmd_vp_incall_mux_pause)
    {
      /* We are paused but we were doing an incall mux and so
      voice call is still on, we need to disable comfort noise */
      qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
    }
#endif  /* FEATURE_VOICE_PLAYBACK */

    qdsp_write(QDSP_decFlagWord, dec_flag);    /* write the final value */

    /* ===== Providing packet data to QDSP ===== */
    qdsp_block_write(QDSP_decPacketBuf, 0, qdsp_cmd_rx_packet,
                     QDSP_CMD_GSM_PACKET_LENGTH, FALSE);
  }   /* if (qdsp_cmd_dec_semaphore_flag == 0) else */


  /* ===== handshaking & statistics ===== */
  qdsp_cmd_dec_semaphore_flag = 0;     /* notify qdsp_cmd_gsm_rx_packet */
  qdsp_write(QDSP_decPacketReg, 0);    /* notify QDSP firmware */

  qdsp_cmd_gsm_decoded_pkt_cnt++;


  /* Perform packet logging here */
#ifdef FEATURE_GSM_WCDMA_AMR_PKT_LOG
#error code not present
#endif  /* FEATURE_GSM_WCDMA_AMR_PKT_LOG */
}

#endif  /* MSMAUD_VOC_HR */

/* <EJECT> */
#if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) || \
    defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_HR) || \
    defined(MSMAUD_VOC_AMR_WB) || defined(FEATURE_AVS_INCALL_ADEC_PB)
/*===========================================================================

FUNCTION QDSP_CMD_GSM_VOC_QDSP_ISR

DESCRIPTION
  This function processes the encoder and decoder interrupts for AMR image,
which supports all FR, EFR and AMR vocoder modes.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_gsm_voc_qdsp_isr(void)
{
  static uint16 vp_enc_flag;
  static boolean play_vp_on_both = FALSE;
  static uint16 *rx_tx_packet = NULL;

#if defined(QDSP_vp3ParamsReg)
#error code not present
#endif /*QDSP_vp3ParamsReg*/

#ifdef FEATURE_VOC_DTMF_DETECT
  uint16 dsp_msg_type;        /* flag indicating dsp message type        */

  dsp_msg_type = qdsp_read(QDSP_dspMessageReg);
  if ( dsp_msg_type == QDSP_CMD_DTMF_DETECT_MSG ) {
    /* Semaphore is cleared in this function */
    qdsp_cmd_dtmf_detect_processing();
  }
#endif /* FEATURE_VOC_DTMF_DETECT */

#ifdef FEATURE_VOC_ADPCM
  if ((qdsp_cmd_voc_adpcm_is_supported() == TRUE)            &&
      (qdsp_read(QDSP_adpcmPacketReg)    != 0)               &&
      (qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED)) {
    if (qdsp_cmd_voc_adpcm_send_frame() == TRUE) {
      qdsp_write(QDSP_adpcmPacketReg, 0);
    }
  }
#endif /* FEATURE_VOC_ADPCM */


#if defined(QDSP_vp3ParamsReg)
#error code not present
#endif /*QDSP_vp3ParamsReg*/


  /* ------------------- Check Encoder ------------------------- */
  if (qdsp_read(QDSP_encPacketReg) != 0)
  {
    switch (qdsp_voc_mode)
    {
#if defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_EFR)
#error code not present
#endif  /* MSMAUD_VOC_FR || MSMAUD_VOC_EFR */

#ifdef MSMAUD_VOC_AMR_WB_COMMON
      case QDSP_VOC_MODE_AMR_WB_V :
        qdsp_cmd_amr_wb_enc_isr(&rx_tx_packet, &vp_enc_flag, &play_vp_on_both);
        break;
#endif  /* MSMAUD_VOC_AMR_WB_COMMON */

#ifdef MSMAUD_VOC_AMR
      case QDSP_VOC_MODE_AMR_V :
        qdsp_cmd_amr_enc_isr(&rx_tx_packet, &vp_enc_flag, &play_vp_on_both);
        break;
#endif  /* MSMAUD_VOC_AMR */

#ifdef MSMAUD_VOC_HR
      case QDSP_VOC_MODE_GSM_HR_V :
        qdsp_cmd_gsm_hr_enc_isr(&rx_tx_packet, &vp_enc_flag, &play_vp_on_both);
        break;
#endif  /* MSMAUD_VOC_HR */

      default :
        MSG_ERROR("Wrong VDSP enc isr for voc mode %d", qdsp_voc_mode, 0, 0);
    }
  }


  /* ------------------- Check Decoder ------------------------- */
  if (qdsp_read(QDSP_decPacketReg) != 0)
  {
    switch (qdsp_voc_mode)
    {
#if defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_EFR)
#error code not present
#endif  /* MSMAUD_VOC_FR || MSMAUD_VOC_EFR */

#ifdef MSMAUD_VOC_AMR_WB_COMMON
      case QDSP_VOC_MODE_AMR_WB_V :
        qdsp_cmd_amr_wb_dec_isr(rx_tx_packet, vp_enc_flag, play_vp_on_both);
        play_vp_on_both = FALSE;
        break;
#endif  /* MSMAUD_VOC_AMR_WB_COMMON */

#ifdef MSMAUD_VOC_AMR
      case QDSP_VOC_MODE_AMR_V :
        qdsp_cmd_amr_dec_isr(rx_tx_packet, vp_enc_flag, play_vp_on_both);
        play_vp_on_both = FALSE;
        break;
#endif  /* MSMAUD_VOC_AMR */

#ifdef MSMAUD_VOC_HR
      case QDSP_VOC_MODE_GSM_HR_V :
        qdsp_cmd_gsm_hr_dec_isr(rx_tx_packet, vp_enc_flag, play_vp_on_both);
        play_vp_on_both = FALSE;
        break;
#endif  /* MSMAUD_VOC_HR */

      default :
        MSG_ERROR("Wrong VDSP dec isr for voc mode %d", qdsp_voc_mode, 0, 0);
    }
  }

#ifdef FEATURE_VOC_PCM_INTERFACE
  qdsp_cmd_process_pcm_data();
#endif /* FEATURE_VOC_PCM_INTERFACE */

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)

#if defined(QDSP_IMAGE_AMR_MP3_DEFINED) || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)  || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED) || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)  || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)
    switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
      case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
      case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
      case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
      case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
        if (qdsp_cmd_adec_int_cb_ptr != NULL) {
          /* If msg type is non-zero, we have an interrupt pending */
          if (qdsp_read(QDSP_adecDataHostStickyInt) != 0) {
            /* Tell vocoder task to return the next set of data */

            qdsp_cmd_adec_int_cb_ptr();

          }
        }
        break;
  } /* switch */
#ifdef FEATURE_AUDIO_FORMAT
  qdsp_cmd_do_av_sync();
#endif /* FEATURE_AUDIO_FORMAT */

#ifdef FEATURE_AUDFMT_SPECTRUM_ANALYZER
  qdsp_cmd_do_spectrum_analyzer();
#endif /* FEATURE_AUDFMT_SPECTRUM_ANALYZER */
#endif

#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */
}
#endif /* MSMAUD_VOC_AMR || MSMAUD_VOC_EFR || MSMAUD_VOC_FR ||
          MSMAUD_VOC_HR  || MSMAUD_VOC_AMR_WB || FEATURE_AVS_INCALL_ADEC_PB */

#ifdef MSMAUD_VOC_G711
#ifdef FEATURE_WAVE_PB
/*===========================================================================

FUNCTION QDSP_CMD_VOC_WAV_SEND_FRAME

DESCRIPTION
  This function sends an ADPCM frame to vocoder image.

DEPENDENCIES
  This function depends on all initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_voc_wav_send_frame(void)
{
  uint32 tlong;
  uint16 frame_size = QDSP_CMD_G711_PACKET_LENGTH<<1;
  uint16 format     = 0;
  boolean ret_val   = FALSE;

#ifdef MSMAUD_VOC_G711
  if(qdsp_voc_mode == QDSP_VOC_MODE_G711_V)
  {
    if(qdsp_cmd_wav_format == QDSP_CMD_WAV_FORMAT_MULAW) {
      format = QDSP_G711_MODE_MULAW;
    }
    else if(qdsp_cmd_wav_format == QDSP_CMD_WAV_FORMAT_ALAW) {
      format = QDSP_G711_MODE_ALAW;
    }
  }
#endif /* MSMAUD_VOC_G711 */

  if (qdsp_cmd_adpcm_status != QDSP_CMD_ADPCM_MODE_ENABLED) {
    return ret_val;
  }

  if (qdsp_read(QDSP_decPacketReg) != 0) {
    /* Verify that there is one whole frame to send to DSP */
    if((qdsp_cmd_adpcm_adec_info.buf_length +
                     qdsp_cmd_adpcm_adec_info.tmp_buf_length) >= frame_size) {

      if (qdsp_cmd_adpcm_adec_info.tmp_buf_length != 0) {
        /* If temp buffer has odd number of bytes do adjustment */
        if (qdsp_cmd_adpcm_adec_info.tmp_buf_length & 0x1) {
          qdsp_cmd_adpcm_adec_info.tmp_buf
                    [qdsp_cmd_adpcm_adec_info.tmp_buf_length] =
                                        *qdsp_cmd_adpcm_adec_info.buf_ptr;
          qdsp_cmd_adpcm_adec_info.buf_ptr++;
          qdsp_cmd_adpcm_adec_info.tmp_buf_length++;
          qdsp_cmd_adpcm_adec_info.buf_length--;
        }

        tlong = frame_size - qdsp_cmd_adpcm_adec_info.tmp_buf_length;

        qdsp_block_write(QDSP_decPacketBuf, 0,
                         (uint16*) qdsp_cmd_adpcm_adec_info.tmp_buf,
                         qdsp_cmd_adpcm_adec_info.tmp_buf_length/2, FALSE);
        ret_val = TRUE;

      } else {
        tlong = frame_size;
      }
      qdsp_block_write(QDSP_decPacketBuf,
                       qdsp_cmd_adpcm_adec_info.tmp_buf_length/2,
                       (uint16*) qdsp_cmd_adpcm_adec_info.buf_ptr,
                       tlong/2, FALSE);

      ret_val = TRUE;
      qdsp_cmd_adpcm_adec_info.buf_ptr        += tlong;
      qdsp_cmd_adpcm_adec_info.buf_length     -= tlong;
      qdsp_cmd_adpcm_adec_info.tmp_buf_length  = 0;
      qdsp_write(QDSP_decPacketRate, format);
    }

    /* Check if less than one frame of data remaining in buffers */
    if ((qdsp_cmd_adpcm_adec_info.buf_length +
                     qdsp_cmd_adpcm_adec_info.tmp_buf_length) <= frame_size) {

      if (qdsp_cmd_adpcm_adec_info.buf_length != 0) {

        memcpy(&(qdsp_cmd_adpcm_adec_info.tmp_buf
                             [qdsp_cmd_adpcm_adec_info.tmp_buf_length]),
               qdsp_cmd_adpcm_adec_info.buf_ptr,
               qdsp_cmd_adpcm_adec_info.buf_length);

        qdsp_cmd_adpcm_adec_info.tmp_buf_length +=
                             qdsp_cmd_adpcm_adec_info.buf_length;

        qdsp_cmd_adpcm_adec_info.buf_length = 0;
      }

      if (qdsp_cmd_adec_int_cb_ptr != NULL) {
        /* Tell vocoder task to return the next set of data */
        qdsp_cmd_adec_int_cb_ptr();
      }
    }
  }

  return (ret_val);
}
#endif /* FEATURE_WAVE_PB */

/*===========================================================================

FUNCTION QDSP_CMD_G711_ENC_ISR

DESCRIPTION
  This function processes the encoder interrupt for the G.711 vocoder.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_g711_enc_isr
(
  void
)
{
  uint16                   g711_packet_length;
  qdsp_cmd_g711_mode_type  qdsp_g711_mode;

  /* Drop the first X packets from all vocoders */
  if(qdsp_cmd_voc_enc_pkt_drop > 0) {
    qdsp_cmd_voc_enc_pkt_drop--;

    /* handshaking and statistics */
    qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

    /* Do not deliver a packet anywhere */
    return;
  }

  /* Read the wlan mode from the DSP */
  qdsp_g711_mode = (qdsp_cmd_g711_mode_type)qdsp_read(QDSP_encPacketRate);

  /* Get the packet length */
  g711_packet_length = QDSP_CMD_G711_PACKET_LENGTH;

  /* Get packet from DSP */
  qdsp_block_read(QDSP_encPacketBuf, 0, qdsp_cmd_tx_packet,
                  g711_packet_length, FALSE);

  /* handshaking and statistics */
  qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

  qdsp_cmd_wlan_encoded_pkt_cnt++;

  /* unread encoded packet is overridden */
  if (qdsp_cmd_enc_semaphore_flag != 0) {
    qdsp_cmd_wlan_enc_lost_cnt++;
  }
  /* Set the semaphore */
  qdsp_cmd_enc_semaphore_flag = 1;


#ifdef FEATURE_MVS
  if (g711_uplink_func != NULL) {
    /* Clear semaphore */
    qdsp_cmd_enc_semaphore_flag = 0;       /* acknowledged */

    g711_uplink_func(qdsp_cmd_tx_packet,
                     QDSP_CMD_G711_PACKET_LENGTH*2,
                     qdsp_g711_mode);
  }
#endif  /* FEATURE_MVS */
}

/*===========================================================================

FUNCTION QDSP_CMD_G711_DEC_ISR

DESCRIPTION
  This function processes the decoder interrupt for the G.711 vocoder.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_g711_dec_isr
(
  void
)
{
  qdsp_cmd_g711_mode_type  qdsp_g711_mode = QDSP_G711_MODE_MULAW;
  uint16                   g711_packet_length = QDSP_CMD_G711_PACKET_LENGTH;

#ifdef FEATURE_MVS
  if (g711_downlink_func != NULL) {
    /* Get packet data from MVS */
    g711_downlink_func(qdsp_cmd_rx_packet,
                       &g711_packet_length,
                       &qdsp_g711_mode);

    /* Check length parameter */
    g711_packet_length = g711_packet_length >> 1;
    g711_packet_length = MIN(g711_packet_length, QDSP_CMD_G711_PACKET_LENGTH);

    qdsp_cmd_dec_semaphore_flag = 1;        /* decoding packet provided */
  }
#endif  /* FEATURE_MVS */

#if defined(FEATURE_GRAPH_ADPCM) || defined(FEATURE_VOC_ADPCM)
  /* Pass G711 frame from WAV file for a/ulaw playback */
  if (qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED) {
    if (qdsp_cmd_voc_wav_send_frame() == TRUE) {
      qdsp_write(QDSP_decPacketReg, 0);
      return;
    }
    /* If frame failure, the semaphore flag below will blank the frame */
  }
#endif /* defined(FEATURE_GRAPH_ADPCM) || defined(FEATURE_VOC_ADPCM) */

  /* check if rx packet available or bad */
  if (qdsp_cmd_dec_semaphore_flag == 0 ||
      (qdsp_g711_mode != QDSP_G711_MODE_MULAW) &&
      (qdsp_g711_mode != QDSP_G711_MODE_ALAW))
  {
    /* Erase packet */
    qdsp_g711_mode = (qdsp_cmd_g711_mode_type) qdsp_read(QDSP_encCodecMode);
    if(qdsp_g711_mode == QDSP_G711_MODE_MULAW) {
      /* u-law blank frame */
      qdsp_block_set(QDSP_decPacketBuf, 0, 0xFFFF, g711_packet_length);
    } else {
      /* a-law blank frame */
      qdsp_block_set(QDSP_decPacketBuf, 0, 0xD5D5, g711_packet_length);
    }

    /* statistics */
    qdsp_cmd_wlan_dec_miss_cnt++;
                         /* times when rx packets are unavailable */
  }
  else
  {
    /* ===== Providing packet data to QDSP ===== */
    qdsp_block_write(QDSP_decPacketBuf, 0, qdsp_cmd_rx_packet,
                     g711_packet_length, FALSE);
  }

  /* ===== handshaking & statistics ===== */
  qdsp_cmd_dec_semaphore_flag = 0;     /* notify qdsp_cmd_gsm_rx_packet */
  qdsp_write(QDSP_decPacketRate, qdsp_g711_mode);
  qdsp_write(QDSP_decPacketReg, 0);    /* notify QDSP firmware */

  qdsp_cmd_wlan_decoded_pkt_cnt++;
}
#endif /* MSMAUD_VOC_G711 */

#ifdef MSMAUD_VOC_G723
/*===========================================================================

FUNCTION QDSP_CMD_G723_ENC_ISR

DESCRIPTION
  This function processes the encoder interrupt for the G.723 vocoder.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_g723_enc_isr
(
  void
)
{
  uint16                   g723_packet_length;
  qdsp_cmd_g723_mode_type  qdsp_g723_mode;

  /* Drop the first X packets from all vocoders */
  if(qdsp_cmd_voc_enc_pkt_drop > 0) {
    qdsp_cmd_voc_enc_pkt_drop--;

    /* handshaking and statistics */
    qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

    /* Do not deliver a packet anywhere */
    return;
  }

  /* Read the wlan mode from the DSP */
  qdsp_g723_mode = (qdsp_cmd_g723_mode_type)qdsp_read(QDSP_encPacketRate) &
                                                        QDSP_CMD_G723_MODE_MASK;

  /* Get the packet length */
  g723_packet_length = qdsp_cmd_packet_size_g723[(uint16)qdsp_g723_mode];

  /* Get packet from DSP */
  qdsp_block_read(QDSP_encPacketBuf, 0, qdsp_cmd_tx_packet,
                  g723_packet_length, FALSE);

  /* handshaking and statistics */
  qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */

  qdsp_cmd_wlan_encoded_pkt_cnt++;

  /* unread encoded packet is overridden */
  if (qdsp_cmd_enc_semaphore_flag != 0) {
    qdsp_cmd_wlan_enc_lost_cnt++;
  }
  /* Set the semaphore */
  qdsp_cmd_enc_semaphore_flag = 1;


#ifdef FEATURE_MVS
  if (g723_uplink_func != NULL) {
    /* Clear semaphore */
    qdsp_cmd_enc_semaphore_flag = 0;       /* acknowledged */

    g723_uplink_func(qdsp_cmd_tx_packet,
                     g723_packet_length*2,
                     qdsp_g723_mode);
  }
#endif  /* FEATURE_MVS */
}

/*===========================================================================

FUNCTION QDSP_CMD_G723_DEC_ISR

DESCRIPTION
  This function processes the decoder interrupt for the G.723 vocoder.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_g723_dec_isr
(
  void
)
{
  qdsp_cmd_g723_mode_type  qdsp_g723_mode;
  uint16                   g723_packet_length;

#ifdef FEATURE_MVS
  if (g723_downlink_func != NULL) {
    /* Get packet data from MVS */
    g723_downlink_func(qdsp_cmd_rx_packet,
                       &g723_packet_length,
                       &qdsp_g723_mode);

    /* Validate mode parameter */
    if((qdsp_g723_mode & QDSP_CMD_G723_MODE_MASK) == qdsp_g723_mode) {
      /* Check length parameter */
      g723_packet_length = MIN(g723_packet_length,
                               qdsp_cmd_packet_size_g723[(uint16)qdsp_g723_mode]);

      qdsp_cmd_dec_semaphore_flag = 1;        /* decoding packet provided */
    }
  }
#endif  /* FEATURE_MVS */

  /* check if rx packet available or bad */
  if (qdsp_cmd_dec_semaphore_flag == 0)
  {
    if(qdsp_cmd_g723_sid_flag != TRUE) {
      /* Substitute a SID packet for first blank frame */
      qdsp_g723_mode = QDSP_G723_MODE_SID;
      qdsp_write(QDSP_decPacketBuf, 0x3aaa);
      qdsp_write_offset(QDSP_decPacketBuf, 1, 0x02be);
      qdsp_block_set(QDSP_decPacketBuf, 2, 0x0000, 17-2);
      qdsp_write(QDSP_rxCrcRealTime, 0);
      qdsp_cmd_g723_sid_flag = TRUE;
    } else {
      /* Erase packet */
      qdsp_write(QDSP_rxCrcRealTime, 1);
    }

    /* statistics */
    qdsp_cmd_wlan_dec_miss_cnt++;
                         /* times when rx packets are unavailable */
  }
  else
  {
    /* Clear SID packet check once good data is received. */
    qdsp_cmd_g723_sid_flag = FALSE;

    /* ===== Providing packet data to QDSP ===== */
    qdsp_block_write(QDSP_decPacketBuf, 0, qdsp_cmd_rx_packet,
                     g723_packet_length, FALSE);
    qdsp_block_set(QDSP_decPacketBuf, g723_packet_length, 0x0000,
                   17-g723_packet_length);
    qdsp_write(QDSP_rxCrcRealTime, 0);
  }

  /* ===== handshaking & statistics ===== */
  qdsp_cmd_dec_semaphore_flag = 0;     /* notify qdsp_cmd_gsm_rx_packet */
  qdsp_write(QDSP_decPacketRate, qdsp_g723_mode);
  qdsp_write(QDSP_decPacketReg, 0);    /* notify QDSP firmware */

  qdsp_cmd_wlan_decoded_pkt_cnt++;
}
#endif /* MSMAUD_VOC_G723 */

#if defined(MSMAUD_VOC_G711) || defined(MSMAUD_VOC_G723)
/*===========================================================================

FUNCTION QDSP_CMD_WLAN_VOC_ISR

DESCRIPTION
  This function processes the encoder and decoder interrupts for WLAN images,
including G.711 mode.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_wlan_voc_isr(void)
{
#ifdef FEATURE_VOC_DTMF_DETECT
  uint16 dsp_msg_type;        /* flag indicating dsp message type        */

  dsp_msg_type = qdsp_read(QDSP_dspMessageReg);
  if ( dsp_msg_type == QDSP_CMD_DTMF_DETECT_MSG ) {
    /* Semaphore is cleared in this function */
    qdsp_cmd_dtmf_detect_processing();
  }
#endif /* FEATURE_VOC_DTMF_DETECT */

  /* ------------------- Check Encoder ------------------------- */
  if (qdsp_read(QDSP_encPacketReg) != 0)
  {
    switch (qdsp_voc_mode)
    {
#ifdef MSMAUD_VOC_G711
      case QDSP_VOC_MODE_G711_V :
        qdsp_cmd_g711_enc_isr();
        break;
#endif /* MSMAUD_VOC_G711 */
#ifdef MSMAUD_VOC_G723
      case QDSP_VOC_MODE_G723_V :
        qdsp_cmd_g723_enc_isr();
        break;
#endif /* MSMAUD_VOC_G723 */
      default :
        MSG_ERROR("Wrong VDSP enc isr for voc mode %d", qdsp_voc_mode, 0, 0);
    }
  }

  /* ------------------- Check Decoder ------------------------- */
  if (qdsp_read(QDSP_decPacketReg) != 0)
  {
    switch (qdsp_voc_mode)
    {
#ifdef MSMAUD_VOC_G711
      case QDSP_VOC_MODE_G711_V :
        qdsp_cmd_g711_dec_isr();
        break;
#endif  /* MSMAUD_VOC_G711 */
#ifdef MSMAUD_VOC_G723
      case QDSP_VOC_MODE_G723_V :
        qdsp_cmd_g723_dec_isr();
        break;
#endif  /* MSMAUD_VOC_G723 */
      default :
        MSG_ERROR("Wrong VDSP dec isr for voc mode %d", qdsp_voc_mode, 0, 0);
    }
  }

#ifdef FEATURE_VOC_PCM_INTERFACE
  qdsp_cmd_process_pcm_data();
#endif /* FEATURE_VOC_PCM_INTERFACE */
}
#endif /* defined(MSMAUD_VOC_G711) || defined(MSMAUD_VOC_G723) */

/* <EJECT> */
#ifdef FEATURE_PHONE_VR
/*===========================================================================

FUNCTION qdsp_cmd_vr_qdsp2_isr

DESCRIPTION
  This function processes the QDSP2 ISR for the QDSP2 mode B/C image.

DEPENDENCIES
  This function depends on all VR mode B/C vocoder initialization taking
  place first.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

void qdsp_cmd_vr_qdsp2_isr ( void )
{
  uint16 dsp_msg_type;        /* Incoming DSP message type                 */
  int16  dsp_msg_data;        /* Incoming DSP message data                 */
  uint16 packet_length;       /* Temp variable to manipulate buffers       */
  uint16 *rx_tx_packet;       /* Temp variable to manipulate buffers       */
  uint16 frame_rate;          /* Temp variable to manipulate buffers       */
  static uint16 qdsp_vr_pkt_buf[QDSP2_VR_PKT_LEN];
                              /* Vocoder packet for Endpoint detector      */

  /*************************************************************************/
  /* DSP Message processing                                                */
  /*************************************************************************/

  /* If msg type is non zero then DSP has sent a message.
  */
  if ((dsp_msg_type = qdsp_read (QDSP_dspMessageReg)) != 0)
  {

    switch (dsp_msg_type)
    {
      case VR_INIT_STATUS_MSG:

        /* Log an NV item error if the VR software version is invalid.  All
        ** VR commands will be rejected by DSP.
        */
        dsp_msg_data = qdsp_read (QDSP_dspMessageBuf);
        if (dsp_msg_data < 0)
        {
          ERR ("QDSP2 rejected VR Software Version Number", 0, 0, 0);
        }
        else
        {
          MSG_HIGH("VR SVN accepted svn=%x", dsp_msg_data ,0 ,0);
        }
        break;

      default:
        ERR ("Invalid msg received from DSP %x", dsp_msg_type, 0, 0);
        break;
    }

    /* Host clears the semaphore flag when read.
    */
    qdsp_write (QDSP_dspMessageReg, 0);

    /* Increment diagnostic mode B/C vocoder interrupt msg counter.
    */
#ifdef FEATURE_QDSP_ISR_COUNT
    qdsp_cmd_isr_msg_count++;
#endif /* FEATURE_QDSP_ISR_COUNT */
  } /* end while (dsp_msg_type = qdsp_read (QDSP_dspMessageReg) != 0) */

  /* If VR Match is in progress, do not process Encoder and Decoder packets.
  ** Encoder and Decoder are turned off during VR Match state and the DSP's
  ** memory has been re-configured for VR operation.
  */
  if (qdsp_cmd_match_in_progress == TRUE)
  {
    return;
  }
  /*************************************************************************/
  /* Encoder Packet processing                                             */
  /*************************************************************************/

  /* If encoder sempahore flag is set then DSP is ready to tx packet.
  */
  if (qdsp_read (QDSP_encPacketReg) != 0)
  {
    /* Read the frame rate from the DSP.
    */
    qdsp_cmd_enc_frame_rate = qdsp_read (QDSP_encPacketRate);

    /* If we are capturing and we have a valid frame...
    */
    if ((qdsp_cmd_vr_utterance_capture) &&
        (qdsp_cmd_enc_frame_rate == QDSP_RATE_HALF_V))
    {
      /* Set packet length to expected length based on rate.
      */
      qdsp_cmd_enc_packet_length =
        QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS (QDSP_RATE_HALF_V);

      /* Get voice packet from DSP's encoder buffer, need to swap byte for
      ** voice packet.
      */
      qdsp_block_read(QDSP_encPacketBuf, 0,
                      qdsp_cmd_tx_packet,
                      qdsp_cmd_enc_packet_length, FALSE);

      swap ((byte *)qdsp_cmd_tx_packet, (byte *)qdsp_cmd_temp_packet,
            qdsp_cmd_enc_packet_length);

      /* Get frame number and VR band power data from DSP's VR packet buffer,
      ** do not need to swap byte for frame number and VR band power data.
      */

      qdsp_block_read(QDSP_vrPacketBuf, 0,
                      qdsp_cmd_vr_packet,
                      QDSP2_VR_DIAG_LEN, FALSE);

      /* Prepare VR frame data in qdsp_vr_pkt_buf.
      **
      **   First word : qdsp_cmd_enc_frame_rate
      **   Following  : TX packet data
      **   Following  : Frame number
      **   Following  : VR bandpower data
      */
      qdsp_vr_pkt_buf [0] = QDSP_RATE_HALF_V;
      packet_length = 1;
      memcpy (&qdsp_vr_pkt_buf [packet_length],
              qdsp_cmd_temp_packet,
              qdsp_cmd_enc_packet_length * 2);

      packet_length += qdsp_cmd_enc_packet_length;
      memcpy (&qdsp_vr_pkt_buf [packet_length],
              qdsp_cmd_vr_packet,
              QDSP2_VR_DIAG_LEN * 2);

      /* If talk-over-prompt is enabled then it's OK to call endpoint function.
      ** If talk-over-prompt is disabled then call endpoint function only if
      ** Sound is not active (no tones, sound, or voice prompts are playing.)
      */
      if ((qdsp_cmd_talkover_capture == TRUE) ||
          ((qdsp_cmd_talkover_capture == FALSE) &&
           (qdsp_cmd_snd_active_status == FALSE)))
      {
        /* Give VR frame data to function responsible for detecting endpoint.
        */
        if (qdsp_cmd_vr_endpt_cb != (qdsp_cmd_endpt_cb_type) NULL)
        {
          qdsp_cmd_vr_endpt_cb ((byte *) qdsp_vr_pkt_buf);
        }
      }
    }

    /* Output tx frame rates for next frame.
    */
    qdsp_write (QDSP_encMinRate, qdsp_cmd_vr_min_frame_rate);
    qdsp_write (QDSP_encMaxRate, qdsp_cmd_vr_max_frame_rate);

    /* Host clears the semaphore flag when read.
    */
    qdsp_write (QDSP_encPacketReg, 0);

    /* Increment diagnostic mode B/C vocoder interrupt enc counter.
    */
#ifdef FEATURE_QDSP_ISR_COUNT
    qdsp_cmd_isr_enc_count++;
#endif /* FEATURE_QDSP_ISR_COUNT */
  } /* end if QDSP_encPacketReg != 0 */

  /*************************************************************************/
  /* Decoder Packet processing                                             */
  /*************************************************************************/

  /* If decoder sempahore flag is set then DSP is ready to rx packet.
  */
  if (qdsp_read (QDSP_decPacketReg) != 0)
  {
    /* Default frame rate is an erasure.
    */
    frame_rate = QDSP_RATE_ERASURE_V;

    /* If a voice prompt is playing then get the next frame.
    */
    if (qdsp_cmd_vp_rx_playing)
    {
      if (qdsp_cmd_get_vp_rx_frame != NULL)
      {
        (void) qdsp_cmd_get_vp_rx_frame (&frame_rate, &rx_tx_packet);
      }
      else
      {
        ERR ("NULL playback get frame function", 0, 0, 0 );
      }

      /* Make sure we have a valid frame rate.  Otherwise, output an erasure.
      */
      if ((frame_rate <= QDSP_RATE_FULL_V) &&
          ((frame_rate > QDSP_RATE_BLANK_V) ||
           (frame_rate == QDSP_RATE_BLANK_V)))
      {
        /* Determine how much data we want to send for this frame.
        */
        packet_length = QDSP_CMD_VOC_PACKET_DATA_SIZE_WORDS (frame_rate);
      }
      else
      {
        /* We do not have a valid frame rate so send the default erasure.
        */
        packet_length = 0;
      }

      /* Write out frame rate to decoder packet rate.
      */
      qdsp_write (QDSP_decPacketRate, frame_rate);

      /* Output packet data to DSP decoder buffer.
      */
      if (packet_length != 0)
      {
        swap ((byte *) rx_tx_packet, (byte *) qdsp_cmd_temp_packet,
              packet_length);
        /*
        ** output encoder packet data to DSP decoder buffer
        */
        qdsp_block_write(QDSP_decPacketBuf, 0,
                         qdsp_cmd_temp_packet,
                         packet_length, FALSE);
      }
    }
    else
    {
      /* Nothing is playing so send the default erasure.
      */
      qdsp_write (QDSP_decPacketRate, frame_rate);

    } /* endif (qdsp_cmd_vp_rx_playing) */

    /* Host clears the semaphore flag when read.
    */
    qdsp_write (QDSP_decPacketReg, 0);

    /* Increment diagnostic mode B/C vocoder interrupt dec counter.
    */
#ifdef FEATURE_QDSP_ISR_COUNT
    qdsp_cmd_isr_dec_count++;
#endif /* FEATURE_QDSP_ISR_COUNT */
  } /* end if QDSP_decPacketReg != 0 */

  /* Increment diagnostic mode B/C vocoder interrupt counter.
  */
#ifdef FEATURE_QDSP_ISR_COUNT
  qdsp_cmd_isr_count++;
#endif /* FEATURE_QDSP_ISR_COUNT */
  /* Read QDSP state (for debugging purpose).
  */
  /* qdsp_cmd_state = (sint15) qdsp_read(QDSP_qdspState); */

} /* end qdsp_cmd_vr_qdsp2_isr */
#endif /* FEATURE_PHONE_VR */

/* <EJECT> */
#ifdef FEATURE_UP_LOOPBACK_TEST

#if defined(MSMAUD_VOC_1X_COMMON)
/*===========================================================================

FUNCTION QDSP_CMD_uP_PACKET_LOOPBACK_ISR

DESCRIPTION
  This function processes the vocoders encoder and decoder interrupt.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/

void qdsp_cmd_up_packet_loopback_isr ( void )
{
  uint16  enc_semaphore_flag;
  /* flag indicating if packet can be read    */
  uint16  dec_semaphore_flag;
  /* flag indicating if packet can be read    */
  static uint16  frame_rate;
  /* frame rate of Tx packet                 */
  static uint16  tx_packet[17];
  /* tx packet data buffer                   */

  /* Read the encPacketReg and set the semaphore flag         */
  enc_semaphore_flag = qdsp_read(QDSP_encPacketReg);
  /* Read the decPacketReg and set the semaphore flag         */
  dec_semaphore_flag = qdsp_read(QDSP_decPacketReg);

  /* Check whether this is an encoder interrupt */
  if ( enc_semaphore_flag != 0 )
  {
    /* semaphore was not 0 so read out frame rate                      */

    /* Read the frame rate from the DSP                */
    frame_rate = qdsp_read(QDSP_encPacketRate);

    qdsp_block_read(QDSP_encPacketBuf, 0, tx_packet, 17, FALSE);

    /* Host clears the semaphore flag when read                        */
    qdsp_write(QDSP_encPacketReg, 0); /* Clear the semaphore */

    /* Diagnostic transmit frame rate counters */
    switch (frame_rate) {
       case QDSP_RATE_EIGHTH_V:
          qdsp_tx_8++;
          break;
       case QDSP_RATE_QUARTER_V:
          qdsp_tx_4++;
          break;
       case QDSP_RATE_HALF_V:
          qdsp_tx_2++;
          break;
       case QDSP_RATE_FULL_V:
          qdsp_tx_1++;
          break;
       default:
          break;
    }

    qdsp_write(QDSP_encMinRate, QDSP_RATE_EIGHTH_V);

    qdsp_write(QDSP_encMaxRate, QDSP_RATE_FULL_V);

  } /* end if ( enc_semaphore_flag != 0 ) */


  /* Check whether this is a decoder interrupt */
  if ( dec_semaphore_flag != 0 )
  {
    /* semaphore was not 0 so write out frame rate  */
    qdsp_write(QDSP_decPacketRate, frame_rate);

    qdsp_block_write(QDSP_decPacketBuf, 0, tx_packet, 17, FALSE);

    /* Host clears the count to indicate a valid packet is
       available for DSP */
    qdsp_write(QDSP_decPacketReg, 0);

    /* Diagnostic receive frame rate counters */
    switch (frame_rate) {
       case QDSP_RATE_EIGHTH_V:
          qdsp_rx_8++;
          break;
       case QDSP_RATE_QUARTER_V:
          qdsp_rx_4++;
          break;
       case QDSP_RATE_HALF_V:
          qdsp_rx_2++;
          break;
       case QDSP_RATE_FULL_V:
          qdsp_rx_1++;
          break;
       case QDSP_RATE_BLANK_V:
          qdsp_rx_0++;
          break;
       case QDSP_RATE_ERASURE_V:
          qdsp_rx_e++;
          break;
       default:
          break;
    }
  } /* end if ( dec_semaphore_flag != 0 ) */

#ifdef FEATURE_VOC_PCM_INTERFACE
  qdsp_cmd_process_pcm_data();
#endif /* FEATURE_VOC_PCM_INTERFACE */

} /* qdsp_cmd_up_packet_loopback_isr() */

#endif  /* MSMAUD_VOC_1X_COMMON */


/* <EJECT> */
#ifdef MSMAUD_VOC_AMR_WB
/*===========================================================================

FUNCTION QDSP_CMD_AMR_WB_uP_PACKET_LOOPBACK_ISR

DESCRIPTION
  This function processes the AMR-WB vocoders encoder and decoder interrupt.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_amr_wb_up_packet_loopback_isr(void)
{
 static uint16 enc_flag = 0;
 static uint16 amr_wb_lb_packet[30];
 static uint16 lb_semaphore_flag = 0;
                              /* indicate encoder packet is available */
 uint16 dec_flag;


 if (qdsp_read(QDSP_encPacketReg) != 0)
 {
    enc_flag = qdsp_read(QDSP_encFlagWord);
                                 /* recording encoder pkt information */
    qdsp_block_read(QDSP_encPacketBuf, 0, amr_wb_lb_packet, 30, FALSE);

    qdsp_write(QDSP_encPacketReg, 0);

    if (lb_semaphore_flag == 1)
    {
      /* Old encoder packet is overridden. */
      qdsp_cmd_gsm_lb_lost_cnt++;
    }

    lb_semaphore_flag = 1;                     /* handshaking */

    /* statistics */
    qdsp_cmd_gsm_lb_enc_pkt_cnt++;

// YM_DEBUG
 MSG_ERROR("enc_flag %x", enc_flag, 0, 0);
//

 }

 if (qdsp_read(QDSP_decPacketReg) != 0)
 {
    /* Encoder packet not available */
    if (lb_semaphore_flag == 0)
    {
       /* Decoder miss */
       qdsp_cmd_gsm_lb_miss_cnt++;

       dec_flag = (uint16)(QDSP_AMR_WB_SPEECH_BAD & QDSP_AMR_WB_FRAME_TYPE_M)
                  | (uint16)(enc_flag & QDSP_AMR_WB_CODEC_MODE_M);

       qdsp_write(QDSP_decFlagWord, dec_flag);
    }
    else
    {
       /* Preparing the value for QDSP_decFlagWord */
       switch (enc_flag & QDSP_AMR_WB_FRAME_TYPE_M)
       {
         case QDSP_AMR_WB_TX_SPEECH_V :
              dec_flag = (uint16)QDSP_AMR_WB_SPEECH_GOOD;
              break;

         case QDSP_AMR_WB_TX_SID_FIRST_V :
              dec_flag = (uint16)QDSP_AMR_WB_SID_FIRST;
              break;

         case QDSP_AMR_WB_TX_SID_UPDATE_V :
              dec_flag = (uint16)QDSP_AMR_WB_SID_UPDATE;
              break;

         case QDSP_AMR_WB_TX_NO_DATA_V :
              dec_flag = (uint16)QDSP_AMR_WB_NO_DATA;
              break;

         default :
              ERR("Invalid AMR_WB encoder frame type, encFlagWord: %x",
                  enc_flag, 0, 0);
              /* default to QDSP_AMR_WB_SPEECH_BAD */
              dec_flag = (uint16)QDSP_AMR_WB_SPEECH_BAD;
       }

       dec_flag = (dec_flag & QDSP_AMR_WB_FRAME_TYPE_M)
                  | (enc_flag & QDSP_AMR_WB_CODEC_MODE_M);


       /* Deliver packet to QDSP decoder */
       qdsp_write(QDSP_decFlagWord, dec_flag);
       qdsp_block_write(QDSP_decPacketBuf, 0, amr_wb_lb_packet, 30, FALSE);
    }    /* if (lb_semaphore_flag == 0) else */


    /* handshaking */
    lb_semaphore_flag = 0;
    qdsp_write(QDSP_decPacketReg, 0);

    /* statistics */
    qdsp_cmd_gsm_lb_dec_pkt_cnt++;

// YM_DEBUG
 MSG_FATAL("dec_flag %x", dec_flag, 0, 0);
//

 }    /* if (qdsp_read(QDSP_decPacketReg) != 0) */

#ifdef FEATURE_VOC_PCM_INTERFACE
// YM_DEBUG
//  qdsp_cmd_process_pcm_data();
#endif /* FEATURE_VOC_PCM_INTERFACE */

}   /* qdsp_cmd_amr_wb_up_packet_loopback_isr */


#endif  /* MSMAUD_VOC_AMR_WB */


/* <EJECT> */
#if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) \
    || defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_HR)

/*===========================================================================

FUNCTION QDSP_CMD_GSM_uP_PACKET_LOOPBACK_ISR

DESCRIPTION
  This function processes the GSM vocoders encoder and decoder interrupt.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_gsm_up_packet_loopback_isr(void)
{
 static uint16 enc_flag = 0;
 static uint16 gsm_lb_packet[17];
 static uint16 lb_semaphore_flag = 0;
                              /* indicate encoder packet is available */
 uint16 dec_flag;



 if (qdsp_read(QDSP_encPacketReg) != 0)
 {
    enc_flag = qdsp_read(QDSP_encFlagWord);
                                 /* recording encoder pkt information */
    qdsp_block_read(QDSP_encPacketBuf, 0, gsm_lb_packet, 17, FALSE);

    qdsp_write(QDSP_encPacketReg, 0);

    if (lb_semaphore_flag == 1)
    {
      /* Old encoder packet is overridden. */
      qdsp_cmd_gsm_lb_lost_cnt++;
    }

    lb_semaphore_flag = 1;                     /* handshaking */

    /* statistics */
    qdsp_cmd_gsm_lb_enc_pkt_cnt++;
 }


 if (qdsp_read(QDSP_decPacketReg) != 0)
 {
    /* Encoder packet not available */
    if (lb_semaphore_flag == 0)
    {
       /* Decoder miss */
       qdsp_cmd_gsm_lb_miss_cnt++;

#ifdef MSMAUD_VOC_AMR
       if (qdsp_voc_mode == QDSP_VOC_MODE_AMR_V)
       {
          dec_flag = (uint16)(QDSP_AMR_SPEECH_BAD & QDSP_AMR_FRAME_TYPE_M)
                     | (uint16)(enc_flag & QDSP_AMR_CODEC_MODE_M);
       }
       else
#endif
       {
          dec_flag = (uint16)QDSP_GSM_RX_BFI_M;
       }

       qdsp_write(QDSP_decFlagWord, dec_flag);
    }
    else
    {
       /* Preparing the value for QDSP_decFlagWord */
#ifdef MSMAUD_VOC_AMR
       if (qdsp_voc_mode == QDSP_VOC_MODE_AMR_V)
       {
          switch (enc_flag & QDSP_AMR_FRAME_TYPE_M)
          {
            case QDSP_AMR_TX_SPEECH_V :
                 dec_flag = (uint16)QDSP_AMR_SPEECH_GOOD;
                 break;

            case QDSP_AMR_TX_SID_FIRST_V :
                 dec_flag = (uint16)QDSP_AMR_SID_FIRST;
                 break;

            case QDSP_AMR_TX_SID_UPDATE_V :
                 dec_flag = (uint16)QDSP_AMR_SID_UPDATE;
                 break;

            case QDSP_AMR_TX_NO_DATA_V :
                 dec_flag = (uint16)QDSP_AMR_NO_DATA;
                 break;

            default :
                 ERR("Invalid AMR encoder frame type, encFlagWord: %x",
                     enc_flag, 0, 0);
                 /* default to QDSP_AMR_SPEECH_BAD */
                 dec_flag = (uint16)QDSP_AMR_SPEECH_BAD;
          }

          dec_flag = (dec_flag & QDSP_AMR_FRAME_TYPE_M)
                     | (enc_flag & QDSP_AMR_CODEC_MODE_M);
       }
       else
#endif
       {
          dec_flag = (qdsp_cmd_gsm_lb_taf_cnt == 0)?
                     QDSP_GSM_RX_TAF_M : 0;            /* TAF insertion */

#ifdef MSMAUD_VOC_HR
          if (qdsp_voc_mode == QDSP_VOC_MODE_GSM_HR_V)
          {
            dec_flag |= (enc_flag & (QDSP_GSM_HR_RX_SP_M | QDSP_GSM_RX_BFI_M));
          }
#endif
       }


       /* Deliver packet to QDSP decoder */
       qdsp_write(QDSP_decFlagWord, dec_flag);
       qdsp_block_write(QDSP_decPacketBuf, 0, gsm_lb_packet, 17, FALSE);
    }    /* if (lb_semaphore_flag == 0) else */


    /* handshaking */
    lb_semaphore_flag = 0;
    qdsp_write(QDSP_decPacketReg, 0);

    /* statistics */
    qdsp_cmd_gsm_lb_dec_pkt_cnt++;


    /* frame counting for TAF insertion in GSM FR or EFR mode */
#ifdef MSMAUD_VOC_AMR
    if (qdsp_voc_mode != QDSP_VOC_MODE_AMR_V)
    {
#endif
       qdsp_cmd_gsm_lb_taf_cnt = (qdsp_cmd_gsm_lb_taf_cnt == 0)?
                                 QDSP_GSM_LB_UPDATE_TAF_FRAME
                                 : (qdsp_cmd_gsm_lb_taf_cnt - 1);
#ifdef MSMAUD_VOC_AMR
    }
#endif
 }    /* if (qdsp_read(QDSP_decPacketReg) != 0) */

#ifdef FEATURE_VOC_PCM_INTERFACE
  qdsp_cmd_process_pcm_data();
#endif /* FEATURE_VOC_PCM_INTERFACE */

}   /* qdsp_cmd_gsm_up_packet_loopback_isr */


#endif  /* MSMAUD_VOC_AMR || MSMAUD_VOC_FR || MSMAUD_VOC_EFR || MSMAUD_VOC_HR */

#if defined(QDSP_IMAGE_G711_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED) || \
    defined(QDSP_IMAGE_QVP_H263P3_G723_DEFINED) || \
    defined(QDSP_IMAGE_QVP_MPEG4_G723_DEFINED)
/*===========================================================================

FUNCTION QDSP_CMD_WLAN_UP_PACKET_LOOPBACK_ISR

DESCRIPTION
  This function processes the vocoders encoder and decoder interrupt.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_wlan_up_packet_loopback_isr ( void )
{
  uint16  enc_semaphore_flag;     /* flag indicating if packet can be read    */
  uint16  dec_semaphore_flag;     /* flag indicating if packet can be read    */
  static uint16                   wlan_mode;     /* frame rate of Tx packet   */
  static uint16                   tx_packet[80]; /* tx packet data buffer     */
  static uint16                   wlan_frame_length; /* Frame length */
  static uint16                   wlan_dsp_frame_length = 80;

  /* Read the encPacketReg and set the semaphore flag         */
  enc_semaphore_flag = qdsp_read(QDSP_encPacketReg);

  /* Check whether this is an encoder interrupt */
  if ( enc_semaphore_flag != 0 )
  {
    /* semaphore was not 0 so read out frame rate                      */
    if(qdsp_cmd_voc_enc_pkt_drop > 0) {
      qdsp_cmd_voc_enc_pkt_drop--;
      /* handshaking and statistics */
      qdsp_write(QDSP_encPacketReg, 0);      /* notify firmware */
      /* Do not deliver a packet anywhere */
      return;
    }

    /* Read the wlan mode from the DSP */
    switch(qdsp_voc_mode) {
#ifdef MSMAUD_VOC_G711
      case QDSP_VOC_MODE_G711_V:
        wlan_mode = qdsp_read(QDSP_encPacketRate);
        wlan_frame_length = QDSP_CMD_G711_PACKET_LENGTH;
        wlan_dsp_frame_length = 80;
        break;
#endif /* MSMAUD_VOC_G711 */
#ifdef MSMAUD_VOC_G723
      case QDSP_VOC_MODE_G723_V:
        wlan_mode = qdsp_read(QDSP_encPacketRate);
        wlan_frame_length =
                 qdsp_cmd_packet_size_g723[wlan_mode & QDSP_CMD_G723_MODE_MASK];
        wlan_dsp_frame_length = 17;
        break;
#endif /* MSMAUD_VOC_G723 */
      default:
        wlan_frame_length = 0;
        break;
    }

    qdsp_block_read(QDSP_encPacketBuf, 0, tx_packet, wlan_frame_length, FALSE);

    /* Host clears the semaphore flag when read                        */
    qdsp_write(QDSP_encPacketReg, 0); /* Clear the semaphore */

  } /* end if ( enc_semaphore_flag != 0 ) */


  /* Read the decPacketReg and set the semaphore flag         */
  dec_semaphore_flag = qdsp_read(QDSP_decPacketReg);

  /* Check whether this is a decoder interrupt */
  if ( dec_semaphore_flag != 0 )
  {
      /* semaphore was not 0 so write out frame rate  */
      qdsp_write(QDSP_decPacketRate, wlan_mode);

      qdsp_block_write(QDSP_decPacketBuf, 0, tx_packet, wlan_frame_length, FALSE);
      qdsp_block_set(QDSP_decPacketBuf, wlan_frame_length, 0,
                                       wlan_dsp_frame_length-wlan_frame_length);

      /* Host clears the count to indicate a valid packet is
         available for DSP */
      qdsp_write(QDSP_decPacketReg, 0);

  } /* end if ( dec_semaphore_flag != 0 ) */

#ifdef FEATURE_VOC_PCM_INTERFACE
  qdsp_cmd_process_pcm_data();
#endif /* FEATURE_VOC_PCM_INTERFACE */

} /* qdsp_cmd_wlan_up_packet_loopback_isr() */
#endif /* defined(QDSP_IMAGE_G711_DEFINED) || \
          defined(QDSP_IMAGE_VOC_COMBO_DEFINED) || \
          defined(QDSP_IMAGE_QVP_H263P3_G723_DEFINED) || \
          defined(QDSP_IMAGE_QVP_MPEG4_G723_DEFINED) */

#endif /* FEATURE_UP_LOOPBACK_TEST */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_INIT

DESCRIPTION
  This function will initialize the qdsp command layer.

DEPENDENCIES
  None

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_init ( boolean pcm_path )
{

  /* Initialize the CODEC_CTL register
  */
#ifdef MSMAUD_INIT_AUX_CODEC
  if (qdsp_cmd_arm_ctrl_aux_pcm_clk != TRUE)
#endif
  {
  MSMAUD_INIT_CODEC();
  }

#ifdef MSMAUD_SEL_PCM_PATH_NORM
  if (pcm_path == TRUE) {
    MSMAUD_SEL_PCM_PATH_NORM();
  }
#endif

  return( QDSP_CMD_SUCCESS );

}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_ISR

DESCRIPTION
  Sets the ISR routine that QDSP Services will call.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_set_isr (
  qdsp_cmd_isr_func_type isr_ptr
)
{
  qdsp_cmd_qdsps_client_type voc_client;

  qdsp_cmd_isr_table[QDSP_ISR_INT0] = isr_ptr;

  /* Change the ISR for all vocoder clients of QDSPS, so that all of them
   * always use the same ISR
   */
  for (voc_client = (qdsp_cmd_qdsps_client_type) 0;
                      voc_client < QDSP_CMD_QDSPS_CLIENT_MAX; voc_client++) {
    if (qdsp_cmd_qdsps_clients[voc_client] < QDSP_APP_MAX) {
      /* Register with QDSP Services
      */
      qdsp_register_app(
        qdsp_cmd_qdsps_clients[voc_client],
        qdsp_cmd_isr_table,
        qdsp_event_cb,
        qdsp_event_mask
      );
    }
  }
}

/* <EJECT> */
#if defined(FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
/*===========================================================================

FUNCTION qdsp_cmd_image_supports_pp

DESCRIPTION
 Checks to see if the current image supports ARM PP

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
boolean qdsp_cmd_image_supports_pp (void)
{
  boolean retval = FALSE;

  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_RA_DEFINED)           || \
    defined(QDSP_IMAGE_I2SSBC_DEFINED)       || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_QTV_VOC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_QTV_DEFINED) /* A2DP support for for NB-AMR */

#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif
#ifdef QDSP_IMAGE_I2SSBC_DEFINED
    case QDSP_IMAGE_I2SSBC:
#endif
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
       /* A2DP support for for NB-AMR */
#ifdef QDSP_IMAGE_QTV_DEFINED
  case QDSP_IMAGE_QTV:
#endif /* QDSP_IMAGE_QTV_DEFINED */
#ifdef QDSP_IMAGE_QTV_VOC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED */
      retval = TRUE;
      break;
#endif
    default:
      break;
  }
  return retval;
}
/*===========================================================================

FUNCTION qdsp_cmd_pp_enable

DESCRIPTION
  Enables ARM Post Processing

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_register_pp_cb (
  qdsp_cmd_arm_pp_cb_type pp_cb,
  qdsp_cmd_pp_type_type pp_type
) {
  qdsp_cmd_status_type status = QDSP_CMD_FAILED;
  boolean ret_val = TRUE;
  if (qdsp_cmd_image_supports_pp()) {
      if (pp_cb != NULL)
      {
        /* We have a valid call back, so enable the interface and
        set the callback */

        qdsp_cmd_arm_pp_cb = pp_cb;
        qdsp_cmd_pp_state = QDSP_CMD_ARM_PP_STATE_BUF_AVAIL;
        qdsp_cmd_pp_type   = pp_type;
        ret_val = qdsp_cmd_pp_reset();
		if (ret_val == FALSE) {
          return status;
        }
#ifdef FEATURE_SBC_DSP_CODEC
        if (pp_type == QDSP_CMD_PP_TYPE_DSP_SBC)
        {
          qdsp_write(QDSP_hostOutIntfActive,    QDSP_CMD_ARM_PP_DIS_V);
          qdsp_write(QDSP_hostOutIntfSBCActive, QDSP_CMD_ARM_PP_SBC_DIS_V);
          qdsp_write(QDSP_hostOutIntfXferDone,  QDSP_CMD_SBC_CLR_DME_FLAG);
        } else
#elif defined (FEATURE_SBC_CODEC)
        if (pp_type == QDSP_CMD_PP_TYPE_SBC)
        {
          qdsp_write(QDSP_hostOutIntfActive, QDSP_CMD_ARM_PP_ENA_V);
          qdsp_write(QDSP_hostOutIntfSBCActive, QDSP_CMD_ARM_PP_SBC_ENA_V);
        } else
#endif /* FEATURE_SBC_CODEC */
        {
          qdsp_write(QDSP_hostOutIntfActive, QDSP_CMD_ARM_PP_ENA_V);
        }
      }
      else
      {
        qdsp_cmd_arm_pp_cb = NULL;
        qdsp_write(QDSP_hostOutIntfActive, QDSP_CMD_ARM_PP_DIS_V);
#ifdef FEATURE_SBC_CODEC
        qdsp_write(QDSP_hostOutIntfSBCActive, QDSP_CMD_ARM_PP_SBC_DIS_V);
#endif /* FEATURE_SBC_CODEC */
      }
      status = QDSP_CMD_SUCCESS;
  }
  return status;
}
/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_pp_disable

DESCRIPTION
  Disables ARM Post Processing

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
void qdsp_cmd_pp_disable ( void )
{
  if (qdsp_cmd_arm_pp_cb != NULL)
  {
    qdsp_cmd_arm_pp_cb = NULL;
    qdsp_write(QDSP_hostOutIntfActive, QDSP_CMD_ARM_PP_DIS_V);
  }
}
/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_pp_init_buffer_pool

DESCRIPTION
 Initializes the ARM Post Processing Buffer Pool(s)

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
boolean qdsp_cmd_pp_init_buffer_pool(void)
{
  uint32 i,k = 0;

  qdsp_cmd_pp_read_q_pending_num = 0;
#ifdef FEATURE_ARM_POST_PROCESSING
  qdsp_cmd_pp_write_q_head = 0;
  qdsp_cmd_pp_write_q_tail = 1;
  qdsp_cmd_pp_write_q_pending_num = 0;
#endif  /* FEATURE_ARM_POST_PROESSING */

  /* free the buffers if the qdsp_cmd_arm_pp_cb is NULL i.e. host pcm
     interface is disabled */
  if (qdsp_cmd_arm_pp_cb == NULL) {
    if (qdsp_cmd_pp_read_buffer != NULL) {
      free(qdsp_cmd_pp_read_buffer);
	  qdsp_cmd_pp_read_buffer = NULL;
    }
#ifdef FEATURE_ARM_POST_PROCESSING
    if (qdsp_cmd_pp_write_buffer != NULL) {
      free(qdsp_cmd_pp_write_buffer);
      qdsp_cmd_pp_write_buffer = NULL;
    }
#endif
  } else {
    /* qdsp_cmd_arm_pp_cb is non-NULL allocate the buffers
	   if already not been allocated - to avoid multiple allocations */
    if (qdsp_cmd_pp_read_buffer == NULL) {
      qdsp_cmd_pp_read_buffer = (uint16 *)malloc(2*QDSP_CMD_ARM_PP_BUFFER_SIZE_MAX);
      if (qdsp_cmd_pp_read_buffer == NULL) {
        MSG_FATAL("Memory alocation failed - qdsp_cmd_pp_read_buffer!",0,0,0);
        return FALSE;
      }
	}
    memset((void*)qdsp_cmd_pp_read_buffer, 0, 2*QDSP_CMD_ARM_PP_BUFFER_SIZE_MAX);

#ifdef FEATURE_ARM_POST_PROCESSING
    if (qdsp_cmd_pp_write_buffer == NULL) {
      qdsp_cmd_pp_write_buffer = (uint16 *)malloc(2*QDSP_CMD_ARM_PP_BUFFER_SIZE_MAX);
      if (qdsp_cmd_pp_write_buffer == NULL) {
        MSG_FATAL("Memory alocation failed - qdsp_cmd_pp_write_buffer!",0,0,0);
        return FALSE;
      }
	}
    memset((void*)qdsp_cmd_pp_write_buffer, 0, 2*QDSP_CMD_ARM_PP_BUFFER_SIZE_MAX);
#endif /* FEATURE_ARM_POST_PROCESSING */
    for (i = 0; i < QDSP_CMD_ARM_PP_BUF_TYPE_MAX; i++)
    {
      for (k = 0; k < QDSP_CMD_ARM_PP_NUM_BUF_MAX; k++)
    {
        qdsp_cmd_pp_read_buf_mgr[i].desc[k].flag = QDSP_CMD_ARM_PP_BUFFER_FREE;

#ifdef FEATURE_ARM_POST_PROCESSING
        qdsp_cmd_pp_write_buf_mgr[i].desc[k].flag = QDSP_CMD_ARM_PP_BUFFER_FREE;
#endif /*FEATURE_ARM_POST_PROCESSING */

        if (k < qdsp_cmd_pp_read_buf_mgr[i].num_buf)
        {
          qdsp_cmd_pp_read_buf_mgr[i].desc[k].buf_ptr = qdsp_cmd_pp_read_buffer +
                                      (k * qdsp_cmd_pp_read_buf_mgr[i].buf_size);
#ifdef FEATURE_ARM_POST_PROCESSING
          qdsp_cmd_pp_write_buf_mgr[i].desc[k].buf_ptr = qdsp_cmd_pp_write_buffer+
                                     (k * qdsp_cmd_pp_write_buf_mgr[i].buf_size);
#endif /*FEATURE_ARM_POST_PROCESSING */
        }
        else
        {
          qdsp_cmd_pp_read_buf_mgr[i].desc[k].buf_ptr = NULL;
#ifdef FEATURE_ARM_POST_PROCESSING
          qdsp_cmd_pp_write_buf_mgr[i].desc[k].buf_ptr = NULL;
#endif /*FEATURE_ARM_POST_PROCESSING */

        }
      }
    }
  }
  return TRUE;
}
/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_pp_select_buffer_pool

DESCRIPTION
 This function selects the appropriate buffer pool depending on the size of
 the buffer received from DSP

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
void qdsp_cmd_pp_select_buffer_pool(uint32 buf_size)
{
  int i = 0;
  boolean pool_found = FALSE;

  for (i = 0; i < QDSP_CMD_ARM_PP_BUF_TYPE_MAX; i++)
  {
    if (qdsp_cmd_pp_read_buf_mgr[i].buf_size >= buf_size)
    {
      qdsp_cmd_pp_read_buffer_desc = qdsp_cmd_pp_read_buf_mgr[i].desc;
#ifdef FEATURE_ARM_POST_PROCESSING
      qdsp_cmd_pp_write_buffer_desc = qdsp_cmd_pp_write_buf_mgr[i].desc;

#endif /* FEATURE_ARM_POST_PROCESSING */
      qdsp_cmd_arm_pp_num_buffers = qdsp_cmd_pp_read_buf_mgr[i].num_buf;
      pool_found = TRUE;
      qdsp_cmd_pp_buf_pool_selected = TRUE;
      break;
    }
  }
  if (pool_found == FALSE)
  {
    MSG_FATAL("Unable to find PP buffer pool of size %d\n", buf_size, 0,0);
  }
}
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_PP_GET_BUFFER

DESCRIPTION
  Returns a pointer to the next available buffer or a NULL if no buffers are
  available

  For ARM read/DSP write: This will return the next free buffer from the
  read pool

  For ARM write/DSP read: This will return the next buffer that is ready to
  be sent to DSP.

DEPENDENCIES
  Buffer pool should have been previously initialized

RETURN VALUE
  Pointer to next buffer or NULL

SIDE EFFECTS

==========================================================================*/
uint16* qdsp_cmd_pp_get_buffer(qdsp_cmd_pp_buffer_type_type btype)
{
  uint16* buf_ptr = NULL;
  uint16 temp_index = 0;

  temp_index = (qdsp_cmd_pp_read_q_head + 1 ) % qdsp_cmd_arm_pp_num_buffers;
  if (btype == QDSP_CMD_PP_BUFFER_TYPE_READ)
  {
    if (qdsp_cmd_pp_read_buffer_desc[temp_index].flag ==
                                                    QDSP_CMD_ARM_PP_BUFFER_FREE)
    {
      ++qdsp_cmd_pp_read_q_pending_num;
      qdsp_cmd_pp_read_q_head = temp_index;
      qdsp_cmd_pp_read_buffer_desc[qdsp_cmd_pp_read_q_head].flag =
                                          QDSP_CMD_ARM_PP_BUFFER_ARM_READ_PEND;
      buf_ptr = qdsp_cmd_pp_read_buffer_desc[qdsp_cmd_pp_read_q_head].buf_ptr;
    }
  }
#ifdef FEATURE_ARM_POST_PROCESSING
  else if (btype == QDSP_CMD_PP_BUFFER_TYPE_WRITE)
  {
    temp_index = (qdsp_cmd_pp_write_q_head + 1 ) % qdsp_cmd_arm_pp_num_buffers;
    if (qdsp_cmd_pp_write_buffer_desc[temp_index].flag ==
                                           QDSP_CMD_ARM_PP_BUFFER_DSP_READ_PEND)
    {
      qdsp_cmd_pp_write_q_head = temp_index;
      qdsp_cmd_pp_write_buffer_desc[qdsp_cmd_pp_write_q_head].flag =
                                           QDSP_CMD_ARM_PP_BUFFER_DSP_READ_DONE;
      buf_ptr = qdsp_cmd_pp_write_buffer_desc[qdsp_cmd_pp_write_q_head].buf_ptr;
    }
  }
#endif /* FEATURE_ARM_POST_PROCESSING */
  return (buf_ptr);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_pp_reset

DESCRIPTION
 Resets the PP module's internal data structures including initializing the
 buffer pools and resetting the DSP control words.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
boolean qdsp_cmd_pp_reset(void)
{
  uint16* buf_ptr = NULL;
  boolean status = TRUE;

#ifdef FEATURE_ARM_POST_PROCESSING
  qdsp_cmd_pp_delayed_start = TRUE;
  qdsp_cmd_pp_first_buf_sent = FALSE;
#endif /* FEATURE_ARM_POST_PROCESSING*/
  qdsp_cmd_pp_pause = FALSE;

  if (qdsp_cmd_image_supports_pp()) {
      /* Initialize our buffer pool */
      status = qdsp_cmd_pp_init_buffer_pool();
	  if(status == FALSE) {
        return status;
      }
      /* Temperoraly select the pool with the largest size */
      qdsp_cmd_pp_select_buffer_pool(QDSP_CMD_ARM_PP_MAX_BUF_SIZE);
      qdsp_cmd_pp_buf_pool_selected = FALSE;

      /* Point the DSP to the correct buffer to DME out the PCM data */

      buf_ptr = qdsp_cmd_pp_get_buffer(QDSP_CMD_PP_BUFFER_TYPE_READ);

      if (buf_ptr != NULL)
      {
        qdsp_write(QDSP_hostOutIntfDSPWritePtr, (uint32) buf_ptr);
        qdsp_write(QDSP_hostOutIntfBufferFull, QDSP_CMD_ARM_PP_BUF_AVAILABLE);
      }
      switch (qdsp_cmd_pp_type) {
#ifdef FEATURE_SBC_DSP_CODEC
        case QDSP_CMD_PP_TYPE_DSP_SBC:
          qdsp_write(QDSP_hostOutIntfXferDone, QDSP_CMD_SBC_CLR_DME_FLAG);
          break;
#endif
        default:
          qdsp_write(QDSP_hostOutIntfXferDone, QDSP_CMD_ARM_PP_CLR_DME_FLAG);
          break;
      }
#ifdef FEATURE_ARM_POST_PROCESSING
      qdsp_write(QDSP_hostOutIntfFrameCounter, 0x0000);
      qdsp_write(QDSP_hostOutIntfDataIsReady, QDSP_CMD_ARM_PP_DATA_NOT_READY );
#endif /* FEATURE_ARM_POST_PROCESSING */
  }
  return status;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_PP_FREE_BUFFER

DESCRIPTION
  Frees a buffer to the appropriate pool. This will be called

  1. By the ISR when DSP finishes reading the post processed data from ARM
      to free the write buffer
  2. By the function qdsp_cmd_pp_queue_write_buffer() to free the read
      buffer.

  The ...queue_write_buffer function receives a pointer to the read buffer,
  copies it to the write buffer and frees the read buffer.
  Since we need to know the index of the read buffer to be freed we need to
  be passed the index. But for a write buffer the free will happen only for
  the head which we know and so there is no need to pass it to us.

DEPENDENCIES
  Buffer pool should have been previously initialized

RETURN VALUE
  None

SIDE EFFECTS

==========================================================================*/
void qdsp_cmd_pp_free_buffer(qdsp_cmd_pp_buffer_type_type btype, uint16 index)
{
  uint16 *buf_ptr = NULL;

  if (btype == QDSP_CMD_PP_BUFFER_TYPE_READ)
  {
    if (qdsp_cmd_pp_read_buffer_desc[index].flag ==
                                          QDSP_CMD_ARM_PP_BUFFER_ARM_READ_DONE)
    {
      --qdsp_cmd_pp_read_q_pending_num;
      qdsp_cmd_pp_read_buffer_desc[index].flag = QDSP_CMD_ARM_PP_BUFFER_FREE;

      if (qdsp_cmd_pp_state == QDSP_CMD_ARM_PP_STATE_BUF_FULL)
      {
        /* If we had told the DSP that we were out of buffers, since we
        have a free buffer now we will provide it to DSP */

        qdsp_cmd_pp_read_buffer_desc[index].flag =
                                          QDSP_CMD_ARM_PP_BUFFER_ARM_READ_PEND;

        buf_ptr = qdsp_cmd_pp_read_buffer_desc[index].buf_ptr;

        qdsp_cmd_pp_read_q_head = index;

        /* Clear the buff full flag */
        qdsp_cmd_pp_state = QDSP_CMD_ARM_PP_STATE_BUF_AVAIL;

        qdsp_write(QDSP_hostOutIntfDSPWritePtr, (uint32)buf_ptr);

        qdsp_write(QDSP_hostOutIntfBufferFull, QDSP_CMD_ARM_PP_BUF_AVAILABLE);
      }
    }
  }/* Read buffer */
#ifdef FEATURE_ARM_POST_PROCESSING
  else if (btype == QDSP_CMD_PP_BUFFER_TYPE_WRITE)
  {
    if (qdsp_cmd_pp_write_buffer_desc[qdsp_cmd_pp_write_q_head].flag ==
                                          QDSP_CMD_ARM_PP_BUFFER_DSP_READ_DONE)
    {
      --qdsp_cmd_pp_write_q_pending_num;

      qdsp_cmd_pp_write_buffer_desc[qdsp_cmd_pp_write_q_head].flag =
                                                    QDSP_CMD_ARM_PP_BUFFER_FREE;
    }
  }/* Write Buffer */
#endif /* FEATURE_ARM_POST_PROCESSING */
}

#endif /* FEATURE_ARM_POST_PROCESSING || FEATURE_AVS_WB_PCM_RX_INTERFACE */

/* <EJECT> */
#if defined (FEATURE_SBC_CODEC) || defined (FEATURE_SBC_DSP_CODEC) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
/*===========================================================================

FUNCTION QDSP_CMD_PP_FREE_READ_BUFFER

DESCRIPTION
  Frees a buffer to the read pool. This will be called
DEPENDENCIES
  Buffer pool should have been previously initialized

RETURN VALUE
  None

SIDE EFFECTS

==========================================================================*/
void  qdsp_cmd_pp_free_read_buffer(uint16 buf_index)
{
  qdsp_cmd_pp_free_buffer(QDSP_CMD_PP_BUFFER_TYPE_READ, buf_index);
}
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_PP_QUEUE_READ_BUFFER

DESCRIPTION
 This function queues the buffer, that was read from the DSP , before
 sending it to the application. This returns the current buffer pointer
 as a return value and the current index (which is to be passed on to
 the application) through uint16* argument.

DEPENDENCIES
 Buffer pools should have been initialized

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
uint16* qdsp_cmd_pp_queue_read_buffer(uint16 *index_ptr)
{
  uint16* buf_ptr = NULL;

  if ( qdsp_cmd_pp_read_buffer_desc[qdsp_cmd_pp_read_q_head].flag ==
                                         QDSP_CMD_ARM_PP_BUFFER_ARM_READ_PEND)
  {
    /* ARM has finished reading from DSP, mark this buffer so and return a
    pointer to the buffer and the index to the caller. These will be sent
    to the client */


    qdsp_cmd_pp_read_buffer_desc[qdsp_cmd_pp_read_q_head].flag =
                                          QDSP_CMD_ARM_PP_BUFFER_ARM_READ_DONE;
    buf_ptr = qdsp_cmd_pp_read_buffer_desc[qdsp_cmd_pp_read_q_head].buf_ptr;
    *index_ptr = qdsp_cmd_pp_read_q_head;

  }
  return buf_ptr;
}
/* <EJECT> */
/*===========================================================================

FUNCTION  QDSP_CMD_PP_ARM_READ_DONE

DESCRIPTION
  This function will get called when DSP has finished the DME of a frame to
  ARM. We will send the frame to the application and once the application has
  finished processing the frame we will send it to the DSP. Before sending
  the frame to the application we will point the DSP to the next memory location
  to where the DSP can do the next DME.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
 current_read_index and current_write_index will get changed

==========================================================================*/
void qdsp_cmd_pp_arm_read_done(void)
{
  uint16* buf_ptr = NULL;
  uint16* new_buf_ptr = NULL;
  uint16 frame_size = 0;
  uint16 temp_index = 0;

  /* We have received a Post processing message from DSP */
  switch (qdsp_cmd_pp_type) {
#ifdef FEATURE_SBC_DSP_CODEC
    case QDSP_CMD_PP_TYPE_DSP_SBC:
      switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_WM_DEFINED
        case QDSP_IMAGE_WM:
#endif
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
        case QDSP_IMAGE_RA:
#endif
          frame_size = qdsp_read(QDSP_hostOutIntfFrameSize);
          break;
        default:
          /* These DSP images do not update this interface variable, yet */
          frame_size = QDSP_CMD_ARM_PP_MIN_BUF_SIZE;
          break;
      }
      break;
#endif
    default:
      frame_size = qdsp_read(QDSP_hostOutIntfFrameSize);
      break;
  }

  if (qdsp_cmd_pp_buf_pool_selected == FALSE)
  {
    qdsp_cmd_pp_select_buffer_pool(frame_size);
  }
  buf_ptr = qdsp_cmd_pp_queue_read_buffer(&temp_index);

  new_buf_ptr =  qdsp_cmd_pp_get_buffer(QDSP_CMD_PP_BUFFER_TYPE_READ);

  if (new_buf_ptr != NULL)
  {
    /* Point the DSP to the next write buffer */
    qdsp_write(QDSP_hostOutIntfDSPWritePtr, (uint32)new_buf_ptr);

    /* In case we had previously told the DSP that we are out of buffers
    we will tell now that we have buffers */
    qdsp_write(QDSP_hostOutIntfBufferFull, QDSP_CMD_ARM_PP_BUF_AVAILABLE);
  }
  else
  {
    /* We are out of buffers, tell the DSP that we are out of buffers */
    qdsp_write(QDSP_hostOutIntfBufferFull, QDSP_CMD_ARM_PP_BUF_FULL);
    qdsp_cmd_pp_state = QDSP_CMD_ARM_PP_STATE_BUF_FULL;
    MSG_ERROR("Host Interface Buffer full\n", 0,0,0);
  }

  if ((buf_ptr != NULL) && (qdsp_cmd_arm_pp_cb != NULL))
  {
#ifdef FEATURE_NO_CACHE_LINES
    mmu_invalidate_data_cache();
#else
	/* Added the macro due to new writeback cache policy to invalidate the data from external
	   memory before ARM usses it */
    INVALIDATE_DATA_CACHE((uint32*)buf_ptr, (frame_size * 2));
#endif
    qdsp_cmd_arm_pp_cb (frame_size, buf_ptr, temp_index);
  }
}
#endif /* FEATURE_SBC_CODEC || FEATURE_SBC_DSP_CODEC ||
          FEATURE_AVS_WB_PCM_RX_INTERFACE */

#ifdef FEATURE_ARM_POST_PROCESSING
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_PP_QUEUE_WRITE_BUFFER

DESCRIPTION
  This function queues a buffer that is to be written to the DSP.

DEPENDENCIES
  Buffer pool should have been previously initialized

RETURN VALUE
  SUCCESS or FAILED

SIDE EFFECTS

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_pp_queue_write_buffer
                      (uint16 buf_length, uint16* buffer, uint16 buf_index )
{
  uint32 isave;
  qdsp_cmd_status_type status = QDSP_CMD_FAILED;
  uint16* src = NULL;
  uint16* dest = NULL;

  if (buf_index >= qdsp_cmd_arm_pp_num_buffers ||
        buf_length > QDSP_CMD_ARM_PP_MAX_BUF_SIZE  ||
        buffer != qdsp_cmd_pp_read_buffer_desc[buf_index].buf_ptr ||
        qdsp_cmd_pp_read_buffer_desc[buf_index].flag !=
                                        QDSP_CMD_ARM_PP_BUFFER_ARM_READ_DONE ||
        qdsp_cmd_pp_write_buffer_desc[qdsp_cmd_pp_write_q_tail].flag !=
                                        QDSP_CMD_ARM_PP_BUFFER_FREE)
  {
    /* Houston we have a problem. Either the buffer index is out of bounds
    or buf_length is greater than the max length or simply the buffer does
    not belong to the pool or while the client was processing this data,
    a flush, because of a ffwd or rewind, happened and all the buffer pools got
    re initiated */

    MSG_ERROR("Error in pp queue write buffer\n", 0,0,0);
    status = QDSP_CMD_FAILED;
  }
  else
  {
    /* we will copy the buffer to the tail of the write queue and
    free the read buffer */

    src =  qdsp_cmd_pp_read_buffer_desc[buf_index].buf_ptr;
    dest = qdsp_cmd_pp_write_buffer_desc[qdsp_cmd_pp_write_q_tail].buf_ptr;

    memcpy((uint8*)dest, (uint8*)src, buf_length * 2);

	/* Added due to new writeback cache policy to flush the data to external memory
	   before passing to DSP */
    FLUSH_DATA_CACHE(dest, (buf_length * 2));

    qdsp_cmd_pp_free_buffer(QDSP_CMD_PP_BUFFER_TYPE_READ, buf_index);


    INTLOCK_SAV (isave);

    qdsp_cmd_pp_write_buffer_desc[qdsp_cmd_pp_write_q_tail].flag =
                                           QDSP_CMD_ARM_PP_BUFFER_DSP_READ_PEND;

    ++qdsp_cmd_pp_write_q_pending_num;

    if (qdsp_cmd_pp_delayed_start &&
       (qdsp_cmd_pp_write_q_pending_num ==
                                         (qdsp_cmd_pp_delayed_start_thres + 1)))
    {
      qdsp_cmd_pp_delayed_start = FALSE;
    }

    INTFREE_SAV (isave);

    /* Grow the tail */
    qdsp_cmd_pp_write_q_tail =
                  (qdsp_cmd_pp_write_q_tail + 1 ) % qdsp_cmd_arm_pp_num_buffers;
    status = QDSP_CMD_SUCCESS;
  }
  return status;
}
/* <EJECT> */
/*===========================================================================

FUNCTION  QDSP_CMD_PP_DSP_READ_DONE

DESCRIPTION
 This function gets called when the DSP has finished reading a buffer
 from ARM. We will free this buffer and will check to see if there is a
 buffer to be sent to the DSP, if yes, we will send it to the DSP.

DEPENDENCIES
 Buffer pools should be initialized

RETURN VALUE
  None

SIDE EFFECTS
  current_write_index will get updated.

==========================================================================*/
void qdsp_cmd_pp_dsp_read_done(void)
{
  /* Called only from ISR context */
  uint16* buf_ptr = NULL;
  static uint16 frame_cnt = 0;

  /* Free the buffer as we are done with it */
  qdsp_cmd_pp_free_buffer(QDSP_CMD_PP_BUFFER_TYPE_WRITE, 0);
  frame_cnt++;


  buf_ptr = qdsp_cmd_pp_get_buffer(QDSP_CMD_PP_BUFFER_TYPE_WRITE);

  if (buf_ptr != NULL)
  {
     qdsp_write(QDSP_hostOutIntfDSPReadPtr, (uint32)buf_ptr);
     qdsp_write(QDSP_hostOutIntfDataIsReady, QDSP_CMD_ARM_PP_DATA_READY );
  }
  else
  {
    /* We dont have any buffers to send to DSP, so let the DSP know about it
     */
    qdsp_write(QDSP_hostOutIntfDataIsReady, QDSP_CMD_ARM_PP_DATA_NOT_READY );
  }
}
/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_pp_client_data

DESCRIPTION
  This is the function called by the client to pass the PP data back to
  the DSP

DEPENDENCIES
  None

RETURN VALUE
  SUCCESS or FAILURE

SIDE EFFECTS
  None

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_pp_client_data
(
  uint16    buf_length,
  uint16    *buffer,
  uint16    buf_index
)
{
  uint16* buf_ptr = NULL;
  qdsp_cmd_status_type status   = QDSP_CMD_FAILED;
  if (qdsp_cmd_image_supports_pp()) {
    /* Queue this buffer on to the write queue */
    status = qdsp_cmd_pp_queue_write_buffer(buf_length, buffer, buf_index);

    if ((status == QDSP_CMD_SUCCESS)&& (qdsp_cmd_pp_delayed_start == FALSE) &&
        (qdsp_cmd_pp_pause == FALSE) &&
        ((qdsp_cmd_pp_write_q_pending_num == 1)||
                                      (qdsp_cmd_pp_first_buf_sent == FALSE)))
    {
      /* When we are here it could be because of

      1. We were in delayed start mode till now and we have buffered the
      required number of buffers and so we can send the first buffer to DSP.
      The subsequent buffers will be sent by the ISR when DSP raises an
      interrupt saying that it has read a buffer.

      (or)

      2. We were not in delayed start mode but somehow so far data was not
      ready and this is the first buffer that has been made ready since we
      said data is not ready.
      */

      qdsp_cmd_pp_first_buf_sent = TRUE;
      buf_ptr = qdsp_cmd_pp_get_buffer(QDSP_CMD_PP_BUFFER_TYPE_WRITE);

      qdsp_write(QDSP_hostOutIntfDSPReadPtr, (uint32) buf_ptr);
      qdsp_write(QDSP_hostOutIntfDataIsReady, QDSP_CMD_ARM_PP_DATA_READY );
    }
  }
  return status;
}
#endif /* FEATURE_ARM_POST_PROCESSING */

#if defined(FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_DO_PP

DESCRIPTION
 Depending on the bits set in hostOutIntfXferDone register this will
 call the appropriate functions to do the PP.

DEPENDENCIES
 Buffer pools should have been initialized

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
void qdsp_cmd_do_pp(uint16 dsp_pp_msg)
{
  if (qdsp_cmd_image_supports_pp()) {
      if ((dsp_pp_msg & QDSP_CMD_ARM_PP_DME_TO_ARM_DONE) &&
                            (qdsp_cmd_pp_pause == FALSE))
      {
        uint16 pause;

        /* We have received data from DSP and are not paused */
        // Check if audio is in pause state
        pause = qdsp_read(QDSP_audioPause);

        if (pause == FALSE)
        {
          qdsp_cmd_pp_arm_read_done();
        }
        else
        {
          MSG_LOW("Audio pause state = 0x%x \n", pause, 0, 0);
        }
      }
#ifdef FEATURE_ARM_POST_PROCESSING
      if (dsp_pp_msg & QDSP_CMD_ARM_PP_DME_TO_DSP_DONE)
      {
        /* DSP is acknowledging the data that we sent */
        qdsp_cmd_pp_dsp_read_done();
      }
#endif /*FEATURE_ARM_POST_PROCESSING */
  }
}

/*===========================================================================

FUNCTION QDSP_CMD_ARM_PP_ISR

DESCRIPTION
  This function processes the interrupts from host interface part of the DSP

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_arm_pp_isr( void )
{
  uint16  dsp_pp_msg = 0;
  if (qdsp_cmd_image_supports_pp() && (qdsp_cmd_arm_pp_cb != NULL)) {
    /* Check if we have received  post processing interrupt from DSP */
    dsp_pp_msg = (uint16)qdsp_read(QDSP_hostOutIntfXferDone);
    if (dsp_pp_msg != 0)
    {
      /* Clear the hostOutIntfXferDone flag */
      switch (qdsp_cmd_pp_type) {
#ifdef FEATURE_SBC_DSP_CODEC
        case QDSP_CMD_PP_TYPE_DSP_SBC:
          qdsp_write(QDSP_hostOutIntfXferDone, QDSP_CMD_SBC_CLR_DME_FLAG);
          break;
#endif
        default:
          qdsp_write(QDSP_hostOutIntfXferDone, QDSP_CMD_ARM_PP_CLR_DME_FLAG);
          break;
      }
      qdsp_cmd_do_pp(dsp_pp_msg);
    }
  }
}
#endif /* FEATURE_ARM_POST_PROCESSING || FEATURE_AVS_WB_PCM_RX_INTERFACE */

/* <EJECT> */
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
#if defined(FEATURE_SBC_DSP_CODEC) && defined(FEATURE_AVS_I2SSBC)
/*===========================================================================

FUNCTION QDSP_CMD_SET_I2SSBC_SAMPLE_RATE

DESCRIPTION
  This function sets the sample rate for the i2s sbc interface

DEPENDENCIES


RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
void qdsp_cmd_set_i2ssbc_sample_rate(
  qdsp_cmd_i2ssbc_sample_rate_type sample_rate
)
{
  qdsp_cmd_i2ssbc_sample_rate = sample_rate;
}
#endif /* FEATURE_SBC_DSP_CODEC && FEATURE_AVS_I2SSBC */

#ifdef FEATURE_SBC_DSP_CODEC
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SBC_CONFIG (command 0x0310)

DESCRIPTION
  This function will send a command to the DSP to configure the SBC encoder.

DEPENDENCIES

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_sbc_config (
  const qdsp_cmd_sbc_codec_config_type *data
)
{
  qdsp_cmd_status_type result = QDSP_CMD_FAILED;  /* Return value */


  /* Local buffer for the command */
  uint16 sbc_config_command[SBC_CONFIG_CMD_SIZE_MAX + 1];

  if(data == NULL) {
    MSG_FATAL("Codec config called in invalid state!",0,0,0);
    return(result);
  }

  if (qdsp_cmd_image_supports_pp()) {
#ifdef FEATURE_AVS_I2SSBC
    if (qdsp_cmd_image_select == QDSP_IMAGE_I2SSBC)
    {
      sbc_config_command[0] = I2SSBC_CONFIG_CMD_SIZE;
      sbc_config_command[1] = I2SSBC_CONFIG_CMD_HDR;
      sbc_config_command[2] = qdsp_cmd_i2ssbc_sample_rate;
      sbc_config_command[3] = data->param_buf;
    } else
#endif
    {
      sbc_config_command[0] = SBC_CONFIG_CMD_SIZE;
      sbc_config_command[1] = SBC_CONFIG_CMD_HDR;
      sbc_config_command[2] = data->param_buf;
    }
    if((result = qdsp2_command( sbc_config_command )) != QDSP_CMD_SUCCESS )
    {
      MSG_HIGH("QDSP2 SBC Configuration Error!", 0, 0, 0);
    }
  }
  return( result );
}
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_sbc_set_bitrate

DESCRIPTION
  This function will set the bitrate for the DSP based SBC encoder.

DEPENDENCIES

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_sbc_set_bitrate (uint32 bitrate)
{
  if (qdsp_cmd_image_supports_pp()) {
    qdsp_write( QDSP_sbcBitRate, bitrate);
  }
}
#endif

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_CODEC_CONFIG (command 0x0301,default_frame_rate)

DESCRIPTION
  This function will send a command to the DSP to configure the codec,
  PCM audio path selection and PCM format selection.

DEPENDENCIES
  This command is only valid when the DSP is in INIT, IDLE, Vocoder
  or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_codec_config (
  const qdsp_cmd_codec_config_type *data , qdsp_cmd_pcm_sample_rate_type
                                                          default_frame_rate)
{
#ifndef MSMAUD_SCMM
#if defined(MSMAUD_ADIE_UNPLUG_RX) && defined(MSMAUD_ADIE_RESTORE_RX)
  msmaud_adie_codec_config_type rx_codec;
  uint32 isave;
#endif
#endif  /* SMAUD_SCMM */

  qdsp_cmd_status_type result = QDSP_CMD_FAILED;  /* Return value */

  /* Local buffer for the command */
  uint16 codec_config_command[CODEC_CONFIG_CMD_SIZE + 1];

  if(data == NULL) {
    MSG_FATAL("Codec config called in invalid state!",0,0,0);
    return(result);
  }


  /* Setup the DMA channels if necessary */
  switch(qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif
#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
#endif /* QDSP_IMAGE_AACENC_DEFINED */
    default:
#ifdef MSMAUD_UP_DMA_PATH_CONTROL
      qdsp_write( QDSP_upDmaPathControl, data->dma_path );
#endif /* MSMAUD_UP_DMA_PATH_CONTROL */
      break;

#ifdef FEATURE_QVPHONE

      /* QVP_MPEG4_AMR and QVTP_MPEG4_EVRC will use the dmaPath value
      ** in qdsp_cmd_codec_config_type structure.
      */

#ifdef QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_H263:
#ifdef MSMAUD_UP_DMA_PATH_CONTROL
      qdsp_write( QDSP_upDmaPathControl, 0x58 );
#endif /* MSMAUD_UP_DMA_PATH_CONTROL */
      break;
#endif /* QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED */

#ifdef QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_MPEG4:
#ifdef MSMAUD_UP_DMA_PATH_CONTROL
      qdsp_write( QDSP_upDmaPathControl, 0x58 );
#endif /* MSMAUD_UP_DMA_PATH_CONTROL */
      break;
#endif /* QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED */
#if defined (QDSP_IMAGE_QVP_H263P3_AMR_DEFINED) ||\
    defined (QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED)  ||\
    defined (QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED) ||\
    defined (QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED) ||\
    defined (QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED) || \
    defined (QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED)

#ifdef QDSP_IMAGE_QVP_H263P3_AMR_DEFINED
    case QDSP_IMAGE_QVP_H263P3_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED
    case QDSP_IMAGE_QVP_H263P3_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED
#error code not present
#endif
#ifdef MSMAUD_UP_DMA_PATH_CONTROL
      qdsp_write( QDSP_upDmaPathControl, 0x180 );
#endif /* MSMAUD_UP_DMA_PATH_CONTROL */
      break;
#endif

#ifdef QDSP_IMAGE_QVP_BAYER_AMR_DEFINED
    case QDSP_IMAGE_QVP_BAYER_AMR:
#ifdef MSMAUD_UP_DMA_PATH_CONTROL
      qdsp_write( QDSP_upDmaPathControl, 0x58 );
#endif /* MSMAUD_UP_DMA_PATH_CONTROL */
      break;
#endif /* QDSP_IMAGE_QVP_BAYER_AMR_DEFINED */

#endif /* FEATURE_QVPHONE */

#ifdef FEATURE_GRAPH_AUDIO
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */
#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */
#ifdef QDSP_IMAGE_MP4D_DEFINED
    case QDSP_IMAGE_MP4D:
#endif /* QDSP_IMAGE_MP4D_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AMR_DEFINED
    case QDSP_IMAGE_MP4D_AMR:
#endif /* QDSP_IMAGE_MP4D_AMR_DEFINED */
#ifdef QDSP_IMAGE_H263D_DEFINED
    case QDSP_IMAGE_H263D:
#endif /* QDSP_IMAGE_H263D_DEFINED */
#ifdef QDSP_IMAGE_H263D_AMR_DEFINED
    case QDSP_IMAGE_H263D_AMR:
#endif /* QDSP_IMAGE_H263D_AMR_DEFINED */
#ifdef QDSP_IMAGE_H264D_AMR_DEFINED
    case QDSP_IMAGE_H264D_AMR:
#endif /* QDSP_IMAGE_H264D_AMR_DEFINED */
#ifdef QDSP_IMAGE_H264D_EVRC_DEFINED
#error code not present
#endif /* QDSP_IMAGE_H264D_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_13K_DEFINED
    case QDSP_IMAGE_AUDDUB_13K:
#endif /* QDSP_IMAGE_AUDDUB_13K_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_EVRC_DEFINED
    case QDSP_IMAGE_AUDDUB_EVRC:
#endif /* QDSP_IMAGE_AUDDUB_EVRC_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_AMR_DEFINED
    case QDSP_IMAGE_AUDDUB_AMR:
#endif /* QDSP_IMAGE_AUDDUB_AMR_DEFINED */
      break;
#endif /* FEATURE_GRAPH_AUDIO */
  }

  codec_config_command[0] = CODEC_CONFIG_CMD_SIZE;
  codec_config_command[1] = CODEC_CONFIG_CMD_HDR;
  codec_config_command[2] = data->pcm_format_ctrl;
  codec_config_command[3] = data->pcm_ctrl;
  codec_config_command[4] = data->codec_func_ctrl;
  codec_config_command[5] = data->codec_interface;
#ifdef MSMAUD_UP_DMA_PATH_CONTROL
  codec_config_command[6] = 0;
  codec_config_command[7] = data->eight_khz_int_mode;
#else
  codec_config_command[6] = data->dma_path;
#endif /* MSMAUD_UP_DMA_PATH_CONTROL */

/* When JPEGD image is loaded the PCM_FORMAT_CTRL should be 13 bit Linear PCM
  and the upsampling from 8 Khz to 64 Khz should be done in the HW and not in
  the firmware */
#ifdef QDSP_IMAGE_JPEGD_DEFINED
if (qdsp_cmd_image_select == QDSP_IMAGE_JPEGD)
{
  codec_config_command[2] = CODEC_PCM_FORMAT_CTRL_JPEGD;
  codec_config_command[6] = CODEC_RESERVED_JPEGD_DTMF_HW_UPSAMPLE;
}
#endif /*QDSP_IMAGE_JPEGD_DEFINED*/


MSG_MED("QDSP Codec Config CMD L1: Size:0x%x HDR:0x%x PCM FMT CTRL:0x%x\n", codec_config_command[0], codec_config_command[1], codec_config_command[2]);
MSG_MED("QDSP Codec Config CMD L2: PCMCtrl:0x%x CodecFuncCtrl:0x%x Codec Interface:0x%x\n", codec_config_command[3], codec_config_command[4], codec_config_command[5]);
#ifdef MSMAUD_UP_DMA_PATH_CONTROL
MSG_MED("QDSP Codec Config CMD L3: 0x%x 0x%x \n", codec_config_command[6], codec_config_command[7], 0);
#else
MSG_MED("QDSP Codec Config CMD L3: 0x%x \n", codec_config_command[6], 0, 0);
#endif

#ifndef MSMAUD_SCMM
#if defined(MSMAUD_ADIE_UNPLUG_RX) && defined(MSMAUD_ADIE_RESTORE_RX)
  INTLOCK_SAV(isave);
  MSMAUD_ADIE_UNPLUG_RX(&rx_codec);
#endif
#endif /* MSMAUD_SCMM */

  /* Now send the CODEC Configuration command to the QDSP */
  if( (result = qdsp2_command( codec_config_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_HIGH("QDSP2 Vocoder CODEC Configuration Error!", 0, 0, 0);
  }

#ifndef MSMAUD_SCMM
#if defined(MSMAUD_ADIE_UNPLUG_RX) && defined(MSMAUD_ADIE_RESTORE_RX)
  MSMAUD_ADIE_RESTORE_RX(&rx_codec);
  INTFREE_SAV(isave);
#endif

#endif /* MSMAUD_SCMM */

#ifdef MSMAUD_INIT_AUX_CODEC
  if (qdsp_cmd_arm_ctrl_aux_pcm_clk == TRUE)
  {
    MSMAUD_INIT_CODEC();
    qdsp_cmd_arm_ctrl_aux_pcm_clk = FALSE;
  }
#endif

#ifdef FEATURE_VOC_PCM_INTERFACE
  qdsp_cmd_init_pcm_current_attribs(default_frame_rate);
#endif  /* FEATURE_VOC_PCM_INTERFACE */

  return( result );
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_DTMF_TONE_REQUEST (command 0x0302)

DESCRIPTION
  This function will send a command to the DSP to enable or disable DTMF tone
  generation and load the DTMF parameters.


DEPENDENCIES
  This command is only valid when the DSP is in IDLE, Vocoder
  or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_dtmf (
  const qdsp_cmd_dtmf_type *data
)
{
  qdsp_cmd_status_type result;             /* Return value                 */

  word dtmf_tone_request_command[7];       /* Local buffer for the command */

#if defined(FEATURE_QSYNTH_COMMON) || defined(FEATURE_QTUNES_COMMON)

	#ifdef FEATURE_CMI
#error code not present
	#else
    		clk_dereg( &qdsp_cmd_audfmt_dtmf_clk_cb );
	#endif
  
#endif /* FEATURE_QSYNTH_COMMON || FEATURE_QTUNES_COMMON */

#ifdef FEATURE_AVS_VOC_DTMF_MIXING
  if ( data->duration != 0 )
  {
    switch( qdsp_cmd_image_select )
    {
#if defined(QDSP_IMAGE_AMR_DEFINED)             || \
    defined(QDSP_IMAGE_AMR_WB_DEFINED)    || \
    defined(QDSP_IMAGE_EFR_DEFINED)             || \
    defined(QDSP_IMAGE_FR_DEFINED)              || \
    defined(QDSP_IMAGE_HR_DEFINED)              || \
    defined(QDSP_IMAGE_VOC_DEFINED)             || \
    defined(QDSP_IMAGE_VOC_EVRC_DEFINED)        || \
    defined(QDSP_IMAGE_VOC_QTV_DEFINED)         || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED)  || \
    defined(QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED)   || \
    defined(QDSP_IMAGE_QVP_H263P3_AMR_DEFINED)  || \
    defined(QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED)  || \
    defined(QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)   || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED) || \
    defined (QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED) || \
    defined (QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED)	|| \
    defined(QDSP_IMAGE_G711_DEFINED)

#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_AMR_DEFINED
    case QDSP_IMAGE_QVP_H263P3_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED
    case QDSP_IMAGE_QVP_H263P3_EVRC:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_G711_DEFINED
    case QDSP_IMAGE_G711:
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED
    case QDSP_IMAGE_QCAMCORDER_COMBO:
#endif
      if( qdsp_cmd_dtmf_mixing_enabled ) {
        qdsp_write(QDSP_dtmfMixingOn, QDSP_CMD_DTMF_MIXING_ENA);
      } else {
        qdsp_write(QDSP_dtmfMixingOn, QDSP_CMD_DTMF_MIXING_DIS);
      }
      break;
#endif
    default:
      break;
    }
  }
#endif /* FEATURE_AVS_VOC_DTMF_MIXING */

  dtmf_tone_request_command[0] = DTMF_TONE_REQUEST_CMD_SIZE;
  dtmf_tone_request_command[1] = DTMF_TONE_REQUEST_CMD_HDR;
  dtmf_tone_request_command[2] = data->dtmf_hi;
  dtmf_tone_request_command[3] = data->dtmf_low;
  dtmf_tone_request_command[4] = data->duration;

  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_GRAPH_AUDIO
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */
#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */
#ifdef QDSP_IMAGE_MP4D_DEFINED
    case QDSP_IMAGE_MP4D:
#endif /* QDSP_IMAGE_MP4D_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AMR_DEFINED
    case QDSP_IMAGE_MP4D_AMR:
#endif /* QDSP_IMAGE_MP4D_AMR_DEFINED */
#ifdef QDSP_IMAGE_H263D_DEFINED
    case QDSP_IMAGE_H263D:
#endif /* QDSP_IMAGE_H263D_DEFINED */
#ifdef QDSP_IMAGE_H263D_AMR_DEFINED
    case QDSP_IMAGE_H263D_AMR:
#endif /* QDSP_IMAGE_H263D_AMR_DEFINED */
#ifdef QDSP_IMAGE_H264D_AMR_DEFINED
    case QDSP_IMAGE_H264D_AMR:
#endif /* QDSP_IMAGE_H264D_AMR_DEFINED */
#ifdef QDSP_IMAGE_H264D_EVRC_DEFINED
#error code not present
#endif /* QDSP_IMAGE_H264D_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_13K_DEFINED
    case QDSP_IMAGE_AUDDUB_13K:
#endif /* QDSP_IMAGE_AUDDUB_13K_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_EVRC_DEFINED
    case QDSP_IMAGE_AUDDUB_EVRC:
#endif /* QDSP_IMAGE_AUDDUB_EVRC_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_AMR_DEFINED
    case QDSP_IMAGE_AUDDUB_AMR:
#endif /* QDSP_IMAGE_AUDDUB_AMR_DEFINED */
#ifndef FEATURE_AVS_QCAM_COMBO_VOC_INTERFACE
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
#endif /* QDSP_IMAGE_QCAMCORDER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#endif /* FEATURE_AVS_QCAM_COMBO_VOC_INTERFACE */
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
#endif /* QDSP_IMAGE_AACENC_DEFINED */

#if defined(QDSP_IMAGE_QCAMERA_DEFINED)      || \
    defined(QDSP_IMAGE_VFE_BAYER_DEFINED)    || \
    defined(QDSP_IMAGE_VFE_YCBCR_DEFINED)    || \
    defined(QDSP_IMAGE_MP4D_DEFINED)         || \
    defined(QDSP_IMAGE_MP4D_AMR_DEFINED)     || \
    defined(QDSP_IMAGE_H263D_DEFINED)        || \
    defined(QDSP_IMAGE_H263D_AMR_DEFINED)    || \
    defined(QDSP_IMAGE_H264D_AMR_DEFINED)    || \
    defined(QDSP_IMAGE_H264D_EVRC_DEFINED)   || \
    defined(QDSP_IMAGE_MP4E_DEFINED)         || \
    defined(QDSP_IMAGE_MP4E_BAYER_DEFINED)   || \
    defined(QDSP_IMAGE_MP4E_13K_DEFINED)     || \
    defined(QDSP_IMAGE_MP4E_EVRC_DEFINED)    || \
    defined(QDSP_IMAGE_MP4E_AMR_DEFINED)     || \
    defined(QDSP_IMAGE_AUDDUB_13K_DEFINED)   || \
    defined(QDSP_IMAGE_AUDDUB_EVRC_DEFINED)  || \
    defined(QDSP_IMAGE_AUDDUB_AMR_DEFINED)   || \
    defined(QDSP_IMAGE_QCAMCORDER_DEFINED)   || \
    defined(QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_AACENC_DEFINED)

      dtmf_tone_request_command[0] = GRAPH_DTMF_TONE_REQUEST_CMD_SIZE;
      dtmf_tone_request_command[5] = data->rx_gain;
      break;
#endif
#endif /* FEATURE_GRAPH_AUDIO */

    default:
      dtmf_tone_request_command[5] = data->tx_gain;
      dtmf_tone_request_command[6] = data->rx_gain;
      break;
  }

  switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
      /* Now send the DTMF command to the QDSP */
      result = qdsp_mixer_command(dtmf_tone_request_command);
      MSG_LOW("DTMF command for Mixer is issued!",0,0,0);
      break;
#endif // FEATURE_AVS_INCALL_MIXER_ADEC_PB
    default:
      /* Now send the DTMF Tone Request command to the QDSP2 */
      result = qdsp2_command( dtmf_tone_request_command );
      break;
  }

  if( result != QDSP_CMD_SUCCESS ) {
#if defined(FEATURE_QSYNTH_COMMON) || defined(FEATURE_QTUNES_COMMON)

    switch(qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_SYNTH_DEFINED
      case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
      case QDSP_IMAGE_Q3D:
#endif /* QDSP_IMAGE_Q3D_DEFINED */
#ifdef QDSP_IMAGE_QGL_DEFINED
      case QDSP_IMAGE_QGL:
#endif /* QDSP_IMAGE_QGL_DEFINED */
#ifdef QDSP_IMAGE_TUNES_DEFINED
      case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
      case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
      case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
      case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
      case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
      case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif /*QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
      case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
      case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
      case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
      case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
      case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
      case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_WM_DEFINED
      case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
      case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
      case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */

        qdsp_cmd_audfmt_dtmf_retry = *data;

        /* Set up callback to retry DTMF command in 5 ms. */

        
        
	#ifdef FEATURE_CMI
#error code not present
	#else

        clk_reg(
          &qdsp_cmd_audfmt_dtmf_clk_cb, /* Call-back structure to register  */
          qdsp_cmd_dtmf_retry,             /* Routine called by Clock Services */
          10L,                             /* Call routine after 10ms          */
          0L,                              /* De-register after first call     */
          FALSE );                         /* Do not call on a periodic basis  */

	#endif
        break;
    }
#endif
    MSG_HIGH("QDSP2 Vocoder DTMF Tone Request Error!", 0, 0, 0);
  }
  return( result );
}

/* <EJECT> */
#if defined(FEATURE_QSYNTH_COMMON) || defined(FEATURE_QTUNES_COMMON)
/*===========================================================================

FUNCTION QDSP_CMD_DTMF_RETRY

DESCRIPTION
  This function will retry a DTMF command for the QSynth image.

DEPENDENCIES
  This command is only valid when the DSP is in QSynth state.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_dtmf_retry (
  int4 ms_interval
  /*lint -esym(715,ms_interval) Tell Lint we know ms_interval parameter
  ** is not used */
) {
  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_QSYNTH_COMMON
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif /* QDSP_IMAGE_Q3D_DEFINED */
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif /* QDSP_IMAGE_QGL_DEFINED */
      if((sint15) qdsp_read(QDSP_qdspState) == QDSP_STATE_SYNTH) {
        (void) qdsp_cmd_dtmf
               ((const qdsp_cmd_dtmf_type *) &qdsp_cmd_audfmt_dtmf_retry);
        break;
      }
#endif /* FEATURE_QSYNTH_COMMON */

#ifdef FEATURE_QTUNES_COMMON
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif /*QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */

      if((sint15) qdsp_read(QDSP_qdspState) == QDSP_STATE_TUNES) {
        (void) qdsp_cmd_dtmf
               ((const qdsp_cmd_dtmf_type *) &qdsp_cmd_audfmt_dtmf_retry);
        break;
      }
#endif /* FEATURE_TUNES_COMMON */

#if defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_CMX)
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
      if((sint15) qdsp_read(QDSP_adecState) == QDSP_STATE_TUNES) {
        (void) qdsp_cmd_dtmf
          ((const qdsp_cmd_dtmf_type *) &qdsp_cmd_audfmt_dtmf_retry);
      }
      break;
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
      if((sint15) qdsp_read(QDSP_adecState) == QDSP_STATE_SYNTH) {
        (void) qdsp_cmd_dtmf
          ((const qdsp_cmd_dtmf_type *) &qdsp_cmd_audfmt_dtmf_retry);
      }
      break;
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB ||
          FEATURE_AVS_INCALL_MIXER_CMX */

#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
      if((sint15) qdsp_read(QDSP_qdspState) == QDSP_STATE_PLAY) {
        (void) qdsp_cmd_dtmf
          ((const qdsp_cmd_dtmf_type *) &qdsp_cmd_audfmt_dtmf_retry);
      }
    break;
#endif /*FEATURE_AUDIO_CAMERA_CONCURRENCY */

    default:
      MSG_MED("Ignore command",0,0,0);
      
      #ifdef FEATURE_CMI
#error code not present
	#else
    		clk_dereg( &qdsp_cmd_audfmt_dtmf_clk_cb );
	#endif
      break;
  }
}
#endif /* FEATURE_QSYNTH_COMMON || FEATURE_QTUNES_COMMON */

/* <EJECT> */
#if defined(FEATURE_EXTERNAL_SDAC) || defined (MSMAUD_CODEC_CLOCK_CTRL)
/*===========================================================================

FUNCTION QDSP_CMD_CHECK_CMD_REG

DESCRIPTION
  This function will check the uP command register to see if the DSP has
  cleared it.


DEPENDENCIES
  None

RETURN VALUE
  True if the semaphore has been cleared
  False if the seaphore has not been cleared

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_check_cmd_reg ( void )
{
  return(!qdsp_read(QDSP_uPCommandReg));
}
#endif /* FEATURE_EXTERNAL_SDAC || MSMAUD_CODEC_CLOCK_CTRL */

/* <EJECT> */
#if defined(FEATURE_QTUNES_COMMON) || defined(FEATURE_QSYNTH_COMMON)
/*===========================================================================

FUNCTION QDSP_CMD_MASTER_VOLUME

DESCRIPTION
  This function sets the master volume setting for audio formats.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_master_volume(
  uint16 vol
)
{
  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_Q3D_DEFINED) || \
    defined(QDSP_IMAGE_QGL_DEFINED) ||\
    defined(QDSP_IMAGE_TUNES_DEFINED) ||\
    defined(QDSP_IMAGE_MP4D_MP3_DEFINED) ||\
    defined(QDSP_IMAGE_AAC_DEFINED) ||\
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) ||\
    defined(QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED) ||\
    defined(QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED) ||\
    defined(QDSP_IMAGE_MP4D_AAC_DEFINED) ||\
    defined(QDSP_IMAGE_H263D_MP3_DEFINED) ||\
    defined(QDSP_IMAGE_H263D_AAC_DEFINED) ||\
    defined(QDSP_IMAGE_H264D_AAC_DEFINED) ||\
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)  || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED) ||\
    defined(QDSP_IMAGE_RA_DEFINED) ||\
    defined(QDSP_IMAGE_WM_DEFINED) ||\
    defined(QDSP_IMAGE_WM_PRO_DEFINED) || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)

#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA */
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
      qdsp_write(QDSP_masterVolume, vol);
      break;
#endif

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
       if ((qdsp_cmd_adec_int_cb_ptr  != NULL) &&
#ifdef FEATURE_AVS_INCALL_ADEC_PB
          (qdsp_cmd_get_state()      == QDSP_STATE_ADEC_VOC) &&
#endif /* FEATURE_AVS_INCALL_ADEC_PB */
#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
          (qdsp_cmd_get_state()      == QDSP_STATE_VOCODER) &&
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB */
          (qdsp_cmd_get_adec_state() == QDSP_STATE_TUNES)) {
        qdsp_write(QDSP_adecVolume,vol);
      }
      break;
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */

#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
      if (qdsp_cmd_get_adec_state() == QDSP_STATE_SYNTH) {
        qdsp_write(QDSP_audioMVolume,vol);
      }
      break;
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */

#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
      if (qdsp_cmd_get_decoder_in_use()==QDSP_CMD_DEC_WAVE){
        /* When WAVE file is played using ACC image the volume settings are
           written to QDSP_rxVolume, which will get reflected in the DSP masterVolume
           as rxVolume is aliased to masterVolume (in acc.sdf file) */
        qdsp_write(QDSP_rxVolume,vol);
      }
      else if (qdsp_cmd_get_decoder_in_use()==QDSP_CMD_DEC_MP3){
      /* For MP3 playback, the volume settings are written to masterVolume that
         will get reflected in the DSP adecVolume */
        qdsp_write(QDSP_masterVolume,vol);
      }
      else {
      }
      break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */

    default:
      break;
  }
  return(QDSP_CMD_SUCCESS);
}
#endif /* FEATURE_QTUNES_COMMON || FEATURE_QSYNTH_COMMON */

#ifdef FEATURE_AUDFMT_SPECTRUM_ANALYZER
/*===========================================================================

FUNCTION qdsp_cmd_set_spectrum_analyzer

DESCRIPTION
  Enables/disables the spectrum analyzer

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_spectrum_analyzer
(
  qdsp_cmd_spectrum_analyzer_cb_type  spa_cb
)
{

  qdsp_cmd_spectrum_analyzer_cb = spa_cb;

  return (QDSP_CMD_SUCCESS);
}
/*===========================================================================

FUNCTION qdsp_cmd_spectrum_analyzer_config

DESCRIPTION
  Configures the spectrum analyzer for the current DSP image

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
void qdsp_cmd_spectrum_analyzer_config
(
  uint16 interval
)
{
  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_RA_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)|| \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif
      if (qdsp_cmd_spectrum_analyzer_cb) {
        qdsp_write(QDSP_spaSampleInterval, interval);
      } else {
        qdsp_write(QDSP_spaSampleInterval, 0);
      }
      break;
#endif /* QDSP_IMAGE_AAC_DEFINED     || QDSP_IMAGE_ENH_AAC_PLUS_DEFINED ||
          QDSP_IMAGE_QTV_AAC_DEFINED || QDSP_IMAGE_SYNTH_DEFINED        ||
          QDSP_IMAGE_TUNES_DEFINED   || QDSP_IMAGE_WM_DEFINED           ||
          QDSP_IMAGE_RA_DEFINED      || QDSP_IMAGE_QTV_CONC_DEFINED     ||
          QDSP_IMAGE_VOC_MP3_DEFINED || QDSP_IMAGE_VOC_EVRC_MP3_DEFINED ||
          QDSP_IMAGE_AMR_MP3_DEFINED || QDSP_IMAGE_EFR_MP3_DEFINED      ||
          QDSP_IMAGE_FR_MP3_DEFINED  || QDSP_IMAGE_HR_MP3_DEFINED       ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
    default:
      break;
  }
}

/*===========================================================================

FUNCTION qdsp_cmd_do_spectrum_analyzer

DESCRIPTION
  Process the spectrum analyzer interrupt for the current DSP image

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
void qdsp_cmd_do_spectrum_analyzer( void )
{
  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_RA_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)|| \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED */
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif
      if (qdsp_read(QDSP_spaCoeffReady) &&
          (qdsp_cmd_spectrum_analyzer_cb != NULL))
      {
        qdsp_block_read(QDSP_spaCoefficientBuf, 0,
                        qdsp_cmd_spectrum_analyzer_buffer,
                        QDSP_CMD_SPA_NUM_COEFFS, FALSE);
        qdsp_write(QDSP_spaCoeffReady, 0);
        qdsp_cmd_spectrum_analyzer_cb(qdsp_cmd_spectrum_analyzer_buffer);
      }
      break;
#endif /* QDSP_IMAGE_AAC_DEFINED     || QDSP_IMAGE_ENH_AAC_PLUS_DEFINED ||
          QDSP_IMAGE_QTV_AAC_DEFINED || QDSP_IMAGE_SYNTH_DEFINED        ||
          QDSP_IMAGE_TUNES_DEFINED   || QDSP_IMAGE_WM_DEFINED           ||
          QDSP_IMAGE_RA_DEFINED      || QDSP_IMAGE_QTV_CONC_DEFINED     ||
          QDSP_IMAGE_VOC_MP3_DEFINED || QDSP_IMAGE_VOC_EVRC_MP3_DEFINED ||
          QDSP_IMAGE_AMR_MP3_DEFINED || QDSP_IMAGE_EFR_MP3_DEFINED      ||
          QDSP_IMAGE_FR_MP3_DEFINED  || QDSP_IMAGE_HR_MP3_DEFINED      ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED  */
    default:
      break;
  }
}
#endif /* FEATURE_AUDFMT_SPECTRUM_ANALYZER */

/* <EJECT> */
#if defined(FEATURE_MIDI) || defined(FEATURE_MIDI_OUT)
/*===========================================================================

FUNCTION QDSP_CMD_QSYNTH_CMD

DESCRIPTION
  This function will issue queued up MIDI commands.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_qsynth_num_commands
  qdsp_cmd_qsynth_num_words
  qdsp_cmd_qsynth_cmd_buffer

===========================================================================*/
void qdsp_cmd_qsynth_cmd (
  int4 ms_interval
  /*lint -esym(715,ms_interval) Tell Lint we know ms_interval parameter
  ** is not used */
) {
  volatile uint16 *buf_ptr;
  boolean synth_ready = FALSE;

  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_Q3D_DEFINED) || \
    defined(QDSP_IMAGE_QGL_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)

#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
    synth_ready = (qdsp_read(QDSP_qdspState) == QDSP_STATE_SYNTH)?TRUE:FALSE;
    break;


#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
      synth_ready = (qdsp_read(QDSP_adecState) == QDSP_STATE_SYNTH)?TRUE:FALSE;
#endif
      break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED || \
          QDSP_IMAGE_Q3D_DEFINED || \
          QDSP_IMAGE_QGL_DEFINED || \
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED  */
  default:
    MSG_ERROR("qdsp_cmd_qsynth_cmd: Invalid fw image", 0, 0, 0);
    break;

  }

  if (synth_ready == TRUE) {
        /*  Get the addresses of the packet buffers in the ARM address space
        */
        buf_ptr = qdsp_address( QDSP_midiMessageBuf,0 );

        if(*buf_ptr != 0) {
          /* Set up callback to retry command in 5 ms. */

          
          
	#ifdef FEATURE_CMI
#error code not present
	#else

          clk_reg(
            &qdsp_cmd_qsynth_cmd_clk_cb, /* Call-back structure to register  */
            qdsp_cmd_qsynth_cmd,         /* Routine called by Clock Services */
            5L,                          /* Call routine after 5ms           */
            0L,                          /* De-register after first call     */
            FALSE );                     /* Do not call on a periodic basis  */
	#endif
          return;
        } else {
          if(qdsp_cmd_qsynth_num_words != 0) {
            qdsp_block_write(QDSP_midiMessageBuf, 1, qdsp_cmd_qsynth_cmd_buffer,
                             qdsp_cmd_qsynth_num_words, FALSE);
            qdsp_write(QDSP_midiMessageBuf, qdsp_cmd_qsynth_num_commands);
          }
        }
      }
  qdsp_cmd_qsynth_num_commands    = 0;
  qdsp_cmd_qsynth_num_words       = 0;
  qdsp_cmd_qsynth_cmd_clk_enabled = FALSE;
}

/*===========================================================================

FUNCTION qdsp_cmd_qsynth_cmd_dereg

DESCRIPTION
  This function deregisters the MIDI command callback

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void qdsp_cmd_qsynth_cmd_dereg ( ){
    
	#ifdef FEATURE_CMI
#error code not present
	#else
    		clk_dereg( &qdsp_cmd_qsynth_cmd_clk_cb );
	#endif
  
  MSG_HIGH( "Dropping commands in MIDI command queue", 0, 0,0);
  qdsp_cmd_qsynth_num_commands    = 0;
  qdsp_cmd_qsynth_num_words       = 0;
  qdsp_cmd_qsynth_cmd_clk_enabled = FALSE;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_MIDI_CMD_BUFFER

DESCRIPTION
  This function will buffer up MIDI comamnds.

DEPENDENCIES
  This function is called within INTLOCK.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  qdsp_cmd_qsynth_num_commands
  qdsp_cmd_qsynth_num_words
  qdsp_cmd_qsynth_cmd_buffer

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_midi_cmd_buffer (
  qdsp_cmd_midi_cmd_type *cmd_buf,
  uint32                 num_cmd
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               buf_len = QDSP_CMD_QSYNTH_MAX_CMD_BUFF_SIZE;

  switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
      buf_len = QDSP_CMD_GRAPHICS_QSYNTH_MAX_CMD_BUFF_SIZE;
      break;
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
      buf_len = QDSP_CMD_GRAPHICS_QSYNTH_MAX_CMD_BUFF_SIZE;
      break;
#endif
  }

  if((num_cmd != 0) && (cmd_buf != NULL)) {
    ret_val = QDSP_CMD_SUCCESS;
    while(num_cmd) {
      if(cmd_buf->num_commands != 0) {
        if((cmd_buf->num_words + qdsp_cmd_qsynth_num_words) <= buf_len) {
          memcpy((uint8 *) &qdsp_cmd_qsynth_cmd_buffer
                                               [qdsp_cmd_qsynth_num_words],
                 (uint8 *) cmd_buf->command_buf, cmd_buf->num_words*2);
          qdsp_cmd_qsynth_num_commands += cmd_buf->num_commands;
          qdsp_cmd_qsynth_num_words    += cmd_buf->num_words;
          cmd_buf->num_commands = 0;
          cmd_buf->num_words    = 0;
        } else {
          ret_val = QDSP_CMD_FAILED;
          break;
        }
      }
      num_cmd--;
      cmd_buf++;
    }

    if((qdsp_cmd_qsynth_num_words != 0) && (!qdsp_cmd_qsynth_cmd_clk_enabled)) {
      /* Set up callback to try command in 10 ms. */

     
      
	#ifdef FEATURE_CMI
#error code not present
	#else

      clk_reg(
        &qdsp_cmd_qsynth_cmd_clk_cb,     /* Call-back structure to register  */
        qdsp_cmd_qsynth_cmd,             /* Routine called by Clock Services */
        10L,                             /* Call routine after 10ms          */
        0L,                              /* De-register after first call     */
        FALSE );                         /* Do not call on a periodic basis  */

	#endif


      qdsp_cmd_qsynth_cmd_clk_enabled = TRUE;
    }
  }

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_MIDI

DESCRIPTION
  This function will send a command to the DSP to play midi tones.

DEPENDENCIES
  This command is only valid when the DSP is in MIDI state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_midi (
  qdsp_cmd_midi_cmd_type *cmd_buf,
  uint32                 num_cmd,
  uint16                 volume
) {
  qdsp_cmd_status_type result; /* Store the return value  */
  uint16               num_words = 0, num_commands = 0;

  volatile uint16 *buf_ptr;

  /*  Get the addresses of the packet buffers in the ARM address space
  */
  buf_ptr = qdsp_address( QDSP_midiMessageBuf,0 );

  if(num_cmd > 1) {
    switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_Q3D_DEFINED
      case QDSP_IMAGE_Q3D:
        num_cmd = 1;
        break;
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
      case QDSP_IMAGE_QGL:
        num_cmd = 1;
        break;
#endif
    }
  }

  INTLOCK();
  if(*buf_ptr == 0) {
    if(qdsp_cmd_qsynth_cmd_clk_enabled) {
      
      
	#ifdef FEATURE_CMI
#error code not present
	#else
    		clk_dereg( &qdsp_cmd_qsynth_cmd_clk_cb );
	#endif


      result = qdsp_cmd_midi_cmd_buffer(cmd_buf, num_cmd);

      /* Issue buffered commands */
      qdsp_cmd_qsynth_cmd(0);

      if(result == QDSP_CMD_FAILED) {
        result = qdsp_cmd_midi_cmd_buffer(cmd_buf, num_cmd);
      }
    } else {
      while(num_cmd) {
        if(cmd_buf->num_commands != 0) {
          qdsp_block_write(QDSP_midiMessageBuf, 1 + num_words,
                           cmd_buf->command_buf, cmd_buf->num_words, FALSE);
          num_commands          += cmd_buf->num_commands;
          num_words             += cmd_buf->num_words;
          cmd_buf->num_commands  = 0;
          cmd_buf->num_words     = 0;
        }
        num_cmd--;
        cmd_buf++;
      }

      if(num_commands > 0) {
        qdsp_write(QDSP_midiMessageBuf, num_commands);
      }
      result = QDSP_CMD_SUCCESS;
    }
  } else {
    result = qdsp_cmd_midi_cmd_buffer(cmd_buf, num_cmd);
  }
  INTFREE();

  return( result );

}
#endif /* defined(FEATURE_MIDI) || defined(FEATURE_MIDI_OUT) */

/* <EJECT> */
#ifdef FEATURE_MIDI
/*===========================================================================

FUNCTION QDSP_CMD_SYNTH_MVOL

DESCRIPTION
  This function sets the synth master volume.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_synth_mvol (
  uint16 vol
) {
  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_Q3D_DEFINED) || \
    defined(QDSP_IMAGE_QGL_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)

#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
      qdsp_write(QDSP_synthMVolume, vol);
      break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED || QDSP_IMAGE_Q3D_DEFINED
         || QDSP_IMAGE_QGL_DEFINED || QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */

    default:
      break;
  }
  return(QDSP_CMD_SUCCESS);
}
#endif /* FEATURE_MIDI */

/* <EJECT> */
#ifdef FEATURE_QSYNTH_COMMON
/*===========================================================================

FUNCTION QDSP_CMD_SYNTH_QDSP2_ISR

DESCRIPTION
  This function processes the interrupt from the QSynth image.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_synth_qdsp2_isr( void )
{
  uint16  dsp_msg_type;      /* flag indicating dsp message type */
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP) || \
    defined(FEATURE_QSYNTH_ADPCM)
  uint16  dsp_sticky_int;    /* flag indicating dsp sticky interrupt */
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP || FEATURE_QSYNTH_ADPCM */
  volatile uint16 *messageReg, *messageBuf;

#if defined(FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
    qdsp_cmd_arm_pp_isr();
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

  switch(qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
      messageReg = QDSP_dspMessageReg;
      messageBuf = QDSP_dspMessageBuf;
      break;
#endif
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
      messageReg = QDSP_dspMessageReg;
      messageBuf = QDSP_dspMessageBuf;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
      messageReg = QDSP_adecDspMessageReg;
      messageBuf = QDSP_adecDspMessageBuf;
      break;
#endif

#endif /* QDSP_IMAGE_SYNTH_DEFINED || QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */

    default:
      MSG_FATAL("synth_qdsp2_isr: should not reach here", 0, 0, 0);
      return;
  }

  dsp_msg_type = qdsp_read(messageReg);

#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP) || \
    defined(FEATURE_QSYNTH_ADPCM)
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
  {

    dsp_sticky_int = qdsp_read(QDSP_adecDataHostStickyInt);

    /* If msg type is non-zero, we have an interrupt pending */
    if ((dsp_sticky_int != 0) && ((dsp_msg_type == 0x311) ||
                                  (dsp_msg_type == 0x312))) {
      if(qdsp_cmd_adec_int_cb_ptr != NULL) {
        /* Tell vocoder task to return the next set of data */
        qdsp_cmd_adec_int_cb_ptr();
      }
    }
  }
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP || FEATURE_QSYNTH_ADPCM */

#ifdef FEATURE_QAUDIOFX
  qdsp_cmd_3d_pos_send_cmd(QDSP_CMD_3D_POS_CMD_Q_ENV,
                           &qdsp_cmd_3d_pos_lsnr_cmd_q);
  qdsp_cmd_3d_pos_send_cmd(QDSP_CMD_3D_POS_CMD_Q_SRC0,
                           &qdsp_cmd_3d_pos_src_cmd_q[0]);
  qdsp_cmd_3d_pos_send_cmd(QDSP_CMD_3D_POS_CMD_Q_SRC1,
                           &qdsp_cmd_3d_pos_src_cmd_q[1]);
  qdsp_cmd_3d_pos_send_cmd(QDSP_CMD_3D_POS_CMD_Q_SRC2,
                           &qdsp_cmd_3d_pos_src_cmd_q[2]);
  qdsp_cmd_3d_pos_send_cmd(QDSP_CMD_3D_POS_CMD_Q_SRC3,
                           &qdsp_cmd_3d_pos_src_cmd_q[3]);
#endif /* FEATURE_QAUDIOFX */

#ifdef FEATURE_AUDIO_FORMAT
  qdsp_cmd_do_av_sync();
#endif /* FEATURE_AUDIO_FORMAT */

  /* Host clears the semaphore flag when read               */
  if (dsp_msg_type != 0) {
    qdsp_write(messageReg, 0); /* Clear the semaphore */
  }

#ifdef FEATURE_AUDFMT_SPECTRUM_ANALYZER
  qdsp_cmd_do_spectrum_analyzer();
#endif /* FEATURE_AUDFMT_SPECTRUM_ANALYZER */

}

#ifndef FEATURE_GASYNTH_INTERFACE
/*===========================================================================

FUNCTION QDSP_CMD_QSYNTH_ADEC_MODE

DESCRIPTION
  This function will set the QSynth audio decoder type.

DEPENDENCIES
  This command is only valid when the DSP is using QSYNTH image and should
  be issued before the first codec config command.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_qsynth_adec_mode (
  uint16 type
) {
#ifdef MSMAUD_QSYNTH_ADEC_MODE_SUPPORT
  qdsp_write(QDSP_midiDecoderType, type);
#endif /* MSMAUD_QSYNTH_ADEC_MODE_SUPPORT */
}
#endif /* FEATURE_GASYNTH_INTERFACE */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_QSYNTH_EMULATE_ISR

DESCRIPTION
  This function manifests ARM-made qsynth interrupt

DEPENDENCIES
  This function should only called in the situation which QSYNTH is in SYNTH
  state.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_qsynth_emulate_isr() {
  qdsp_cmd_synth_qdsp2_isr();
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_DLS_CONFIG

DESCRIPTION
  This function will set the QSynth DLS configuration.

DEPENDENCIES
  This command is only valid when the DSP is using QSYNTH image.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_set_dls_config ( qdsp_cmd_dls_config_type *dls_config )
{
#ifdef MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT
  switch(qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif

#ifdef FEATURE_AUDIO_CMX_5P0
      qdsp_write(QDSP_dlsBankStruct+12, QDSP_DLS_HP_INST_BANK);
      qdsp_write(QDSP_dlsBankStruct+13, dls_config->hp_inst_def);
      qdsp_write(QDSP_dlsBankStruct+15, QDSP_DLS_HP_DRUM_BANK);
      qdsp_write(QDSP_dlsBankStruct+16, dls_config->hp_drum_def);

      qdsp_write(QDSP_dlsBankStruct+18, QDSP_DLS_HQ_INST_BANK);
      qdsp_write(QDSP_dlsBankStruct+19, dls_config->hq_inst_def);
      qdsp_write(QDSP_dlsBankStruct+21, QDSP_DLS_HQ_DRUM_BANK);
      qdsp_write(QDSP_dlsBankStruct+22, dls_config->hq_drum_def);
#else
      qdsp_write(QDSP_dlsProgDefBase, dls_config->hp_inst_def >> 1);
      qdsp_write(QDSP_dlsDrumDefBase, dls_config->hp_drum_def >> 1);
      qdsp_write(QDSP_dlsWfInfoBase, dls_config->hp_wave_info >> 1);

      qdsp_write(QDSP_dlsHqProgPtrPtr, dls_config->hq_inst_def >> 1);
      qdsp_write(QDSP_dlsHqDrumPtrPtr, dls_config->hq_drum_def >> 1);
      qdsp_write(QDSP_dlsHqWfInfoBase, dls_config->hq_wave_info >> 1);
      qdsp_write(QDSP_dlsHqProgPtrSize, dls_config->hq_inst_num);
      qdsp_write(QDSP_dlsHqDrumPtrSize, dls_config->hq_drum_num);
#endif /* FEATURE_AUDIO_CMX_5P0 */
  }
#endif /* MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT */
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_QSYNTH_VOL_MODE

DESCRIPTION
  This function will set the QSynth volume mode configuration.

DEPENDENCIES
  This command is only valid when the DSP is using QSYNTH image.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_set_qsynth_vol_mode ( uint16 vol_mode )
{
#if (defined(MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT) && \
     (!defined(FEATURE_AUDIO_CMX_5P0)))
   switch(qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
    qdsp_write(QDSP_volumeLookupIndex, vol_mode);
  }
#endif /* MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT && !FEATURE_AUDIO_CMX_5P0 */
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_HYBRID_MODE

DESCRIPTION
  This function will set the QSynth hybrid mode configuration.

DEPENDENCIES
  This command is only valid when the DSP is using QSYNTH image.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_set_hybrid_mode ( uint8 hybrid_mode )
{
#ifdef MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT
  switch(qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
    qdsp_write(QDSP_hybridMode, (uint16) hybrid_mode);
  }
#endif /* MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT */
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_PAUSE_MIDI_SEQ

DESCRIPTION
  This function will set the pause flag.

DEPENDENCIES
  This command is only valid when the DSP is using QSYNTH image.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_pause_midi_seq (
  uint32  sequence,
  boolean pause_flag
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_SUCCESS;

  switch(qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#if defined(QDSP_IMAGE_SYNTH_DEFINED)
  case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#if defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
  case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
    qdsp_write_offset(QDSP_audioPause, sequence, (uint16)pause_flag);
    break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED || QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
  default:
    ret_val = QDSP_CMD_FAILED;
  }

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_VOL_MIDI_SEQ

DESCRIPTION
  This function sets the volume for indicated sequence.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_vol_midi_seq (
  uint16 sequence,
  uint16 volume
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_SUCCESS;

#ifdef MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT
  switch(qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef QDSP_IMAGE_SYNTH_DEFINED
  case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
  case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
    qdsp_write_offset(QDSP_seqMVolume, sequence, volume);
    break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
  default:
    ret_val = QDSP_CMD_FAILED;
  }
#endif /* MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT */
  return(ret_val);
}
#endif /* FEATURE_QSYNTH_COMMON */

/* <EJECT> */
#if defined(FEATURE_QSYNTH_ADRC) || defined(FEATURE_QTUNES_ADRC)
/*===========================================================================

FUNCTION qdsp_cmd_set_audfmt_adrc_ctl

DESCRIPTION
  This function configures the ADRC controls through DMA.

DEPENDENCIES
  FEATURE_QSYNTH_ADRC.

RETURN VALUE
  qdsp_cmd_status_type.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_audfmt_adrc_ctl
(
  qdsp_cmd_audfmt_adrc_ctl_type *adrc
)
{
  if (adrc != NULL) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_RA_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)

    switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_SYNTH_DEFINED
      case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_TUNES_DEFINED
      case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
      case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
      case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
      case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
      case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
      case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
      case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
      case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
      case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
      case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
      case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
      case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
      case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
      case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
        /* Disable the ADRC before writing new config
        */
        qdsp_write( QDSP_adrcFlag, 0x0000 );

        /* Write new ADRC config
        */
        qdsp_write( QDSP_compThreshold, adrc->threshold );
        qdsp_write( QDSP_compSlope, adrc->slope );
        qdsp_write( QDSP_compRmsTav, adrc->rms_tav );
        qdsp_block_write( QDSP_compAttackK, 0, adrc->attack, 2, FALSE );
        qdsp_block_write( QDSP_compReleaseK, 0, adrc->release, 2, FALSE );
        qdsp_write( QDSP_compDelay, adrc->delay );
        qdsp_write( QDSP_adrcFlag, adrc->flag );
        break;

      default:
        break;
    }
#endif /* QDSP_IMAGE_SYNTH_DEFINED   || QDSP_IMAGE_TUNES_DEFINED        ||
          QDSP_IMAGE_AAC_DEFINED     || QDSP_IMAGE_QTV_AAC_DEFINED      ||
          QDSP_IMAGE_WM_DEFINED      || QDSP_IMAGE_ENH_AAC_PLUS_DEFINED ||
          QDSP_IMAGE_RA_DEFINED      || QDSP_IMAGE_QTV_CONC_DEFINED     ||
          QDSP_IMAGE_VOC_MP3_DEFINED || QDSP_IMAGE_VOC_EVRC_MP3_DEFINED ||
          QDSP_IMAGE_AMR_MP3_DEFINED || QDSP_IMAGE_EFR_MP3_DEFINED      ||
          QDSP_IMAGE_FR_MP3_DEFINED  || QDSP_IMAGE_HR_MP3_DEFINED       */
  }
  return( QDSP_CMD_SUCCESS );
}
#endif /* FEATURE_QSYNTH_ADRC || FEATURE_QTUNES_ADRC */

/* <EJECT> */
#ifdef FEATURE_AUDFMT_FIR_FILTER
/*===========================================================================

FUNCTION qdsp_cmd_set_audfmt_pcm_filter

DESCRIPTION
  This function configures the PCM Filter through DMA for Qsynth or Qtunes.

DEPENDENCIES
  FEATURE_AUDFMT_FIR_FILTER.

RETURN VALUE
  qdsp_cmd_status_type.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_audfmt_pcm_filter
(
  qdsp_cmd_audfmt_pcm_filter_type *filter
)
{
  uint16 coeff_max;
  if (filter != NULL) {
    switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)

#ifdef QDSP_IMAGE_TUNES_DEFINED
      case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
      case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
      case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
      case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
      case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
      case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
      case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_AAC_DEFINED
      case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
      case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
      case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
      case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
        coeff_max = QDSP_QTUNES_COEFF_MAX;
        break;
#endif /* QDSP_IMAGE_TUNES_DEFINED        || QDSP_IMAGE_AAC_DEFINED      ||
          QDSP_IMAGE_ENH_AAC_PLUS_DEFINED || QDSP_IMAGE_QTV_AAC_DEFINED  ||
          QDSP_IMAGE_WM_DEFINED           || QDSP_IMAGE_QTV_CONC_DEFINED ||
          QDSP_IMAGE_VOC_MP3_DEFINED      ||
          QDSP_IMAGE_VOC_EVRC_MP3_DEFINED ||
          QDSP_IMAGE_AMR_MP3_DEFINED      || QDSP_IMAGE_EFR_MP3_DEFINED  ||
          QDSP_IMAGE_FR_MP3_DEFINED       || QDSP_IMAGE_HR_MP3_DEFINED   */

#if (defined(QDSP_IMAGE_SYNTH_DEFINED) || \
      defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED) && \
     (!defined(FEATURE_AUDFMT_IIR_FILTER))) || \
    defined(QDSP_IMAGE_Q3D_DEFINED)         || \
    defined(QDSP_IMAGE_QGL_DEFINED)

#if (defined(QDSP_IMAGE_SYNTH_DEFINED) && \
     (!defined(FEATURE_AUDFMT_IIR_FILTER)))
      case QDSP_IMAGE_SYNTH:
#endif
#if (defined(QDSP_IMAGE_QSYNTH_RS_DEFINED) && \
     (!defined(FEATURE_AUDFMT_IIR_FILTER)))
#error code not present
#endif
#if (defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED) && \
     (!defined(FEATURE_AUDFMT_IIR_FILTER)))
      case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */

#ifdef QDSP_IMAGE_Q3D_DEFINED
      case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
      case QDSP_IMAGE_QGL:
#endif
        coeff_max = QDSP_QSYNTH_COEFF_MAX;
        break;

#endif /* (QDSP_IMAGE_SYNTH_DEFINED && !FEATURE_AUDFMT_IIR_FILTER) ||
          QDSP_IMAGE_Q3D_DEFINED || QDSP_IMAGE_QGL_DEFINED */
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
       case QDSP_IMAGE_CAM_AUDIO_CONC:
         if ( qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_MP3 ){
           coeff_max = QDSP_QTUNES_COEFF_MAX;
         } else if (qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_WAVE){
           coeff_max = QDSP_QSYNTH_COEFF_MAX;
         }
         break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
      default:
        return( QDSP_CMD_SUCCESS );
    }

    /* Disable the PCM filter before writing new config
    */
    qdsp_write( QDSP_pcmFiltFlag, 0x0000 );

    if (filter->length >= QDSP_AUDFMT_FILTER_MIN_LEN) {
      /* Write new PCM filter config
      */
      qdsp_block_write( QDSP_pcmFiltCoeff, 0,
                        (uint16 *) filter->coeff,
                        MIN(filter->length, coeff_max), FALSE );
      qdsp_write( QDSP_pcmFiltLength, MIN(filter->length, coeff_max));
      qdsp_write( QDSP_pcmFiltCompFactor, filter->factor );
      qdsp_write( QDSP_pcmFiltFlag, filter->flag );
    }
  }
  return( QDSP_CMD_SUCCESS );
}
#endif /* FEATURE_AUDFMT_FIR_FILTER */

/* <EJECT> */
#ifdef FEATURE_AUDFMT_EQUALIZER
/*===========================================================================

FUNCTION qdsp_cmd_check_equalizer_reset

DESCRIPTION
  This function check the Equalizer reset flag.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
boolean qdsp_cmd_check_equalizer_reset
(
  void
)
{
  boolean ret_val = FALSE;

  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_RA_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)

#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
      ret_val = (qdsp_read( QDSP_mbEqReset ) == 0xFFFF);
      break;
#endif /* QDSP_IMAGE_AAC_DEFINED     || QDSP_IMAGE_TUNES_DEFINED        ||
          QDSP_IMAGE_SYNTH_DEFINED   || QDSP_IMAGE_QTV_AAC_DEFINED      ||
          QDSP_IMAGE_WM_DEFINED      || QDSP_IMAGE_ENH_AAC_PLUS_DEFINED ||
          QDSP_IMAGE_RA_DEFINED      || QDSP_IMAGE_QTV_CONC_DEFINED     ||
          QDSP_IMAGE_VOC_MP3_DEFINED || QDSP_IMAGE_VOC_EVRC_MP3_DEFINED ||
          QDSP_IMAGE_AMR_MP3_DEFINED || QDSP_IMAGE_EFR_MP3_DEFINED      ||
          QDSP_IMAGE_FR_MP3_DEFINED  || QDSP_IMAGE_HR_MP3_DEFINED       ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */

#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
     case QDSP_IMAGE_CAM_AUDIO_CONC:
       ret_val = (qdsp_read( QDSP_mbEqReset ) == 0xFFFF);
       break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
    default:
      break;
  }
  return (ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_set_equalizer

DESCRIPTION
  This function configures the Equalizer through DME for Qsynth or Qtunes.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_equalizer
(
  const qdsp_cmd_equalizer_type *equalizer
)
{
  if (equalizer != NULL) {
    switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_RA_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)

#ifdef QDSP_IMAGE_AAC_DEFINED
      case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
      case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_TUNES_DEFINED
      case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
      case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
      case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
      case QDSP_IMAGE_RA:
#endif
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
      case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
      case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
      case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
      case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
      case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
      case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
      case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
      case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif
        qdsp_write(QDSP_mbEqActiveFlag, 0x0000);
        if ((equalizer->enable) && (equalizer->band)) {
          qdsp_write( QDSP_mbEqCoeffExtRamBase, ((uint32)equalizer->coeff)>>1);
          qdsp_write( QDSP_mbEqNumBands, equalizer->band);
          qdsp_write( QDSP_mbEqReset,  0xFFFF);
          qdsp_write( QDSP_mbEqActiveFlag, 0xFFFF);
        }
        break;
#endif /* QDSP_IMAGE_AAC_DEFINED     || QDSP_IMAGE_TUNES_DEFINED        ||
          QDSP_IMAGE_SYNTH_DEFINED   || QDSP_IMAGE_QTV_AAC_DEFINED      ||
          QDSP_IMAGE_WM_DEFINED      || QDSP_IMAGE_ENH_AAC_PLUS_DEFINED ||
          QDSP_IMAGE_RA_DEFINED      || QDSP_IMAGE_QTV_CONC_DEFINED     ||
          QDSP_IMAGE_VOC_MP3_DEFINED || QDSP_IMAGE_VOC_EVRC_MP3_DEFINED ||
          QDSP_IMAGE_AMR_MP3_DEFINED || QDSP_IMAGE_EFR_MP3_DEFINED      ||
          QDSP_IMAGE_FR_MP3_DEFINED  || QDSP_IMAGE_HR_MP3_DEFINED       ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
      case QDSP_IMAGE_CAM_AUDIO_CONC:
        qdsp_write(QDSP_mbEqActiveFlag, 0x0000);
        if ((equalizer->enable) && (equalizer->band)) {
          qdsp_write( QDSP_mbEqCoeffExtRamBase, ((uint32)equalizer->coeff)>>1);
          qdsp_write( QDSP_mbEqNumBands, equalizer->band);
          qdsp_write( QDSP_mbEqReset,  0xFFFF);
          qdsp_write( QDSP_mbEqActiveFlag, 0xFFFF);
        }
       break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */

      default:
        break;
    }
  }
  return( QDSP_CMD_SUCCESS );
}
#endif /* FEATURE_AUDFMT_EQUALIZER */

/* <EJECT> */
#ifdef FEATURE_AUDIO_QENSEMBLE
#error code not present
#endif /* FEATURE_AUDIO_QENSEMBLE */

/* <EJECT> */
#ifdef FEATURE_AUDFMT_QCONCERT
/*===========================================================================

FUNCTION qdsp_cmd_audio_pp_reset_cmd

DESCRIPTION
  Enables ARM Post Processing features (3D expander)

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_audio_pp_reset_cmd( void ) {

  uint16 command[AUDIO_PP_RESET_CMD_SIZE];
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;

  command[0] = AUDIO_PP_RESET_CMD_SIZE;
  command[1] = AUDIO_PP_RESET_CMD_HDR;

  switch(qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
      ret_val = qdsp_adec_command(command);
      break;
#endif
    default:
      ret_val = qdsp2_command(command);
      break;
  }
  return(ret_val);

}

/*===========================================================================

FUNCTION qdsp_cmd_set_qconcert_config

DESCRIPTION
  Configures the Qconcert 3D expander

DEPENDENCIES
  None

RETURN VALUE
  QDSP_CMD_SUCCESS - if successfully set for supported images.
  QDSP_CMD_FAILED  - Command failed, need retry.

SIDE EFFECTS
  None

==========================================================================*/
extern qdsp_cmd_status_type qdsp_cmd_set_qconcert_config(
  const qdsp_cmd_qconcert_config_type *qconcert
) {

  qdsp_cmd_status_type status = QDSP_CMD_SUCCESS;

  if (qconcert != NULL) {
    switch(qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_RA_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)
#ifdef QDSP_IMAGE_TUNES_DEFINED
      case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
      case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_AAC_DEFINED
      case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
      case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
      case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
      case QDSP_IMAGE_RA:
#endif
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
      case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
        if (qconcert->enable == TRUE) {
          if (qdsp_read(QDSP_a3dQxReset) == 0) {
            qdsp_write(QDSP_a3dQxEnable, 0x0000);
            qdsp_write(QDSP_a3dQxOutputMode, qconcert->mode);
            qdsp_write(QDSP_a3dQxDirectGain, qconcert->gain);
            qdsp_write(QDSP_a3dQxSpread, qconcert->spread);
            qdsp_write(QDSP_a3dQxGeometry, qconcert->geometry);
            qdsp_write(QDSP_a3dQxSampRate, qconcert->sample_rate);
            qdsp_write(QDSP_a3dQxReset, 0xFFFF);
            qdsp_write(QDSP_a3dQxEnable, 0xFFFF);
            status = qdsp_cmd_audio_pp_reset_cmd();
          } else {
            status = QDSP_CMD_FAILED;
          }
        } else {
          /* No need to send audio pp reset command */
          qdsp_write(QDSP_a3dQxEnable, 0x0000);
        }
        break;
#endif /* QDSP_IMAGE_TUNES_DEFINED        || QDSP_IMAGE_SYNTH_DEFINED    ||
          QDSP_IMAGE_AAC_DEFINED          || QDSP_IMAGE_QTV_AAC_DEFINED  ||
          QDSP_IMAGE_ENH_AAC_PLUS_DEFINED || QDSP_IMAGE_WM_DEFINED       ||
          QDSP_IMAGE_RA_DEFINED           || QDSP_IMAGE_QTV_CONC_DEFINED  ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
      default:
        break;
    }
  }
  return (status);
}
#endif /* FEATURE_AUDFMT_QCONCERT */


/* <EJECT> */
#ifdef FEATURE_AUDFMT_STF
/*===========================================================================

FUNCTION qdsp_cmd_set_audfmt_sidechain_filter

DESCRIPTION
  Configures the side chain filter

DEPENDENCIES
  None

RETURN VALUE
  QDSP_CMD_SUCCESS

SIDE EFFECTS
  None

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_audfmt_sidechain_filter
(
  const qdsp_cmd_audfmt_sidechain_filter_type *filter
)
{
  if (filter != NULL) {
    switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_RA_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)|| \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)

#ifdef QDSP_IMAGE_SYNTH_DEFINED
      case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_AAC_DEFINED
      case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
      case QDSP_IMAGE_QTV_AAC:
#endif

#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif

#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif

#ifdef QDSP_IMAGE_TUNES_DEFINED
      case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
      case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
      case QDSP_IMAGE_RA:
#endif
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
      case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
      case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
      case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
      case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
      case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
      case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
      case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
      case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
      case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
        qdsp_write( QDSP_stfActiveFlag, 0 );
        if (filter->enable) {
          qdsp_write( QDSP_stfCoeffExtRamBase, ((uint32) filter->coeff)>>1);
          qdsp_write( QDSP_stfNumBands, filter->bands);
          qdsp_write( QDSP_mainChainGain, filter->mainChainGain);
          qdsp_write( QDSP_stfPreGain, filter->sideChainGain);
          qdsp_write( QDSP_stfReset, 0xFFFF);
          qdsp_write( QDSP_stfActiveFlag, 0xFFFF);
        }
        break;
#endif /* QDSP_IMAGE_AAC_DEFINED     || QDSP_IMAGE_ENH_AAC_PLUS_DEFINED ||
          QDSP_IMAGE_QTV_AAC_DEFINED || QDSP_IMAGE_TUNES_DEFINED        ||
          QDSP_IMAGE_WM_DEFINED      || QDSP_IMAGE_SYNTH_DEFINED        ||
          QDSP_IMAGE_RA_DEFINED      || QDSP_IMAGE_QTV_CONC_DEFINED     ||
          QDSP_IMAGE_VOC_MP3_DEFINED || QDSP_IMAGE_VOC_EVRC_MP3_DEFINED ||
          QDSP_IMAGE_AMR_MP3_DEFINED || QDSP_IMAGE_EFR_MP3_DEFINED      ||
          QDSP_IMAGE_FR_MP3_DEFINED  || QDSP_IMAGE_HR_MP3_DEFINED       ||
          QDSP_IMAGE_SYNTH_DEFINED   || QDSP_IMAGE_QTV_AAC_DEFINED      */

      default:
        break;
    }
  }
  return (QDSP_CMD_SUCCESS);
}
#endif /* FEATURE_AUDFMT_STF */

/* <EJECT> */
#ifdef FEATURE_AUDFMT_IIR_FILTER
/*===========================================================================

FUNCTION qdsp_cmd_set_audfmt_iir_filter

DESCRIPTION
  Configures the side chain filter

DEPENDENCIES
  None

RETURN VALUE
  QDSP_CMD_SUCCESS

SIDE EFFECTS
  None

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_audfmt_iir_filter
(
  const qdsp_cmd_audfmt_iir_filter_type *filter
)
{
  if (filter != NULL) {
    switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS)         || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_RA_DEFINED)           || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)     || \
    defined(QDSP_IMAGE_VOC_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_VOC_EVRC_MP3_DEFINED) || \
    defined(QDSP_IMAGE_AMR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_EFR_MP3_DEFINED)      || \
    defined(QDSP_IMAGE_FR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_HR_MP3_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)

#ifdef QDSP_IMAGE_SYNTH_DEFINED
      case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_AAC_DEFINED
      case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
      case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
      case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
      case QDSP_IMAGE_RA:
#endif
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
      case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
#ifdef QDSP_IMAGE_TUNES_DEFINED
      case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
      case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
      case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
      case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
      case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
      case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
      case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
      case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
      case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
        qdsp_write( QDSP_iirFiltActiveFlag, 0 );
        if (filter->enable) {
          qdsp_write( QDSP_iirFiltCoeffExtRamBase, ((uint32) filter->coeff)>>1);
          qdsp_write( QDSP_iirFiltNumBands, filter->bands);
          qdsp_write( QDSP_iirFiltReset, 0xFFFF);
          qdsp_write( QDSP_iirFiltActiveFlag, 0xFFFF);
        }
        break;
#endif  /* QDSP_IMAGE_SYNTH_DEFINED   || QDSP_IMAGE_AAC_DEFINED          ||
           QDSP_IMAGE_ENH_AAC_PLUS    || QDSP_IMAGE_WM_DEFINED           ||
           QDSP_IMAGE_TUNES_DEFINED   || QDSP_IMAGE_QTV_AAC_DEFINED      ||
           QDSP_IMAGE_RA_DEFINED      || QDSP_IMAGE_QTV_CONC_DEFINED     ||
           QDSP_IMAGE_VOC_MP3_DEFINED || QDSP_IMAGE_VOC_EVRC_MP3_DEFINED ||
           QDSP_IMAGE_AMR_MP3_DEFINED || QDSP_IMAGE_EFR_MP3_DEFINED      ||
           QDSP_IMAGE_FR_MP3_DEFINED  || QDSP_IMAGE_HR_MP3_DEFINED       */

      default:
        break;
    }
  }
  return (QDSP_CMD_SUCCESS);
}
#endif /* FEATURE_AUDFMT_IIR_FILTER */

#ifdef FEATURE_AUDIO_ISDBT_DUAL_MONO
/*===========================================================================

FUNCTION qdsp_cmd_set_codec_update_int_cb

DESCRIPTION
  Set the client callback that will be invoked when a ADEC interrupt
  is received.

DEPENDENCIES
  This command is only valid when the DSP is in adec state.

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_adec_int_cb_ptr

===========================================================================*/
void qdsp_cmd_set_codec_update_int_cb(
  qdsp_cmd_dualmono_cb_type cb_func /* Callback for QDSP to request data */
)
{
  MSG_LOW("Set dualmono callback func %p", cb_func,0,0);
  qdsp_cmd_codec_update_cb_funcptr = cb_func;

  /* reset static variable at this moment, DSP output is 0 = non dual mono,
  0xFFFF = dualmono. set it unique value to distinguish initial value from
  non dual mono
  */
  if( cb_func == NULL )
    qdsp_audio_current_mode = QDSP_DUAL_MONO_INIT_VALUE;
}

/*===========================================================================

FUNCTION qdsp_cmd_do_codec_update

DESCRIPTION
  Provide DSP interrupt to upper layer

DEPENDENCIES
  None

RETURN VALUE
  QDSP_CMD_SUCCESS

SIDE EFFECTS
  None

==========================================================================*/
void qdsp_cmd_do_codec_update( void )
{
/* Save value and call callback just when it changes */
  if( qdsp_cmd_codec_update_cb_funcptr != NULL) {

    uint16 dualmono = qdsp_read(QDSP_dualMonoPresent);
    MSG_LOW("Dual Mono present [%d], [%d]",dualmono,
                                           qdsp_audio_current_mode,0);

    if( qdsp_audio_current_mode != dualmono ) {
      qdsp_audio_current_mode = dualmono;

      /* Callback to upper layer */
      qdsp_cmd_codec_update_cb_funcptr(dualmono);
    }
  }
}
#endif /* FEATURE_AUDIO_ISDBT_DUAL_MONO */

#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
/*===========================================================================

FUNCTION QDSP_CMD_ADPCM_TUNES_QDSP2_ISR

DESCRIPTION
  This function processes the interrupt from the cam_audio_conc image

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_adpcm_tunes_qdsp2_isr(void)
{
  uint16  dsp_msg_type;      /* flag indicating dsp message type */
#if  defined(FEATURE_QSYNTH_ADPCM)
  uint16  dsp_sticky_int;    /* flag indicating dsp sticky interrupt */
#endif /*FEATURE_QSYNTH_ADPCM */
  volatile uint16 *messageReg, *messageBuf;

#if defined(FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
    qdsp_cmd_arm_pp_isr();
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

 if ( qdsp_cmd_get_decoder_in_use() ==  QDSP_CMD_DEC_WAVE)
 {
      messageReg = QDSP_dspMessageReg;
      messageBuf = QDSP_dspMessageBuf;
      dsp_msg_type = qdsp_read(messageReg);

#if defined(FEATURE_QSYNTH_ADPCM) ||defined(FEATURE_WAVE_PB)
    dsp_sticky_int = qdsp_read(QDSP_adecDataHostStickyInt);
    /* If msg type is non-zero, we have an interrupt pending */
    if ((dsp_sticky_int != 0) && ((dsp_msg_type == 0x311) ||
                                  (dsp_msg_type == 0x312))) {
      if(qdsp_cmd_adec_int_cb_ptr != NULL) {
        /* Tell vocoder task to return the next set of data */
        qdsp_cmd_adec_int_cb_ptr();
      }
    }
#endif /* FEATURE_QSYNTH_ADPCM || defined(FEATURE_WAVE_PB) */
 /* Host clears the semaphore flag when read               */
  if (dsp_msg_type != 0) {
    qdsp_write(messageReg, 0); /* Clear the semaphore */
  }
 }

 if ( qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_MP3){
  dsp_msg_type = qdsp_read(QDSP_adecDataHostStickyInt);

  if ( dsp_msg_type != 0 )
  {
#if defined(FEATURE_ADEC)
    /* If msg type is non-zero, we have an interrupt pending */
    if(qdsp_cmd_adec_int_cb_ptr != NULL) {
      /* Tell vocoder task to return the next set of data */
      qdsp_cmd_adec_int_cb_ptr();
    }
#endif /* FEATRUE_ADEC */
  }
 }

#ifdef FEATURE_AUDIO_FORMAT
  qdsp_cmd_do_av_sync();
#endif /* FEATURE_AUDIO_FORMAT */

#ifdef FEATURE_AUDFMT_SPECTRUM_ANALYZER
  qdsp_cmd_do_spectrum_analyzer();
#endif /* FEATURE_AUDFMT_SPECTRUM_ANALYZER */

if ( qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_AAC) /*Not Mp3 */
{
#ifdef FEATURE_AUDIO_ISDBT_DUAL_MONO
	qdsp_cmd_do_codec_update();
#endif /* FEATURE_AUDIO_ISDBT_DUAL_MONO */
}

}
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */

/* <EJECT> */
#ifdef FEATURE_QTUNES_COMMON
/*===========================================================================

FUNCTION QDSP_CMD_TUNES_QDSP2_ISR

DESCRIPTION
  This function processes the interrupts from QTunes, AAC, RA images.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_tunes_qdsp2_isr( void )
{
  uint16  dsp_msg_type;      /* flag indicating dsp message type */
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */

#if defined (FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
    /* Process arm post process interrupt */
    qdsp_cmd_arm_pp_isr();
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

  dsp_msg_type = qdsp_read(QDSP_adecDataHostStickyInt);

  if ( dsp_msg_type != 0 )
  {
    /* If msg type is non-zero, we have an interrupt pending */
    if(qdsp_cmd_adec_int_cb_ptr != NULL) {
      /* Tell vocoder task to return the next set of data */
      qdsp_cmd_adec_int_cb_ptr();
    }
  }

#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */

#if defined(QDSP_IMAGE_QTV_AAC_DEFINED)||defined(QDSP_IMAGE_QTV_AAC_DEFINED)||\
	defined(QDSP_IMAGE_QTV_CONC_DEFINED)||defined(QDSP_IMAGE_ENH_AAC_PLUS)
  switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
	case QDSP_IMAGE_QTV_AAC:
#endif

#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif

#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif

#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
	case QDSP_IMAGE_QTV_CONC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
	case QDSP_IMAGE_ENH_AAC_PLUS:
#endif

#ifdef QDSP_idleMeterIsrMssg
  /*check for the qdsp interrupt variable and  print qdsp variables \
  minidlecount and avgidle count....calculate adsp utilisation \
  variables adn print..*/
  if (qdsp_read(QDSP_idleMeterIsrMssg) == 1)
      {
		 int maxidlevar,avgidlevar;
		 float worstadspvar,avgadspvar;
         uint32 minvar =  qdsp_read(QDSP_minIdleCount);
		 uint32 avgvar =  qdsp_read(QDSP_avgIdleCount);
         /* printing the qdsp idlemetering count variables */
		 MSG_HIGH("Idle Metering: minIdleCount = %u, avgIdleCount = %u", \
			      minvar, avgvar,0);
		 /* calculation to find adsp utilisation */
		 worstadspvar =  minvar/((qdsp_read(QDSP_idleMeterScaleFactor)+1) \
			             *(float)65536);
		 avgadspvar =	 avgvar/((qdsp_read(QDSP_idleMeterScaleFactor)+1) \
			            *(float)65536);
		 maxidlevar = (1-worstadspvar)*100;
		 avgidlevar = (1-avgadspvar)*100;
		 /* printing the adsp utilisation values */
		 MSG_HIGH( \
		 "ADSP Utilzation in percentage:Worst Case = %d,Average = %d\n", \
		  maxidlevar ,avgidlevar,0);
         /* disable the qdsp interrupt variable */
         qdsp_write(QDSP_idleMeterIsrMssg, 0);
      }
#endif /* #ifdef QDSP_idleMeterIsrMssg */
	  break;
	   default:
          break;
  }
#endif
#ifdef FEATURE_AUDIO_FORMAT
  qdsp_cmd_do_av_sync();
#endif /* FEATURE_AUDIO_FORMAT */

#ifdef FEATURE_AUDFMT_SPECTRUM_ANALYZER
  qdsp_cmd_do_spectrum_analyzer();
#endif /* FEATURE_AUDFMT_SPECTRUM_ANALYZER */

#ifdef FEATURE_AUDIO_ISDBT_DUAL_MONO
  qdsp_cmd_do_codec_update();
#endif /* FEATURE_AUDIO_ISDBT_DUAL_MONO */

}
#endif /* FEATURE_QTUNES_COMMON */

/* <EJECT> */
#if defined(FEATURE_ADEC) || defined(FEATURE_WAVE_PB)
/*===========================================================================

FUNCTION QDSP_CMD_SET_ADEC_INT_CB

DESCRIPTION
  Set the client callback that will be invoked when a ADEC interrupt
  is received.

DEPENDENCIES
  This command is only valid when the DSP is in adec state.

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_adec_int_cb_ptr

===========================================================================*/
void qdsp_cmd_set_adec_int_cb (
  qdsp_cmd_adec_int_cb_func_type cb_func /* Callback for QDSP to request data */
)
{
  qdsp_cmd_adec_int_cb_ptr = cb_func;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_ADEC_CONFIG (DMA Type Writable Information)

DESCRIPTION
  This function will send a command to the DSP to configure the adec processing.

DEPENDENCIES
  This command is only valid when the DSP is in adec state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS

  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec_config (
  qdsp_cmd_adec_int_cb_func_type cb_func /* Callback for QDSP to request data */
)
{

  if(cb_func == NULL) {
    qdsp_cmd_set_adec_int_cb(NULL);
#ifdef FEATURE_AUDIO_ISDBT_DUAL_MONO
    qdsp_cmd_set_codec_update_int_cb(NULL);
#endif

  } else {
    /* Add dynamic selection of block size dependent on bit-rate of song
    */
    switch(qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
      case QDSP_IMAGE_CAM_AUDIO_CONC:
        if (qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_MP3){
          /* Explicitly clear the pause flag in case the DSP was left in a paused
           * state before the new song is started, since the DSP doesn't clear it
           * when it comes out of INIT.
           */
            qdsp_write(QDSP_audioPause, 0);
            qdsp_write(QDSP_adecDataMinDLSize, QDSP_QTUNES_BUF_WATERMARK);
            /* Read and save this value upon image startup as it is only valid then! */
            qdsp_cmd_adec_data_buf_size = qdsp_read(QDSP_adecDataBufSize);
            qdsp_cmd_adec_data_ptr0     = qdsp_read(QDSP_adecDataWritePtr);
            /* Flush the DSP buffers */
            (void) qdsp_cmd_adec_flush(0xFFFF);
            /* Set the callback function used to access data. */
            qdsp_cmd_set_adec_int_cb(cb_func);
        }else
        if (qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_WAVE){
               /* Set the callback function used to access data. */
                 qdsp_cmd_set_adec_int_cb(cb_func);
        }
        return( QDSP_CMD_SUCCESS );
        break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#ifdef FEATURE_GRAPH_ADPCM
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
      case QDSP_IMAGE_VFE_BAYER:
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
      case QDSP_IMAGE_VFE_YCBCR:
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */
#ifdef QDSP_IMAGE_QCAMERA_DEFINED
      case QDSP_IMAGE_QCAMERA:
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */
#ifdef QDSP_IMAGE_MP4E_DEFINED
      case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
      case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
      case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
      case QDSP_IMAGE_MP4E_AMR:
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
      case QDSP_IMAGE_QCAMCORDER:
#endif /* QDSP_IMAGE_QCAMCORDER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
      case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
      case QDSP_IMAGE_AACENC:
#endif /* QDSP_IMAGE_AACENC_DEFINED */

        qdsp_cmd_set_adec_int_cb(cb_func);
        return( QDSP_CMD_SUCCESS );
#endif /* FEATURE_GRAPH_ADPCM */

#ifdef FEATURE_QTUNES
#ifdef QDSP_IMAGE_TUNES_DEFINED
      case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
      case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
      case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */

        /* Explicitly clear the pause flag in case the DSP was left in a paused
         * state before the new song is started, since the DSP doesn't clear it
         * when it comes out of INIT.
         */
        qdsp_write(QDSP_audioPause, 0);
        qdsp_write(QDSP_adecDataMinDLSize, QDSP_QTUNES_BUF_WATERMARK);
        break;
#endif /* FEATURE_QTUNES */

#if defined(FEATURE_QTUNES_AAC)           || \
    defined(FEATURE_REAL_AUDIO)           || \
    defined(FEATURE_AMR_WBPLUS_AUDIO_DEC)
#ifdef QDSP_IMAGE_AAC_DEFINED
      case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
      case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
      case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
      case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
      case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
      case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED*/
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
      case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
      case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_WM_DEFINED
      case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
      case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
        /* Explicitly clear the pause flag in case the DSP was left in a paused
         * state before the new song is started, since the DSP doesn't clear it
         * when it comes out of INIT.
         */
        qdsp_write(QDSP_audioPause, 0);
        /* NO OP: set using qdsp_cmd_set_adec_buffer_factor()
        */
        break;
#endif /* FEATURE_QTUNES_AAC           || FEATURE_REAL_AUDIO ||
          FEATURE_AMR_WBPLUS_AUDIO_DEC                       */


#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP) || \
    defined(FEATURE_QSYNTH_ADPCM)
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
      case QDSP_IMAGE_VOC_COMBO_SYNTH:
        qdsp_cmd_set_adec_int_cb(cb_func);
        return( QDSP_CMD_SUCCESS );
        break;
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
      case QDSP_IMAGE_SYNTH:
#ifndef FEATURE_GASYNTH_INTERFACE
        qdsp_write(QDSP_adecDataMinDLSize, QDSP_QSYNTH_BUF_WATERMARK);
#else /* FEATURE_GASYNTH_INTERFACE */
        qdsp_cmd_qsynth_adpcm_data[0].adec_state =
                                         QDSP_CMD_QSYNTH_ADEC_STOPPED;

#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS

#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
	    {

        qdsp_cmd_qsynth_adpcm_data[1].adec_state =
                                         QDSP_CMD_QSYNTH_ADEC_STOPPED;
        qdsp_cmd_qsynth_adpcm_data[2].adec_state =
                                         QDSP_CMD_QSYNTH_ADEC_STOPPED;
        qdsp_cmd_qsynth_adpcm_data[3].adec_state =
                                         QDSP_CMD_QSYNTH_ADEC_STOPPED;
        }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
        qdsp_cmd_set_adec_int_cb(cb_func);
        return( QDSP_CMD_SUCCESS );
#endif /* FEATURE_GASYNTH_INTERFACE */
        break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#if defined(QDSP_IMAGE_Q3D_DEFINED) || defined(QDSP_IMAGE_QGL_DEFINED)
#ifdef QDSP_IMAGE_Q3D_DEFINED
      case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
      case QDSP_IMAGE_QGL:
#endif
        (void) qdsp_cmd_adec_flush(0xFFFF);
        qdsp_cmd_set_adec_int_cb(cb_func);
        return (QDSP_CMD_SUCCESS);
#endif /* QDSP_IMAGE_Q3D_DEFINED || QDSP_IMAGE_QGL_DEFINED */
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP || FEATURE_QSYNTH_ADPCM */

#if defined(FEATURE_VOC_ADPCM)                || \
    defined(FEATURE_AVS_INCALL_ADEC_PB)       || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB) || \
    (defined(FEATURE_WAVE_PB) && defined(FEATURE_VOC_G711))
#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
      case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
      case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
      case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
      case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
      case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
      case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */

        if (
#ifdef FEATURE_AVS_INCALL_ADEC_PB
            (qdsp_cmd_get_state()      == QDSP_STATE_ADEC_VOC) &&
#endif /* FEATURE_AVS_INCALL_ADEC_PB */
#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
            ((qdsp_cmd_get_state()     == QDSP_STATE_IDLE) ||
             (qdsp_cmd_get_state()     == QDSP_STATE_VOCODER)) &&
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB */
            (qdsp_cmd_get_adec_state() == QDSP_STATE_TUNES)) {
          /* Explicitly clear the pause flag in case the DSP was left in a
           * paused state before the new song is started, since the DSP
           * doesn't clear it when it comes out of INIT.
           */
          qdsp_write(QDSP_audioPause, 0);
          qdsp_write(QDSP_adecDataMinDLSize, QDSP_QTUNES_BUF_WATERMARK);
        }
        break;
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */
#ifdef QDSP_IMAGE_VOC_DEFINED
      case QDSP_IMAGE_VOC:
#endif /* QDSP_IMAGE_VOC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
      case QDSP_IMAGE_VOC_COMBO:
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
      case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif /* QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
      case QDSP_IMAGE_VOC_EVRC:
#endif /* QDSP_IMAGE_VOC_EVRC_DEFINED */
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
      case QDSP_IMAGE_VOC_E90:
#endif /* QDSP_IMAGE_VOC_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
      case QDSP_IMAGE_VOC_EVRC_E90:
#endif /* QDSP_IMAGE_VOC_EVRC_DEFINED */
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
      case QDSP_IMAGE_VOC_QTV:
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_FR_DEFINED */
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_EFR_DEFINED */
#ifdef QDSP_IMAGE_AMR_DEFINED
      case QDSP_IMAGE_AMR:
#endif /* QDSP_IMAGE_AMR_DEFINED */
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
        case QDSP_IMAGE_AMR_WB:
#endif /* QDSP_IMAGE_AMR_WB_DEFINED */
#ifdef QDSP_IMAGE_HR_DEFINED
      case QDSP_IMAGE_HR:
#endif /* QDSP_IMAGE_HR_DEFINED */
#if defined(FEATURE_WAVE_PB) && defined(FEATURE_VOC_G711)
#ifdef QDSP_IMAGE_G711_DEFINED
      case QDSP_IMAGE_G711:
#endif /* QDSP_IMAGE_G711_DEFINED */
#endif /* FEATURE_WAVE_PB && FEATURE_VOC_G711 */
        qdsp_cmd_set_adec_int_cb(cb_func);
        return( QDSP_CMD_SUCCESS );
#endif /* FEATURE_VOC_ADPCM || FEATURE_AVS_INCALL_ADEC_PB) ||
          (FEATURE_WAVE_PB && FEATURE_VOC_G711) */

      default:
        MSG_MED("Adec config called in wrong state",0,0,0);
        return(QDSP_CMD_FAILED);
    }

#if defined(FEATURE_QTUNES_COMMON)     || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)  || \
    defined(FEATURE_AVS_INCALL_ADEC_PB)|| \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)

    /* Read and save this value upon image startup as it is only valid then! */
    qdsp_cmd_adec_data_buf_size = qdsp_read(QDSP_adecDataBufSize);
    qdsp_cmd_adec_data_ptr0     = qdsp_read(QDSP_adecDataWritePtr);

#ifndef FEATURE_GASYNTH_INTERFACE
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP)
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    if(qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {
      qdsp_cmd_adec_data_ptr1 = qdsp_read(QDSP_adecDataWritePtr1);
      qdsp_cmd_adec_data_ptr2 = qdsp_read(QDSP_adecDataWritePtr2);
      qdsp_cmd_adec_data_ptr3 = qdsp_read(QDSP_adecDataWritePtr3);
    }
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP */
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
#endif /* FEATURE_GASYNTH_INTERFACE */

    /* Flush the DSP buffers */
    (void) qdsp_cmd_adec_flush(0xFFFF);

    /* Set the callback function used to access data. */
    qdsp_cmd_set_adec_int_cb(cb_func);
#endif /* FEATURE_QTUNES_COMMON || FEATURE_QSYNTH_COMMON */

  }

  return( QDSP_CMD_SUCCESS );
}
#endif /* FEATURE_ADEC || FEATURE_WAVE_PB */

/* <EJECT> */
#ifdef FEATURE_ADEC
/*===========================================================================

FUNCTION QDSP_CMD_ADEC_WRITE

DESCRIPTION
  This function will write to the adec buffer.

DEPENDENCIES
  This command is only valid when the DSP is in QTUNES or QSYNTH state.

RETURN VALUE
  TRUE if data was written to the DSP.
  FALSE otherwise.
  was done.

SIDE EFFECTS
  The data lengths are updated to mark what was used to fill the DSP buffers
  completely.

===========================================================================*/
boolean qdsp_cmd_adec_write (
  volatile uint32        adec_data_buf,
  volatile uint32        adec_data_write_ptr,
  volatile uint32        adec_data_free_len,
  uint16                 adec_data_ptr,
  qdsp_cmd_adec_cmd_type *adec_cmd
) {
  uint32 dsp_free_len;    /* length of free space in the circular buffer    */
  uint32 dsp_write_len;   /* length we can write to it at one time          */
  uint32 arm_next_write;  /* next index we write to in the circular buffer  */
  uint32 dsp_offset;      /* index into the DSPs circular buf we write to   */
  uint32 num_write;       /* Number of words we can write at any given time */
  uint8  odd_buffer[2];
  uint8  *data_ptr, *data_ptr2;
  uint32 *data_len, *data_len2;
  uint32 dsp_free_len_copy;

  data_ptr  = adec_cmd->buf1;
  data_ptr2 = adec_cmd->buf2;
  data_len  = &(adec_cmd->length1);
  data_len2 = &(adec_cmd->length2);

  /* Retrieve the BitstreamFreeLen */
  dsp_free_len = qdsp_read((volatile uint16*) adec_data_free_len);
  dsp_free_len_copy = dsp_free_len;

  /* Get the last address we wrote to */
  arm_next_write = qdsp_read((volatile uint16*) adec_data_write_ptr);

  /* Fill to end of circular buffer, or len of data to write */
  dsp_offset = arm_next_write - adec_data_ptr;

  dsp_write_len = MIN(dsp_free_len, qdsp_cmd_adec_data_buf_size - dsp_offset);

  num_write = MIN(*data_len >> 1, dsp_write_len);

  if(num_write != 0) {
    qdsp_block_write((volatile uint16*) adec_data_buf, dsp_offset,
                     (uint16*)data_ptr, num_write, TRUE);

    data_ptr       += 2*num_write;
    dsp_offset     += num_write;
    dsp_free_len   -= num_write;
    dsp_write_len  -= num_write;
    *data_len      -= 2*num_write;
    arm_next_write += num_write;
  }

  if(dsp_write_len) {
    if((*data_len != 0) && (*data_len2 != 0)) {
      odd_buffer[0] = *data_ptr;
      odd_buffer[1] = *data_ptr2;

      qdsp_block_write((volatile uint16*) adec_data_buf, dsp_offset,
                       (uint16*)odd_buffer, 1, TRUE);

      data_ptr2      ++;
      dsp_offset     ++;
      dsp_free_len   --;
      dsp_write_len  --;
      *data_len      -= 1;
      *data_len2     -= 1;
      arm_next_write ++;
    }
  }

  num_write = MIN(*data_len2 >> 1, dsp_write_len);
  if(num_write != 0) {
    qdsp_block_write((volatile uint16*) adec_data_buf, dsp_offset,
                     (uint16*)data_ptr2, num_write, TRUE);

    data_ptr2      += 2*num_write;
    dsp_offset     += num_write;
    dsp_free_len   -= num_write;
    *data_len2     -= 2*num_write;
    arm_next_write += num_write;
  }

  if(qdsp_cmd_adec_data_buf_size == dsp_offset) {
    /* Reload the pointers to the beginning of the circular buffer */
    dsp_offset     = 0;
    arm_next_write = adec_data_ptr;

    num_write = MIN(*data_len >> 1, dsp_free_len);
    if(num_write != 0) {
      qdsp_block_write((volatile uint16*) adec_data_buf, dsp_offset,
                       (uint16*)data_ptr, num_write, TRUE);

      data_ptr       += 2*num_write;
      dsp_offset     += num_write;
      dsp_free_len   -= num_write;
      *data_len      -= 2*num_write;
      arm_next_write += num_write;
    }

    if(dsp_free_len) {
      if((*data_len != 0) && (*data_len2 != 0)) {
        odd_buffer[0] = *data_ptr;
        odd_buffer[1] = *data_ptr2;

        qdsp_block_write((volatile uint16*) adec_data_buf, dsp_offset,
                         (uint16*)odd_buffer, 1, TRUE);

        data_ptr2      ++;
        dsp_offset     ++;
        dsp_free_len   --;
        *data_len      -= 1;
        *data_len2     -= 1;
        arm_next_write ++;
      }
    }

    num_write = MIN(*data_len2 >> 1, dsp_free_len);
    if(num_write != 0) {
      qdsp_block_write((volatile uint16*) adec_data_buf, dsp_offset,
                       (uint16*)data_ptr2, num_write, TRUE);

      data_ptr2      += 2*num_write;
      dsp_offset     += num_write;
      dsp_free_len   -= num_write;
      *data_len2     -= 2*num_write;
      arm_next_write += num_write;
    }
  }

  if (dsp_free_len && (*data_len + *data_len2 == 1)) {
    /* If there's only one byte remaining, just write it, but don't update
    ** any of our pointers - this will allow DSP to process the frame if it
    ** is the last byte of the last frame
    */
    MSG_MED("Writing last odd byte",0,0,0);
    odd_buffer[0] = 0;
    if (*data_len == 1) {
      odd_buffer[1] = *data_ptr;
    }
    else {
      odd_buffer[1] = *data_ptr2;
    }
    qdsp_write_offset((volatile uint16*) adec_data_buf, dsp_offset,
                      *((uint16*)odd_buffer));
  }

  /* Write the adecDataWritePtr */
  qdsp_write((volatile uint16*) adec_data_write_ptr, (uint16) arm_next_write);

  return (dsp_free_len_copy != dsp_free_len);
}

#ifdef FEATURE_WMA
/*===========================================================================
FUNCTION qdsp_cmd_do_memswap

DESCRIPTION
  Do adjacent two bytes swapping in the memory passed in, this is temporily
  done here, eventually should be supported by QDSP image.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  The buffer passed in.

===========================================================================*/
void qdsp_cmd_do_memswap (
  uint8 *data,
  uint32 wlen
)
{
  uint32 i = 0;
  uint8  tempData;

  i = 0;

  /* in case of odd number of bytes, get a "don't care "
   * byte at the end */
  if (wlen % 2)
    wlen += 1;

  while (i < wlen) {

    tempData   = data[i];
    data[i]    = data[i+1];
    data[i+1]  = tempData;

    i += 2;

  } /* while (i < wlen) */
}

/*===========================================================================

FUNCTION qdsp_cmd_adec_dme_write

DESCRIPTION
  DME interrupt handler from SND task. It feeds wma audio data in to ADSP
  for playing back.

DEPENDENCIES
  This command is only valid when the DSP is using QSYNTH image and should
  be issued only after QDSP generates an interrupt to ask for more data.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_adec_dme_write (
  qdsp_cmd_adec_cmd_type *adec_cmd
) {
  uint16 data_used; /* In bytes */
  uint32 free_len;
  uint32 addr;
  uint32 swap_pos, swap_size;

#if defined(QDSP_IMAGE_WM_DEFINED) || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)

  /* Adec data buffer */
  static __align(4) uint8
      qdsp_cmd_adec_data_buffer[QDSP_CMD_ADEC_PRE_ALLOC_BUFFER_SIZE];

  if(qdsp_cmd_adec_data_buffer_size != 0) {
    data_used = qdsp_read( QDSP_adecDataReadPtrOffset ) << 1;

    if(data_used > qdsp_cmd_adec_data_buffer_size) {
      MSG_ERROR("DSP consumed too much data: %d, %d", data_used,
                qdsp_cmd_adec_data_buffer_size, 0);
    } else {
      /* Move un-used data to the beginning of the buffer,
      ** Can optimise it by using ping pong buffer with empty buffer at
      ** beginning, if we know the DSP can only return min of data
      */
      memmove(qdsp_cmd_adec_data_buffer,
              &qdsp_cmd_adec_data_buffer[data_used],
              qdsp_cmd_adec_data_buffer_size - data_used);
      qdsp_cmd_adec_data_buffer_size -= data_used;
    }
  }

  swap_pos = qdsp_cmd_adec_data_buffer_size;

  free_len = qdsp_cmd_adec_data_buffer_threshold -
      qdsp_cmd_adec_data_buffer_size;

  swap_size = 0;

  if (free_len > adec_cmd->length1) {
    memcpy( &qdsp_cmd_adec_data_buffer[qdsp_cmd_adec_data_buffer_size],
            adec_cmd->buf1, adec_cmd->length1);
    qdsp_cmd_adec_data_buffer_size += adec_cmd->length1;
    swap_size                      += adec_cmd->length1;
    free_len                       -= adec_cmd->length1;
    adec_cmd->length1               = 0;

    if (free_len > adec_cmd->length2) {
      memcpy( &qdsp_cmd_adec_data_buffer[qdsp_cmd_adec_data_buffer_size],
              adec_cmd->buf2, adec_cmd->length2);
      qdsp_cmd_adec_data_buffer_size += adec_cmd->length2;
      swap_size                      += adec_cmd->length2;
      adec_cmd->length2               = 0;
    } else {
      memcpy( &qdsp_cmd_adec_data_buffer[qdsp_cmd_adec_data_buffer_size],
              adec_cmd->buf2, free_len);
      adec_cmd->length2              -= free_len;
      qdsp_cmd_adec_data_buffer_size += free_len;
      swap_size                      += free_len;
    }
  } else {
    memcpy( &qdsp_cmd_adec_data_buffer[qdsp_cmd_adec_data_buffer_size],
            adec_cmd->buf1, free_len);
    adec_cmd->length1              -= free_len;
    qdsp_cmd_adec_data_buffer_size += free_len;
    swap_size                      += free_len;
  }

  if ((swap_pos + swap_size) > qdsp_cmd_adec_data_buffer_threshold) {
    swap_size = (qdsp_cmd_adec_data_buffer_threshold - swap_pos);
  }

  /* data in the buffer is in little-edian format, need to swap them into
   * big-edian since that is what required by QDSP */
  qdsp_cmd_do_memswap(&qdsp_cmd_adec_data_buffer[swap_pos],
                      swap_size);

  addr  = ((uint32) &qdsp_cmd_adec_data_buffer) >> 1;

  /* flush the data */
  /* Note: Testing is not done since feature was not available in ULC.
     So this should be tested when the feature will be available. May need to
     take care of possible buffer alignment to cache line size(32bytes) */
  FLUSH_DATA_CACHE(&qdsp_cmd_adec_data_buffer,qdsp_cmd_adec_data_buffer_size);

  qdsp_write( QDSP_adecDataReadPtrOffset, 0);
  qdsp_write( QDSP_adecDataBufStartMSW, ((addr>>16) & 0xffff));
  qdsp_write_offset( QDSP_adecDataBufStartMSW, 1, (addr & 0xffff));
  qdsp_write( QDSP_adecDataBufSize, qdsp_cmd_adec_data_buffer_size >> 1);
#endif /* QDSP_IMAGE_WM_DEFINED||QDSP_IMAGE_WM_PRO_DEFINED */
  return (TRUE);

}
#endif /* FEATURE_WMA */

/* <EJECT> */
#ifdef FEATURE_QSYNTH_ADPCM
#ifndef FEATURE_GASYNTH_INTERFACE
/*===========================================================================

FUNCTION QDSP_CMD_GET_QSYNTH_ADEC_MODE

DESCRIPTION
  This function will get the current QSynth audio decoder mode.

DEPENDENCIES
  This command is only valid when the DSP is in QSYNTH state.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
uint16 qdsp_cmd_get_qsynth_adec_mode (void) {
  return (qdsp_read(QDSP_midiDecoderType));
}
#endif /* FEATURE_GASYNTH_INTERFACE */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_QSYNTH_ADPCM_STOP

DESCRIPTION
  This function will stop a QSynth adpcm channel.

DEPENDENCIES
  This command is only valid when the DSP is in QSYNTH state.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_qsynth_adpcm_stop (
  uint32 channel
) {
  qdsp_cmd_qsynth_adpcm_data_type *adpcm_data;
  volatile uint16                 *adpcm_active;

#ifdef FEATURE_WEBAUDIO
#ifdef FEATURE_GASYNTH_INTERFACE
  word stop_command[QDSP_CMD_ADEC_ACTION_BUFF_SIZE];
#endif /* FEATURE_GASYNTH_INTERFACE */
#endif /*FEATURE_WEBAUDIO*/

#ifndef FEATURE_GASYNTH_INTERFACE
  uint16                          current_mode;
  volatile uint16                 *adpcm_reset;
#ifdef FEATURE_WEBAUDIO
  volatile uint16                 *adpcm_stop;
#endif /* FEATURE_WEBAUDIO */
#endif /* FEATURE_GASYNTH_INTERFACE */

#ifndef FEATURE_GASYNTH_INTERFACE
  current_mode = qdsp_cmd_get_qsynth_adec_mode();
  if ((current_mode == QDSP_CMD_QSYNTH_ADEC_ADPCM)  ||
      (current_mode == QDSP_CMD_QSYNTH_ADEC_YADPCM)
#ifdef FEATURE_QSYNTH_PCM
      || (current_mode == QDSP_CMD_QSYNTH_ADEC_PCM)
#endif /* FEATURE_QSYNTH_PCM */
#ifdef FEATURE_GASYNTH_INTERFACE
      || (current_mode == QDSP_CMD_QSYNTH_ADEC_QCP)
#endif /* FEATURE_GASYNTH_INTERFACE */
     )
#endif /* FEATURE_GASYNTH_INTERFACE */
  {
    switch(channel) {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
  {
      case 1:
        adpcm_active        = QDSP_adecAdpcmActive1;
#ifndef FEATURE_GASYNTH_INTERFACE
        adpcm_reset         = QDSP_adecReset1;
#endif /* FEATURE_GASYNTH_INTERFACE */
        break;

      case 2:
        adpcm_active        = QDSP_adecAdpcmActive2;
#ifndef FEATURE_GASYNTH_INTERFACE
        adpcm_reset         = QDSP_adecReset2;
#endif /* FEATURE_GASYNTH_INTERFACE */
        break;

      case 3:
        adpcm_active        = QDSP_adecAdpcmActive3;
#ifndef FEATURE_GASYNTH_INTERFACE
        adpcm_reset         = QDSP_adecReset3;
#endif /* FEATURE_GASYNTH_INTERFACE */
        break;
  }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */

      case 0:
      default:
        adpcm_active        = QDSP_adecAdpcmActive0;
#ifndef FEATURE_GASYNTH_INTERFACE
        adpcm_reset         = QDSP_adecReset;
#endif /* FEATURE_GASYNTH_INTERFACE */
        channel             = 0;
        break;
    }

#ifdef QDSP_IMAGE_SYNTH_DEFINED
#ifdef FEATURE_QAUDIOFX
    if (qdsp_cmd_image_select == QDSP_IMAGE_SYNTH
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
   ) {
      if(qdsp_cmd_3d_pos_query_src_final_cb[channel] != NULL) {
        qdsp_cmd_3d_pos_query_src_all(channel);
        qdsp_cmd_3d_pos_query_src_final_cb[channel] = NULL;
      }
      qdsp_cmd_3d_pos_src_enable(channel, QDSP_CMD_3D_POS_MODE_DISABLE);
    }
#endif /* FEATURE_QAUDIOFX */
#endif /* QDSP_IMAGE_SYNTH_DEFINE */

    if (qdsp_read(adpcm_active) != 0) {
      adpcm_data = &qdsp_cmd_qsynth_adpcm_data[channel];

#ifdef FEATURE_WEBAUDIO
#ifdef FEATURE_GASYNTH_INTERFACE
      switch(qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef QDSP_IMAGE_SYNTH_DEFINED
        case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
        case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
        case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
        stop_command[0] = QDSP_CMD_ADEC_ACTION_BUFF_SIZE;
        stop_command[1] = QDSP_CMD_ADEC_ACTION_CMD_HDR;
        stop_command[2] = 1 << channel;
        stop_command[channel+3] = QDSP_CMD_ADEC_ACTION_STOP;
        (void) qdsp_cmd_qsynth_adec_cmd( stop_command, channel );
        break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED || \
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */

        default:
          MSG_ERROR("qdsp_cmd_qsynth_adpcm_stop: invalid image", 0, 0, 0);
      }
#else
#ifdef QDSP_IMAGE_SYNTH_DEFINED
        if (qdsp_cmd_image_select == QDSP_IMAGE_SYNTH
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
			) {
        switch(channel) {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
{
          case 1:
            adpcm_stop           = QDSP_adecAdpcmStop1;
            break;

          case 2:
            adpcm_stop           = QDSP_adecAdpcmStop2;
            break;

          case 3:
            adpcm_stop           = QDSP_adecAdpcmStop3;
            break;
}
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
          case 0:
          default:
            adpcm_stop           = QDSP_adecAdpcmStop0;
            break;
        }
        qdsp_write(adpcm_stop, 1);
      }
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#endif /* FEATURE_GASYNTH_INTERFACE */
#endif /* FEATURE_WEBAUDIO */

#ifndef FEATURE_GASYNTH_INTERFACE
      qdsp_write(adpcm_reset, 0);
      qdsp_write(adpcm_active, 0);
#else /* FEATURE_GASYNTH_INTERFACE */
      adpcm_data->buffer2 = NULL;
      adpcm_data->length2 = 0;
      adpcm_data->buf_state = QDSP_CMD_ADEC_STATE_BUFFER1;
      adpcm_data->stamp_counter = 1;
#endif /* FEATURE_GASYNTH_INTERFACE */
      adpcm_data->length = 0;
      adpcm_data->buffer = NULL;
    }
#ifdef FEATURE_GASYNTH_INTERFACE
    qdsp_cmd_synth_adec_enabled[channel] = FALSE;
#endif /* FEATURE_GASYNTH_INTERFACE */
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_QSYNTH_ADPCM_START

DESCRIPTION
  This function will initialize a QSynth adpcm channel.

DEPENDENCIES
  This command is only valid when the DSP is in QSYNTH state.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
#ifdef FEATURE_GASYNTH_INTERFACE
qdsp_cmd_status_type qdsp_cmd_qsynth_adpcm_start (
  uint32                             channel,
  qdsp_cmd_qsynth_adpcm_cmd_type     *adec_cmd,
  qdsp_cmd_adpcm_mode_type           mode,
  qdsp_cmd_adec_start_mode_enum_type start_mode
) {
  qdsp_cmd_qsynth_adpcm_data_type *adpcm_data;
  qdsp_cmd_status_type            ret_val = QDSP_CMD_FAILED;
  volatile uint16                 *adpcm_active;

  word  config_cmd[QDSP_CMD_ADEC_CONFIG_BUFF_SIZE];
  uint8 cmd_index = 0;

  adpcm_data = &qdsp_cmd_qsynth_adpcm_data[channel];

  config_cmd[cmd_index++] = QDSP_CMD_ADEC_CONFIG_BUFF_SIZE;
  config_cmd[cmd_index++] = QDSP_CMD_ADEC_CONFIG_CMD_HDR;
  /* Setting bit 15 to 1 to activate decoder right away */
  if(start_mode == QDSP_CMD_ADEC_START_MODE_DELAYED) {
    config_cmd[cmd_index++] = channel;
  } else {
    config_cmd[cmd_index++] = channel | 0x8000;
  }

  switch(mode) {
    case QDSP_CMD_ADPCM_ADPCM_MODE:
      config_cmd[cmd_index++] = QDSP_CMD_QSYNTH_ADEC_ADPCM;

      adpcm_data->frame_size  = (adec_cmd->sampling_rate/1000) * 10;
#ifdef FEATURE_QSYNTH_FRACTIONAL_SAMPLE_RATE
      config_cmd[cmd_index++] = adec_cmd->sampling_rate;
#else
      config_cmd[cmd_index++] = adpcm_data->frame_size;
#endif /* FEATURE_QSYNTH_FRACTIONAL_SAMPLE_RATE */
      config_cmd[cmd_index++] = adec_cmd->num_channels;
      config_cmd[cmd_index++] = ((adec_cmd->block_length/adec_cmd->num_channels - 4) << 1) + 1;

      adpcm_data->frame_size >>= 1;
      break;

    case QDSP_CMD_ADPCM_YADPCM_MODE:
      config_cmd[cmd_index++] = QDSP_CMD_QSYNTH_ADEC_YADPCM;

      adpcm_data->frame_size  = adec_cmd->sampling_rate/100;
#ifdef FEATURE_QSYNTH_FRACTIONAL_SAMPLE_RATE
      config_cmd[cmd_index++] = adec_cmd->sampling_rate;
#else
      config_cmd[cmd_index++] = adpcm_data->frame_size;
#endif /* FEATURE_QSYNTH_FRACTIONAL_SAMPLE_RATE */
      config_cmd[cmd_index++] = adec_cmd->num_channels;
      config_cmd[cmd_index++] = QDSP_CMD_ADPCM_MODE_YADPCM;

      adpcm_data->frame_size >>= 1;
      break;

    case QDSP_CMD_ADPCM_SIGNED_PCM_MODE:
    case QDSP_CMD_ADPCM_UNSIGNED_PCM_MODE:
      config_cmd[cmd_index++] = QDSP_CMD_QSYNTH_ADEC_PCM;

#ifdef FEATURE_QSYNTH_FRACTIONAL_SAMPLE_RATE
      adpcm_data->frame_size   = (adec_cmd->sampling_rate/1000) * 10;
      config_cmd[cmd_index++]  = adec_cmd->sampling_rate;
#else
      adec_cmd->sampling_rate += 50;
      adpcm_data->frame_size   = (adec_cmd->sampling_rate/1000) * 10;
      config_cmd[cmd_index++]  = adpcm_data->frame_size;
#endif /* FEATURE_QSYNTH_FRACTIONAL_SAMPLE_RATE */
      config_cmd[cmd_index++]  = adec_cmd->num_channels;

      if(mode == QDSP_CMD_ADPCM_UNSIGNED_PCM_MODE) {
        if(adec_cmd->bits_per_sample == 8) {
          config_cmd[cmd_index++] = QDSP_CMD_PCM_MODE_UNSIGNED_8_PCM;
        } else {
          config_cmd[cmd_index++] = QDSP_CMD_PCM_MODE_UNSIGNED_16_PCM;
        }
      } else if(mode == QDSP_CMD_ADPCM_SIGNED_PCM_MODE) {
        if(adec_cmd->bits_per_sample == 8) {
          config_cmd[cmd_index++] = QDSP_CMD_PCM_MODE_SIGNED_8_PCM;
        } else {
          config_cmd[cmd_index++] = QDSP_CMD_PCM_MODE_SIGNED_16_PCM;
        }
      }
      break;

    default:
      return(ret_val);
  }

  switch(channel) {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
  {

    case 1:
      adpcm_active = QDSP_adecAdpcmActive1;
      break;

    case 2:
      adpcm_active = QDSP_adecAdpcmActive2;
      break;

    case 3:
      adpcm_active = QDSP_adecAdpcmActive3;
      break;
  }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */

    case 0:
    default:
      adpcm_active = QDSP_adecAdpcmActive0;
      channel      = 0;
      break;
  }

  if(qdsp_read(adpcm_active) != 0) {
    adpcm_data->buffer = NULL;
    adpcm_data->buffer2 = NULL;
  }

  adpcm_data->mode          = mode;
  adpcm_data->length        = 0;
  adpcm_data->length2       = 0;
  adpcm_data->buf_state     = QDSP_CMD_ADEC_STATE_BUFFER1;
  adpcm_data->sampling_rate = adec_cmd->sampling_rate;

  ret_val = qdsp_cmd_qsynth_adec_cmd(config_cmd, channel);

  if(ret_val == QDSP_CMD_SUCCESS) {
    qdsp_cmd_synth_adec_enabled[channel] = TRUE;
    adpcm_data->stamp_counter = 1;
    MSG_MED("adec start decoder %d", channel, 0, 0);
  }

#ifdef FEATURE_QAUDIOFX
  qdsp_cmd_3d_pos_reset_src(channel);
#endif /* FEATURE_QAUDIOFX */

  return (ret_val);
}
#else
qdsp_cmd_status_type qdsp_cmd_qsynth_adpcm_start (
  uint32                             channel,
  qdsp_cmd_qsynth_adpcm_cmd_type     *adec_cmd,
  qdsp_cmd_adpcm_mode_type           mode,
  qdsp_cmd_adec_start_mode_enum_type start_mode
) {
  qdsp_cmd_qsynth_adpcm_data_type       *adpcm_data;
  uint16                                current_mode;
  qdsp_cmd_status_type                  ret_val = QDSP_CMD_FAILED;
  volatile uint16                       *adpcm_active;

  uint16           block_size;
  volatile uint16  *adpcm_data_type;
  volatile uint16  *adpcm_channel_mode;
  volatile uint16  *adpcm_sampling_rate;
  volatile uint16  *adpcm_block_length;

  current_mode = qdsp_cmd_get_qsynth_adec_mode();
  if(((current_mode == QDSP_CMD_QSYNTH_ADEC_ADPCM) &&
      (mode == QDSP_CMD_ADPCM_ADPCM_MODE)) ||
     ((current_mode == QDSP_CMD_QSYNTH_ADEC_YADPCM) &&
      ((mode == QDSP_CMD_ADPCM_YADPCM_MODE) ||
       (mode == QDSP_CMD_ADPCM_SIGNED_PCM_MODE) ||
       (mode == QDSP_CMD_ADPCM_UNSIGNED_PCM_MODE)))
#ifdef FEATURE_QSYNTH_PCM
  || ((current_mode == QDSP_CMD_QSYNTH_ADEC_PCM) &&
      ((mode == QDSP_CMD_ADPCM_SIGNED_PCM_MODE) ||
       (mode == QDSP_CMD_ADPCM_UNSIGNED_PCM_MODE)))
#endif /* FEATURE_QSYNTH_PCM */
    ) {
    switch(channel) {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS

#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
	{

      case 1:
        adpcm_data_type     = QDSP_adecAdpcmDataType1;
        adpcm_channel_mode  = QDSP_adecAdpcmChannelMode1;
        adpcm_sampling_rate = QDSP_adecAdpcmSamplingRate1;
        adpcm_block_length  = QDSP_adecAdpcmBlockLength1;
        adpcm_active        = QDSP_adecAdpcmActive1;
        break;

      case 2:
        adpcm_data_type     = QDSP_adecAdpcmDataType2;
        adpcm_channel_mode  = QDSP_adecAdpcmChannelMode2;
        adpcm_sampling_rate = QDSP_adecAdpcmSamplingRate2;
        adpcm_block_length  = QDSP_adecAdpcmBlockLength2;
        adpcm_active        = QDSP_adecAdpcmActive2;
        break;

      case 3:
        adpcm_data_type     = QDSP_adecAdpcmDataType3;
        adpcm_channel_mode  = QDSP_adecAdpcmChannelMode3;
        adpcm_sampling_rate = QDSP_adecAdpcmSamplingRate3;
        adpcm_block_length  = QDSP_adecAdpcmBlockLength3;
        adpcm_active        = QDSP_adecAdpcmActive3;
        break;
    }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */

      case 0:
      default:
        adpcm_data_type     = QDSP_adecAdpcmDataType0;
        adpcm_channel_mode  = QDSP_adecAdpcmChannelMode0;
        adpcm_sampling_rate = QDSP_adecAdpcmSamplingRate0;
        adpcm_block_length  = QDSP_adecAdpcmBlockLength0;
        adpcm_active        = QDSP_adecAdpcmActive0;
        channel             = 0;
        break;
    }
    adpcm_data = &qdsp_cmd_qsynth_adpcm_data[channel];

    if(qdsp_read(adpcm_active) != 0) {
      adpcm_data->buffer = NULL;
    }

    adpcm_data->length = 0;
    if(mode == QDSP_CMD_ADPCM_ADPCM_MODE) {
      block_size = ((adec_cmd->block_length - 4) << 1) + 1;
      qdsp_write(adpcm_block_length, block_size);
    }
#ifdef FEATURE_QSYNTH_PCM
    if (current_mode == QDSP_CMD_QSYNTH_ADEC_PCM) {
      adpcm_data->frame_size = (adec_cmd->sampling_rate/1000) * 10;
    } else
#endif /* FEATURE_QSYNTH_PCM */
    {
      adpcm_data->frame_size = adec_cmd->sampling_rate/100;
    }

    adpcm_data->mode       = mode;

    qdsp_write(adpcm_sampling_rate, adpcm_data->frame_size);
    qdsp_write(adpcm_channel_mode, adec_cmd->num_channels);

    switch(mode) {
      case QDSP_CMD_ADPCM_ADPCM_MODE:
        qdsp_write(adpcm_data_type, QDSP_CMD_ADPCM_MODE_ADPCM);
        adpcm_data->frame_size >>= 1;
        break;
      case QDSP_CMD_ADPCM_YADPCM_MODE:
        qdsp_write(adpcm_data_type, QDSP_CMD_ADPCM_MODE_YADPCM);
        adpcm_data->frame_size >>= 1;
        break;
      case QDSP_CMD_ADPCM_SIGNED_PCM_MODE:
        if(current_mode == QDSP_CMD_QSYNTH_ADEC_YADPCM) {
          qdsp_write(adpcm_data_type, QDSP_CMD_ADPCM_MODE_SIGNED_PCM);
#ifdef FEATURE_QSYNTH_PCM
        } else {
          if(adec_cmd->bits_per_sample == 8) {
            qdsp_write(adpcm_data_type, QDSP_CMD_PCM_MODE_SIGNED_8_PCM);
          } else {
            qdsp_write(adpcm_data_type, QDSP_CMD_PCM_MODE_SIGNED_16_PCM);
          }
#endif /* FEATURE_QSYNTH_PCM */
        }
        break;
      case QDSP_CMD_ADPCM_UNSIGNED_PCM_MODE:
        if(current_mode == QDSP_CMD_QSYNTH_ADEC_YADPCM) {
          qdsp_write(adpcm_data_type, QDSP_CMD_ADPCM_MODE_UNSIGNED_PCM);
#ifdef FEATURE_QSYNTH_PCM
        } else {
          if(adec_cmd->bits_per_sample == 8) {
            qdsp_write(adpcm_data_type, QDSP_CMD_PCM_MODE_UNSIGNED_8_PCM);
          } else {
            qdsp_write(adpcm_data_type, QDSP_CMD_PCM_MODE_UNSIGNED_16_PCM);
          }
#endif /* FEATURE_QSYNTH_PCM */
        }
        break;
    }
    qdsp_write(adpcm_active, 1);
    qdsp_cmd_adec_reset(1<<channel);
    ret_val = QDSP_CMD_SUCCESS;
  }
  return (ret_val);
}
#endif /* FEATURE_GASYNTH_INTERFACE */

/* <EJECT> */
#ifndef FEATURE_GASYNTH_INTERFACE
/*===========================================================================

FUNCTION QDSP_CMD_QSYNTH_ADPCM_WRITE

DESCRIPTION
  This function will service the QSynth adpcm data request.

DEPENDENCIES
  This command is only valid when the DSP is in QSYNTH state.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_qsynth_adpcm_write (
  volatile uint32        adpcm_buf_start,
  volatile uint32        adpcm_buf_size,
  volatile uint32        adpcm_read_ptr,
  volatile uint32        adpcm_reset,
  uint32                 channel,
  qdsp_cmd_adec_cmd_type *adec_cmd
) {
  qdsp_cmd_qsynth_adpcm_data_type *adpcm_data;
  uint16                          data_used   = 0;
  uint16                          data_left   = 0;
  uint16                          data_length = 0;
  uint32                          addr, index;
  volatile uint16                 *adpcm_active;
  volatile uint16                 *adpcm_data_is_needed;

  switch(channel) {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS

#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
	{

    case 1:
      adpcm_data_is_needed = QDSP_adecAdpcmDataIsNeeded1;
      adpcm_active         = QDSP_adecAdpcmActive1;
      break;

    case 2:
      adpcm_data_is_needed = QDSP_adecAdpcmDataIsNeeded2;
      adpcm_active         = QDSP_adecAdpcmActive2;
      break;

    case 3:
      adpcm_data_is_needed = QDSP_adecAdpcmDataIsNeeded3;
      adpcm_active         = QDSP_adecAdpcmActive3;
      break;
   }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */

    case 0:
    default:
      adpcm_data_is_needed = QDSP_adecAdpcmDataIsNeeded0;
      adpcm_active         = QDSP_adecAdpcmActive0;
      channel              = 0;
      break;
  }
  adpcm_data = &qdsp_cmd_qsynth_adpcm_data[channel];

  if ((qdsp_read(adpcm_active) != 0) &&
      (qdsp_read(adpcm_data_is_needed) != 0) &&
      (qdsp_read((volatile uint16*) adpcm_reset) == 0) &&
      (adec_cmd != NULL) && (adec_cmd->buf1 != NULL) &&
      (adec_cmd->length1 != 0)) {

    data_length = adec_cmd->length1;
    if(adpcm_data->length != 0) {
      data_used = qdsp_read((volatile uint16*) adpcm_read_ptr) << 1;
      if(data_used > adpcm_data->length) {
        data_left = 0;
        MSG_ERROR("DSP consumed too much data: %d, %d", data_used,
                  adpcm_data->length, 0);
      } else {
        data_left = adpcm_data->length - data_used;
      }
    }

    if (data_left > adec_cmd->length2) {
      MSG_ERROR("Wrong data size, chan %d used %d len %d",
                                    channel,data_used,adpcm_data->length);
      return;
    } else if (data_left & 0x1) {
      memcpy(adec_cmd->buf1, &(adpcm_data->buffer[data_used]),
             data_left);
      memcpy(&adec_cmd->buf1[data_left], &adec_cmd->buf1[adec_cmd->length2],
             data_length);

      adpcm_data->buffer = adec_cmd->buf1;
      data_length += data_left;
    } else if (data_left != 0) {
      index = adec_cmd->length2 - data_left;
      memcpy(&adec_cmd->buf1[index], &(adpcm_data->buffer[data_used]),
             data_left);
      adpcm_data->buffer = &adec_cmd->buf1[index];
      data_length += data_left;
    } else {
      adpcm_data->buffer = adec_cmd->buf2;
    }

    adpcm_data->length = data_length;
    adec_cmd->length1  = 0;

    /* flush the data */
    /* Note: Testing is not done since feature was not available in ULC.
     so this should be tested when the feature will be available. May need to
     take care of possible buffer alignment to cache line size(32bytes) */
    FLUSH_DATA_CACHE(adpcm_data->buffer,data_length);

    addr  = ((uint32) adpcm_data->buffer) >> 1;
    qdsp_write((volatile uint16*) adpcm_buf_start, ((addr>>16) & 0xffff));
    qdsp_write_offset((volatile uint16*) adpcm_buf_start, 1, (addr & 0xffff));
    qdsp_write((volatile uint16*) adpcm_buf_size, (data_length >> 1));
    qdsp_write((volatile uint16*)adpcm_read_ptr, 0);

    if ((adpcm_data->length < adpcm_data->frame_size) &&
        (adpcm_data->mode == QDSP_CMD_ADPCM_YADPCM_MODE)) {
      /* Special case for yadpcm data if it is not a complete frame
      */
      qdsp_cmd_qsynth_adpcm_stop(channel);
    } else {
      qdsp_write(adpcm_data_is_needed, 0);
    }
  }
}
#endif /* FEATURE_GASYNTH_INTERFACE */
#endif /* FEATURE_QSYNTH_ADPCM */

/* <EJECT> */
#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP) || \
    defined(FEATURE_QSYNTH_ADPCM)
#ifdef FEATURE_GASYNTH_INTERFACE
/*===========================================================================

FUNCTION qdsp_cmd_adec_commit_write

DESCRIPTION
  This function commits writing data to DSP.


DEPENDENCIES
  This command is only valid when the DSP is in QSYNTH state.

RETURN VALUE
  None
SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_adec_commit_write(
  volatile uint32        adec_buf_start,
  volatile uint32        adec_buf_size,
  volatile uint32        adec_buf_ready,
  uint8                  *buf,
  uint32                 buf_len,
  uint8                  stamp
) {
  uint32                 addr;

  /* flush the data */
  /* Note: Testing is not done since some issue was present ever in write
     through mode.So this should be tested when the feature will be available.
     May need to take care of possible buffer alignment to cache line size */
  FLUSH_DATA_CACHE(buf,buf_len);

  addr  = ((uint32) buf) >> 1;
  qdsp_write((volatile uint16*) adec_buf_start,
             ((addr>>16) & 0xffff));
  qdsp_write_offset((volatile uint16*) adec_buf_start, 1,
                    (addr & 0xffff));
  qdsp_write((volatile uint16*) adec_buf_size,
             (buf_len >> 1));
  qdsp_write((volatile uint16*) adec_buf_ready,
                       stamp);
}

/*===========================================================================

FUNCTION QDSP_CMD_QSYNTH_ADEC_WRITE

DESCRIPTION
  This function will write to the QSynth adec buffer.


DEPENDENCIES
  This command is only valid when the DSP is in QSYNTH state.

RETURN VALUE
  None
SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_qsynth_adec_write (
  volatile uint32        adec_buf_start1,
  volatile uint32        adec_buf_start2,
  volatile uint32        adec_buf_size1,
  volatile uint32        adec_buf_size2,
  volatile uint32        adec_buf_ready1,
  volatile uint32        adec_buf_ready2,
  uint32                 channel,
  qdsp_cmd_adec_cmd_type *adec_cmd
) {
  qdsp_cmd_qsynth_adpcm_data_type *adpcm_data = NULL;
  volatile uint16                 *adec_active;
  volatile uint16                 *adec_data_is_needed;
  volatile uint16                 *adec_stop;
  uint16                          readyflag1, readyflag2;
  boolean                         clear_data_is_needed = FALSE;
  uint8                           *buf_ptr[2];
  uint32                          *length_ptr[2];
  uint8                           adec_index, ppbuf_index, write_counter= 0;

  switch(channel) {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
	{

    case 1:
      adec_active         = QDSP_adecAdpcmActive1;
      adec_data_is_needed = QDSP_adecAdpcmDataIsNeeded1;
      adec_stop           = QDSP_adecStopFlagCh1;
      break;

    case 2:
      adec_active         = QDSP_adecAdpcmActive2;
      adec_data_is_needed = QDSP_adecAdpcmDataIsNeeded2;
      adec_stop           = QDSP_adecStopFlagCh2;
      break;

    case 3:
      adec_active         = QDSP_adecAdpcmActive3;
      adec_data_is_needed = QDSP_adecAdpcmDataIsNeeded3;
      adec_stop           = QDSP_adecStopFlagCh3;
      break;
   }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */

    case 0:
    default:
      adec_active         = QDSP_adecAdpcmActive0;
      adec_data_is_needed = QDSP_adecAdpcmDataIsNeeded0;
      adec_stop           = QDSP_adecStopFlagCh0;
      channel              = 0;
      break;
  }
  /* If stop flag is set, it means that decoder has not
     stopped completely from previous decoding session */
  qdsp_cmd_qsynth_change_adec_state( NULL, channel, FALSE );

  if (qdsp_cmd_qsynth_adpcm_data[channel].adec_state &
                                           QDSP_CMD_QSYNTH_ADEC_READY) {
    adpcm_data = &qdsp_cmd_qsynth_adpcm_data[channel];
    MSG_MED( "Got buf1 %ld; length1 %ld", adec_cmd->buf1, adec_cmd->length1, 0);

    readyflag1 = qdsp_read((volatile uint16*)adec_buf_ready1);
    readyflag2 = qdsp_read((volatile uint16*)adec_buf_ready2);
    MSG_MED( "Got buf2 %ld; length2 %ld", adec_cmd->buf2, adec_cmd->length2, 0);

    if ((readyflag1 == 0) ||
        (readyflag2 == 0)) {
      MSG_MED( "Ready Flag1:%ld, Flag2:%ld", readyflag1, readyflag2, 0);
      buf_ptr[0] = adec_cmd->buf1;
      buf_ptr[1] = adec_cmd->buf2;
      length_ptr[0] = &adec_cmd->length1;
      length_ptr[1] = &adec_cmd->length2;


      /* reclaim buffer that has been consumed by DSP */
      for (ppbuf_index = 0; ppbuf_index < 2; ppbuf_index++) {
        if ((readyflag1 == 0) && (adpcm_data->buffer != NULL) &&
            (buf_ptr[ppbuf_index] == adpcm_data->buffer) &&
            (*length_ptr[ppbuf_index] == adpcm_data->length)) {
          *length_ptr[ppbuf_index] = 0;
          adpcm_data->buffer       = NULL;
          *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(ppbuf_index));
          MSG_MED("ch%d Reclaim buffer%d", channel, ppbuf_index,0);
        } else if ((readyflag2 == 0) && (adpcm_data->buffer2 != NULL) &&
                   (buf_ptr[ppbuf_index] == adpcm_data->buffer2) &&
                   (*length_ptr[ppbuf_index] == adpcm_data->length2)) {
          *length_ptr[ppbuf_index] = 0;
          adpcm_data->buffer2      = NULL;
          *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(ppbuf_index));
          MSG_MED("ch%d Reclaim buffer%d", channel, ppbuf_index,0);
        }
      }

      if ((*length_ptr[0] == 0) && (*length_ptr[1] == 0)) {
        /* The contract between parser and driver is that
           parser must give preceding data chunk in buffer1
           whenever data is given to driver the first time after
           starting the playback, flush, or all buffers being
           reclaimed. */
        adpcm_data->buf_state = QDSP_CMD_ADEC_STATE_BUFFER1;
      }

      if (adpcm_data->buf_state == QDSP_CMD_ADEC_STATE_BUFFER1) {
        ppbuf_index = 0; /* Start assigning from buffer 1 then buffer 2 */
      } else {
        ppbuf_index = 1; /* Start assigning from buffer 2 then buffer 1 */
      }

      for(adec_index = 0; adec_index < 2; adec_index++) {
		   /* Making sure that ppbuf_index is not greater than array size of length_ptr */
		   ppbuf_index = ppbuf_index & 0x01;
        if ((qdsp_read((volatile uint16*)adec_buf_ready1) == 0) &&
            (*length_ptr[ppbuf_index] != 0) &&
            (buf_ptr[ppbuf_index] != adpcm_data->buffer) &&
            (buf_ptr[ppbuf_index] != adpcm_data->buffer2)) {
          qdsp_cmd_adec_commit_write(adec_buf_start1,
                                     adec_buf_size1,
                                     adec_buf_ready1,
                                     buf_ptr[ppbuf_index],
                                     *length_ptr[ppbuf_index],
                                     adpcm_data->stamp_counter);
          adpcm_data->stamp_counter =
            qdsp_cmd_qsynth_stamp_table[adpcm_data->stamp_counter-1];
          adpcm_data->buffer = buf_ptr[ppbuf_index];
          adpcm_data->length = *length_ptr[ppbuf_index];
          clear_data_is_needed = TRUE;
          write_counter++;
          *adec_cmd->buf_usage_mask |= (GET_ADEC_BUF_MASK(ppbuf_index));
          MSG_LOW("ch%d assign buffer %x as adec buffer 1", channel,
                   buf_ptr[ppbuf_index], 0);
        } else if ((qdsp_read((volatile uint16*)adec_buf_ready2) == 0)
                   && (*length_ptr[ppbuf_index] != 0) &&
                   (buf_ptr[ppbuf_index] != adpcm_data->buffer) &&
                   (buf_ptr[ppbuf_index] != adpcm_data->buffer2)) {
          qdsp_cmd_adec_commit_write(adec_buf_start2,
                                     adec_buf_size2,
                                     adec_buf_ready2,
                                     buf_ptr[ppbuf_index],
                                     *length_ptr[ppbuf_index],
                                     adpcm_data->stamp_counter);
          adpcm_data->stamp_counter =
            qdsp_cmd_qsynth_stamp_table[adpcm_data->stamp_counter-1];
          adpcm_data->buffer2 = buf_ptr[ppbuf_index];
          adpcm_data->length2 = *length_ptr[ppbuf_index];
          clear_data_is_needed = TRUE;
          write_counter++;
          *adec_cmd->buf_usage_mask |= (GET_ADEC_BUF_MASK(ppbuf_index));
          MSG_LOW("ch%d assign buffer %x as adec buffer 2", channel,
                   buf_ptr[ppbuf_index], 0);
        }
        if (adpcm_data->buf_state == QDSP_CMD_ADEC_STATE_BUFFER1) {
          ppbuf_index++;
        } else {
          ppbuf_index--;
        }
      }

      if (write_counter & 0x1) {
        adpcm_data->buf_state ^= 0x1; /* Toggle buffer state */
      }
      if (clear_data_is_needed == TRUE) {
        qdsp_write(adec_data_is_needed, 0);
      }
    } else {
      MSG_MED("ch%d DSP still holds onto two buffers", channel, 0, 0);
    }
  }
}
#else /* FEATURE_GASYNTH_INTERFACE */
/*===========================================================================

FUNCTION QDSP_CMD_QSYNTH_ADEC_WRITE

DESCRIPTION
  This function will write to the QSynth adec buffer.


DEPENDENCIES
  This command is only valid when the DSP is in QSYNTH state.

RETURN VALUE
  The data lengths are updated to mark what was used to fill the DSP buffers
  completely.
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_qsynth_adec_write (
  volatile uint32        adec_data_buf,
  volatile uint32        adec_data_write_ptr,
  volatile uint32        adec_data_free_len,
  uint16                 adec_data_ptr,
  qdsp_cmd_adec_cmd_type *adec_cmd
) {
  uint32 total_bytes, bytes_over = 0;

  total_bytes = adec_cmd->length1 + adec_cmd->length2;
  if(total_bytes >= QDSP_QSYNTH_ADEC_FRAME_SIZE) {
    if((total_bytes > QDSP_QSYNTH_ADEC_FRAME_SIZE) &&
       (total_bytes < 2*QDSP_QSYNTH_ADEC_FRAME_SIZE)) {
      /* The buffer size is verified to ensure we are writing data on frame
      ** boundaries for the QSynth audio decoder. We are taking advantage of
      ** the fact that we know the DSPs buffer size. Doing it this way saves
      ** us from performing a modulus function. If the DSP firmware ever
      ** changes its buffer size, this routine would need to be modified.
      */
      bytes_over = total_bytes - QDSP_QSYNTH_ADEC_FRAME_SIZE;
      if(adec_cmd->length2 >= bytes_over) {
        adec_cmd->length2 -= bytes_over;
      } else {
        adec_cmd->length1 -= (bytes_over - adec_cmd->length2);
        adec_cmd->length2  = 0;
      }
    }
    (void) qdsp_cmd_adec_write(adec_data_buf, adec_data_write_ptr,
                               adec_data_free_len, adec_data_ptr,
                               adec_cmd);

    adec_cmd->length1 += bytes_over;
  }
}
#endif /* FEATURE_GASYNTH_INTERFACE */
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP || FEATURE_QSYNTH_ADPCM */
#endif /* FEATURE_ADEC */

/* <EJECT> */
#if defined(FEATURE_ADEC) || defined(FEATURE_WAVE_PB)
/*===========================================================================

FUNCTION QDSP_CMD_WAV_CONFIG

DESCRIPTION
  This function will configure the WAV decoder parameters.

DEPENDENCIES
  This command is valid anytime.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_wav_config(qdsp_cmd_wav_format_type format) {
  if ( format != QDSP_CMD_WAV_FORMAT_INVALID ) {
    /* Initialize graph/vocoder ADPCM parameters */
    qdsp_cmd_adpcm_status = QDSP_CMD_ADPCM_MODE_DISABLED;

    qdsp_cmd_adpcm_data   = FALSE;

    qdsp_cmd_adpcm_adec_info.buf_ptr        = NULL;
    qdsp_cmd_adpcm_adec_info.buf_length     = 0;
    qdsp_cmd_adpcm_adec_info.tmp_buf_length = 0;
    qdsp_cmd_adpcm_status = QDSP_CMD_ADPCM_MODE_ENABLED;
  }
  qdsp_cmd_wav_format = format;
}
/*===========================================================================

FUNCTION QDSP_CMD_ADEC

DESCRIPTION
  This function will fill the DSP's ADEC buffers with data.

DEPENDENCIES
  This command is only valid when the DSP is in QTUNES or QSYNTH state.

RETURN VALUE
  The data lengths are updated to mark what was used to fill the DSP buffers
  completely.
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec (
  qdsp_cmd_adec_cmd_type *adec_cmd
)
{
#ifdef FEATURE_QTUNES_COMMON
  boolean wrote_data;
#endif /* FEATURE_QTUNES_COMMON */

#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
  switch(qdsp_cmd_image_select){
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
  case QDSP_IMAGE_CAM_AUDIO_CONC:
    if (qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_MP3){
       if((qdsp_cmd_adec_int_cb_ptr != NULL) &&
         (qdsp_cmd_get_state() == QDSP_STATE_TUNES)) {
#if defined(QDSP_adecDataBufPtr) && defined(QDSP_adecDataBufPtrMSW)
            /* The adecDataBuf has a unique address and size for each DSP
            ** decoder implementation. Because of this, sharing the same
            ** adecDataBuf for multiple ADECs in concurrent images is not
            ** possible. The pointer indirection interface exported by the
            ** DSP, adecDataBufPtr and adecDataBufPtrMSW, allows a
            ** workaround for the driver to access adecDataBuf. The
            ** dereference of the DSP address composed of adecDataBufPtr and
            ** adecDataBufPtrMSW is a relative offset from adecDataBufPtr to
            ** adecDataBuf. It is necessary for adecDataBufPtr to be in the
            ** same memory bank as adecDataBuf.
            */
            if(((uint32*) QDSP_adecDataBufPtr != QDSP_NOP_ADDRESS) &&
               ((uint32*) QDSP_adecDataBufPtrMSW != QDSP_NOP_ADDRESS)) {
              wrote_data = qdsp_cmd_adec_write(
                             (((uint32) QDSP_adecDataBufPtr) +
                              ((qdsp_read(QDSP_adecDataBufPtrMSW) <<
                                QDSP_adecDataBufPtr_SIZE) |
                               qdsp_read(QDSP_adecDataBufPtr))),
                             (uint32) QDSP_adecDataWritePtr,
                             (uint32) QDSP_adecDataFreeLen,
                             qdsp_cmd_adec_data_ptr0, adec_cmd);
         } else
#endif /* QDSP_adecDataBufPtr && QDSP_adecDataBufPtrMSW */
         {
           wrote_data = qdsp_cmd_adec_write((uint32) QDSP_adecDataBuf,
                                  (uint32) QDSP_adecDataWritePtr,
                                  (uint32) QDSP_adecDataFreeLen,
                                  qdsp_cmd_adec_data_ptr0, adec_cmd);
          }

          if(wrote_data) {
            /* Host clears the semaphore flag when done */
            qdsp_write(QDSP_adecDataHostStickyInt, 0);
            } else {
              MSG_LOW("Waiting for data", 0,0,0);
            }
          }
    }else
    if ( qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_WAVE ){
               qdsp_cmd_send_synth_adpcm_data( adec_cmd);
    }
    return ( QDSP_CMD_SUCCESS);
    break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
    default :
    break;
}
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */

  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_QTUNES_COMMON
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED*/
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
      if((qdsp_cmd_adec_int_cb_ptr != NULL) &&
         (qdsp_cmd_get_state() == QDSP_STATE_TUNES)) {
#if defined(QDSP_adecDataBufPtr) && defined(QDSP_adecDataBufPtrMSW)
        /* The adecDataBuf has a unique address and size for each DSP
        ** decoder implementation. Because of this, sharing the same
        ** adecDataBuf for multiple ADECs in concurrent images is not
        ** possible. The pointer indirection interface exported by the
        ** DSP, adecDataBufPtr and adecDataBufPtrMSW, allows a
        ** workaround for the driver to access adecDataBuf. The
        ** dereference of the DSP address composed of adecDataBufPtr and
        ** adecDataBufPtrMSW is a relative offset from adecDataBufPtr to
        ** adecDataBuf. It is necessary for adecDataBufPtr to be in the
        ** same memory bank as adecDataBuf.
        */
        if(((uint32*) QDSP_adecDataBufPtr != QDSP_NOP_ADDRESS) &&
           ((uint32*) QDSP_adecDataBufPtrMSW != QDSP_NOP_ADDRESS)) {
          wrote_data = qdsp_cmd_adec_write(
                         (((uint32) QDSP_adecDataBufPtr) +
                          ((qdsp_read(QDSP_adecDataBufPtrMSW) <<
                            QDSP_adecDataBufPtr_SIZE) |
                           qdsp_read(QDSP_adecDataBufPtr))),
                         (uint32) QDSP_adecDataWritePtr,
                         (uint32) QDSP_adecDataFreeLen,
                         qdsp_cmd_adec_data_ptr0, adec_cmd);
        } else
#endif /* QDSP_adecDataBufPtr && QDSP_adecDataBufPtrMSW */
        {
          wrote_data = qdsp_cmd_adec_write((uint32) QDSP_adecDataBuf,
                              (uint32) QDSP_adecDataWritePtr,
                              (uint32) QDSP_adecDataFreeLen,
                              qdsp_cmd_adec_data_ptr0, adec_cmd);
        }

        if(wrote_data) {
          /* Host clears the semaphore flag when done */
          qdsp_write(QDSP_adecDataHostStickyInt, 0);
        } else {
          MSG_LOW("Waiting for data", 0,0,0);
        }
      }
      break;

#if defined(QDSP_IMAGE_WM_DEFINED) || defined(QDSP_IMAGE_WM_PRO_DEFINED)
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /*QDSP_IMAGE_WM_DEFINED*/

#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_WM_PRO_DEFINED*/

      if((qdsp_cmd_adec_int_cb_ptr != NULL) &&
         (qdsp_cmd_get_state() == QDSP_STATE_TUNES)) {
        wrote_data = qdsp_cmd_adec_dme_write(adec_cmd);

        if(wrote_data) {
          /* Host clears the semaphore flag when done */
          qdsp_write(QDSP_adecDataHostStickyInt, 0);
        } else {
          MSG_LOW("Waiting for data", 0,0,0);
        }
      }
      break;
#endif /* QDSP_IMAGE_WM_DEFINED || QDSP_IMAGE_WM_PRO_DEFINED */

#endif /* FEATURE_QTUNES_COMMON */

#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP) || \
    defined(FEATURE_QSYNTH_ADPCM)
#ifdef FEATURE_GASYNTH_INTERFACE
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
     defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
      if(qdsp_cmd_adec_int_cb_ptr != NULL) {
        qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBufStartMSW1Ch0,
                                   (uint32) QDSP_adecDataBufStartMSW2Ch0,
                                   (uint32) QDSP_adecDataBufSize1Ch0,
                                   (uint32) QDSP_adecDataBufSize2Ch0,
                                   (uint32) QDSP_adecDataBufReadyFlag1Ch0,
                                   (uint32) QDSP_adecDataBufReadyFlag2Ch0,
                                   0,&adec_cmd[0]);
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
     {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
        qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBufStartMSW1Ch1,
                                   (uint32) QDSP_adecDataBufStartMSW2Ch1,
                                   (uint32) QDSP_adecDataBufSize1Ch1,
                                   (uint32) QDSP_adecDataBufSize2Ch1,
                                   (uint32) QDSP_adecDataBufReadyFlag1Ch1,
                                   (uint32) QDSP_adecDataBufReadyFlag2Ch1,
                                   1,&adec_cmd[1]);
        qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBufStartMSW1Ch2,
                                   (uint32) QDSP_adecDataBufStartMSW2Ch2,
                                   (uint32) QDSP_adecDataBufSize1Ch2,
                                   (uint32) QDSP_adecDataBufSize2Ch2,
                                   (uint32) QDSP_adecDataBufReadyFlag1Ch2,
                                   (uint32) QDSP_adecDataBufReadyFlag2Ch2,
                                   2,&adec_cmd[2]);
        qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBufStartMSW1Ch3,
                                   (uint32) QDSP_adecDataBufStartMSW2Ch3,
                                   (uint32) QDSP_adecDataBufSize1Ch3,
                                   (uint32) QDSP_adecDataBufSize2Ch3,
                                   (uint32) QDSP_adecDataBufReadyFlag1Ch3,
                                   (uint32) QDSP_adecDataBufReadyFlag2Ch3,
                                   3,&adec_cmd[3]);
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
     }
        if (qdsp_read(QDSP_adecDataHostStickyInt) != 0) {
          qdsp_write(QDSP_adecDataHostStickyInt, 0);
        }
      }
      break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED || QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#else
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
      if(qdsp_cmd_adec_int_cb_ptr != NULL) {
#ifdef FEATURE_QSYNTH_ADPCM
        if(qdsp_cmd_get_qsynth_adec_mode() == QDSP_CMD_QSYNTH_ADEC_QCP)
#endif /* FEATURE_QSYNTH_ADPCM */
        {
          qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBuf,
                                     (uint32) QDSP_adecDataWritePtr,
                                     (uint32) QDSP_adecDataFreeLen,
                                     qdsp_cmd_adec_data_ptr0, &adec_cmd[0]);

#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
   {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS

          qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBuf1,
                                     (uint32) QDSP_adecDataWritePtr1,
                                     (uint32) QDSP_adecDataFreeLen1,
                                     qdsp_cmd_adec_data_ptr1, &adec_cmd[1]);

          qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBuf2,
                                     (uint32) QDSP_adecDataWritePtr2,
                                     (uint32) QDSP_adecDataFreeLen2,
                                     qdsp_cmd_adec_data_ptr2, &adec_cmd[2]);

          qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBuf3,
                                     (uint32) QDSP_adecDataWritePtr3,
                                     (uint32) QDSP_adecDataFreeLen3,
                                     qdsp_cmd_adec_data_ptr3, &adec_cmd[3]);

#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
   }
          qdsp_write(QDSP_adecDataHostStickyInt, 0);
          break;
        }
      }
#endif /* QDSP_IMAGE_SYNTH_DEFINED */

#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef FEATURE_QSYNTH_ADPCM
      if(qdsp_cmd_adec_int_cb_ptr != NULL) {
        qdsp_cmd_qsynth_adpcm_write((uint32) QDSP_adecAdpcmDataBufStart0,
                                    (uint32) QDSP_adecAdpcmDataBufSize0,
                                    (uint32) QDSP_adecAdpcmDataReadPtrOffset0,
                                    (uint32) QDSP_adecReset, 0, &adec_cmd[0]);
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
  {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
        qdsp_cmd_qsynth_adpcm_write((uint32) QDSP_adecAdpcmDataBufStart1,
                                    (uint32) QDSP_adecAdpcmDataBufSize1,
                                    (uint32) QDSP_adecAdpcmDataReadPtrOffset1,
                                    (uint32) QDSP_adecReset1, 1, &adec_cmd[1]);

        qdsp_cmd_qsynth_adpcm_write((uint32) QDSP_adecAdpcmDataBufStart2,
                                    (uint32) QDSP_adecAdpcmDataBufSize2,
                                    (uint32) QDSP_adecAdpcmDataReadPtrOffset2,
                                    (uint32) QDSP_adecReset2, 2, &adec_cmd[2]);

        qdsp_cmd_qsynth_adpcm_write((uint32) QDSP_adecAdpcmDataBufStart3,
                                    (uint32) QDSP_adecAdpcmDataBufSize3,
                                    (uint32) QDSP_adecAdpcmDataReadPtrOffset3,
                                    (uint32) QDSP_adecReset3, 3, &adec_cmd[3]);
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
      	}
        /* Host clears the semaphore flag when done */
        qdsp_write(QDSP_adecDataHostStickyInt, 0);
      }
#endif /* FEATURE_QSYNTH_ADPCM */
      break;
#endif /* FEATURE_GASYNTH_INTERFACE */
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP || FEATURE_QSYNTH_ADPCM */

#ifdef FEATURE_GRAPH_ADPCM
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */
#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */
#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
#endif /* QDSP_IMAGE_QCAMCORDER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
#endif /* QDSP_IMAGE_AACENC_DEFINED */

      INTLOCK();
#ifdef FEATURE_GASYNTH_INTERFACE
      if (qdsp_cmd_adpcm_adec_info.free_ptr != NULL) {

        if (qdsp_cmd_adpcm_adec_info.free_ptr == adec_cmd->buf1) {
          adec_cmd->length1 = 0; /* Reclaim buffer 1 */
          *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(0));
        } else if (qdsp_cmd_adpcm_adec_info.free_ptr == adec_cmd->buf2) {
          adec_cmd->length2 = 0; /* Reclaim buffer 2 */
          *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(1));
        } else {
          MSG_ERROR("Invalid adpcm buffer", 0, 0, 0);
        }
        qdsp_cmd_adpcm_adec_info.free_ptr = NULL;
      }

      if (qdsp_cmd_adpcm_adec_info.buf_ptr == NULL) {
        if ((qdsp_cmd_adpcm_adec_info.buf_state ==
             QDSP_CMD_ADEC_STATE_BUFFER1) && (adec_cmd->length1 != 0)) {
          qdsp_cmd_adpcm_adec_info.buf_ptr = adec_cmd->buf1;
          qdsp_cmd_adpcm_adec_info.buf_index = 0;
          qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
          qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
          *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(0);
          qdsp_cmd_graph_adpcm_send_frame();
        } else if ((qdsp_cmd_adpcm_adec_info.buf_state ==
             QDSP_CMD_ADEC_STATE_BUFFER2) && (adec_cmd->length2 != 0)) {
          qdsp_cmd_adpcm_adec_info.buf_ptr = adec_cmd->buf2;
          qdsp_cmd_adpcm_adec_info.buf_index = 0;
          qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length2;
          qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
          *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(1);
          qdsp_cmd_graph_adpcm_send_frame();
        }
      }

      if (qdsp_cmd_adpcm_adec_info.next_ptr == NULL) {
        if ((qdsp_cmd_adpcm_adec_info.buf_state ==
             QDSP_CMD_ADEC_STATE_BUFFER1) && (adec_cmd->length1 != 0)) {
          qdsp_cmd_adpcm_adec_info.next_ptr = adec_cmd->buf1;
          qdsp_cmd_adpcm_adec_info.next_length = adec_cmd->length1;
          qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
          *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(0);
        } else if ((qdsp_cmd_adpcm_adec_info.buf_state ==
             QDSP_CMD_ADEC_STATE_BUFFER2) && (adec_cmd->length2 != 0)) {
          qdsp_cmd_adpcm_adec_info.next_ptr = adec_cmd->buf2;
          qdsp_cmd_adpcm_adec_info.next_length = adec_cmd->length2;
          qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
          *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(1);
        }
      }
#else
      if(qdsp_cmd_adpcm_adec_info.buf_length == 0) {
        qdsp_cmd_adpcm_adec_info.buf_ptr    = adec_cmd->buf2;
        qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
        adec_cmd->length1                   = 0;
        qdsp_cmd_graph_adpcm_send_frame();
      }
#endif /* FEATURE_GASYNTH_INTERFACE */
      INTFREE();
      break;
#endif /* FEATURE_GRAPH_ADPCM */

#ifdef FEATURE_VOC_ADPCM
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif /* QDSP_IMAGE_VOC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif /* QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif /* QDSP_IMAGE_VOC_EVRC_DEFINED */
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif /* QDSP_IMAGE_VOC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif /* QDSP_IMAGE_VOC_EVRC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_FR_DEFINED */
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_EFR_DEFINED */
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif /* QDSP_IMAGE_AMR_DEFINED */
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif /* QDSP_IMAGE_AMR_WB_DEFINED */
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif /* QDSP_IMAGE_HR_DEFINED */
      {
        INTLOCK();
#ifdef MSMAUD_VOC_G711
        if(qdsp_voc_mode == QDSP_VOC_MODE_G711_V)
        {
          if(qdsp_cmd_adpcm_adec_info.buf_length == 0) {
            qdsp_cmd_adpcm_adec_info.buf_ptr    = adec_cmd->buf2;
            qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
            adec_cmd->length1                   = 0;
            qdsp_cmd_voc_wav_send_frame();
          }
        }
        else
#endif
        {
#ifdef FEATURE_GASYNTH_INTERFACE
          if (qdsp_cmd_adpcm_adec_info.free_ptr != NULL) {

            if (qdsp_cmd_adpcm_adec_info.free_ptr == adec_cmd->buf1) {
              adec_cmd->length1 = 0; /* Reclaim buffer 1 */
              *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(0));
            } else if (qdsp_cmd_adpcm_adec_info.free_ptr == adec_cmd->buf2) {
              adec_cmd->length2 = 0; /* Reclaim buffer 2 */
              *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(1));
            } else {
              MSG_ERROR("Invalid adpcm buffer", 0, 0, 0);
            }
            qdsp_cmd_adpcm_adec_info.free_ptr = NULL;
          }

          if (qdsp_cmd_adpcm_adec_info.buf_ptr == NULL) {
            if ((qdsp_cmd_adpcm_adec_info.buf_state ==
              QDSP_CMD_ADEC_STATE_BUFFER1) && (adec_cmd->length1 != 0)) {
              qdsp_cmd_adpcm_adec_info.buf_ptr = adec_cmd->buf1;
              qdsp_cmd_adpcm_adec_info.buf_index = 0;
              qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
              qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
              *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(0);
              qdsp_cmd_voc_adpcm_send_frame();
            } else if ((qdsp_cmd_adpcm_adec_info.buf_state ==
              QDSP_CMD_ADEC_STATE_BUFFER2) && (adec_cmd->length2 != 0)) {
              qdsp_cmd_adpcm_adec_info.buf_ptr = adec_cmd->buf2;
              qdsp_cmd_adpcm_adec_info.buf_index = 0;
              qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length2;
              qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
              *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(1);
              qdsp_cmd_voc_adpcm_send_frame();
            }
          }

          if (qdsp_cmd_adpcm_adec_info.next_ptr == NULL) {
            if ((qdsp_cmd_adpcm_adec_info.buf_state ==
              QDSP_CMD_ADEC_STATE_BUFFER1) && (adec_cmd->length1 != 0)) {
              qdsp_cmd_adpcm_adec_info.next_ptr = adec_cmd->buf1;
              qdsp_cmd_adpcm_adec_info.next_length = adec_cmd->length1;
              qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
              *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(0);
            } else if ((qdsp_cmd_adpcm_adec_info.buf_state ==
              QDSP_CMD_ADEC_STATE_BUFFER2) && (adec_cmd->length2 != 0)) {
              qdsp_cmd_adpcm_adec_info.next_ptr = adec_cmd->buf2;
              qdsp_cmd_adpcm_adec_info.next_length = adec_cmd->length2;
              qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
              *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(1);
            }
          }
#else
          if(qdsp_cmd_adpcm_adec_info.buf_length == 0) {
            qdsp_cmd_adpcm_adec_info.buf_ptr    = adec_cmd->buf2;
            qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
            adec_cmd->length1                   = 0;
            qdsp_cmd_voc_adpcm_send_frame();
          }
#endif /* FEATURE_GASYNTH_INTERFACE */
        }
        INTFREE();
      }
      break;
#endif /* FEATURE_VOC_ADPCM */

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */

      if ((qdsp_cmd_adec_int_cb_ptr  != NULL)                &&
#ifdef FEATURE_AVS_INCALL_ADEC_PB
          (qdsp_cmd_get_state()      == QDSP_STATE_ADEC_VOC) &&
#endif /* FEATURE_AVS_INCALL_ADEC_PB */
          (qdsp_cmd_get_adec_state() == QDSP_STATE_TUNES)) {

        switch (qdsp_cmd_module_select) {
#ifdef FEATURE_AVS_IN_CALL_WMA
          case QDSP_MODULE_TUNES_WMA_INCALL_MIXER_13K:
          case QDSP_MODULE_TUNES_WMA_INCALL_MIXER_EVRC:
          case QDSP_MODULE_TUNES_WMA_INCALL_MIXER_AMR:
          case QDSP_MODULE_TUNES_WMA_INCALL_MIXER_EFR:
          case QDSP_MODULE_TUNES_WMA_INCALL_MIXER_FR:
          case QDSP_MODULE_TUNES_WMA_INCALL_MIXER_HR:
            wrote_data = qdsp_cmd_adec_dme_write(adec_cmd);
            break;
#endif
        default:
#if defined(QDSP_adecDataBufPtr) && defined(QDSP_adecDataBufPtrMSW)
        /* The adecDataBuf has a unique address and size for each DSP
        ** decoder implementation. Because of this, sharing the same
        ** adecDataBuf for multiple ADECs in concurrent images is not
        ** possible. The pointer indirection interface exported by the
        ** DSP, adecDataBufPtr and adecDataBufPtrMSW, allows a
        ** workaround for the driver to access adecDataBuf. The
        ** dereference of the DSP address composed of adecDataBufPtr and
        ** adecDataBufPtrMSW is a relative offset from adecDataBufPtr to
        ** adecDataBuf. It is necessary for adecDataBufPtr to be in the
        ** same memory bank as adecDataBuf.
        */
        if(((uint32*) QDSP_adecDataBufPtr != QDSP_NOP_ADDRESS) &&
           ((uint32*) QDSP_adecDataBufPtrMSW != QDSP_NOP_ADDRESS)) {
          wrote_data = qdsp_cmd_adec_write((((uint32) QDSP_adecDataBufPtr) +
                         ((qdsp_read(QDSP_adecDataBufPtrMSW) <<
                         QDSP_adecDataBufPtr_SIZE) |
                         qdsp_read(QDSP_adecDataBufPtr))),
                         (uint32) QDSP_adecDataWritePtr,
                         (uint32) QDSP_adecDataFreeLen,
                         qdsp_cmd_adec_data_ptr0, adec_cmd);
        } else
#endif /* QDSP_adecDataBufPtr && QDSP_adecDataBufPtrMSW */
        {
          wrote_data = qdsp_cmd_adec_write((uint32) QDSP_adecDataBuf,
                         (uint32) QDSP_adecDataWritePtr,
                         (uint32) QDSP_adecDataFreeLen,
                         qdsp_cmd_adec_data_ptr0, adec_cmd);
        }
        break;
       }
        if(wrote_data) {
          /* Host clears the semaphore flag when done */
          qdsp_write(QDSP_adecDataHostStickyInt, 0);
        } else {
          MSG_LOW("Waiting for data", 0,0,0);
        }
      }
      break;
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */

#if defined(QDSP_IMAGE_G711_DEFINED) && defined(MSMAUD_VOC_G711) &&\
    defined(FEATURE_WAVE_PB)
    case QDSP_IMAGE_G711:
      INTLOCK();
      if(qdsp_cmd_adpcm_adec_info.buf_length == 0) {
        qdsp_cmd_adpcm_adec_info.buf_ptr    = adec_cmd->buf2;
        qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
        adec_cmd->length1                   = 0;
        qdsp_cmd_voc_wav_send_frame();
      }
      INTFREE();
      break;
#endif /* (QDSP_IMAGE_G711_DEFINED) && (MSMAUD_VOC_G711) &&
          (FEATURE_WAVE_PB) */

    default:
      MSG_ERROR("ADEC write called in %d image",qdsp_cmd_image_select,0,0);
      return(QDSP_CMD_FAILED);
  }

  return(QDSP_CMD_SUCCESS);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_adec_int_pending

DESCRIPTION
  This function checks for a pending ADEC interrupt.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if an interrupt is pending.

SIDE EFFECTS
  None.

===========================================================================*/
boolean qdsp_cmd_adec_int_pending()
{
  boolean ret_val = FALSE;
  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
      if (qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_MP3){
         ret_val = (qdsp_read(QDSP_adecDataHostStickyInt) != 0);
      }else if (qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_WAVE){
#ifdef FEATURE_GASYNTH_INTERFACE
         /* Because of ping-pong buffer architecture, interrupt
         does not necessarily mean that DSP has consumed
         all the data, so need to check dataIsNeeded flag */
         ret_val = qdsp_cmd_adec_data_consumed(0);
#endif /* FEATURE_GASYNTH_INTERFACE */
      }
      break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */

#if defined(FEATURE_QTUNES_COMMON) || defined(FEATURE_QSYNTH_COMMON)
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
      /* Because of ping-pong buffer architecture, interrupt
         does not necessarily mean that DSP has consumed
         all the data, so need to check dataIsNeeded flag */
      ret_val = qdsp_cmd_adec_data_consumed(0);
      break;
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#ifdef FEATURE_GASYNTH_INTERFACE
      /* Because of ping-pong buffer architecture, interrupt
         does not necessarily mean that DSP has consumed
         all the data, so need to check dataIsNeeded flag */
      ret_val = qdsp_cmd_adec_data_consumed(0);
      break;
#endif /* FEATURE_GASYNTH_INTERFACE */
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED*/
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
      ret_val = (qdsp_read(QDSP_adecDataHostStickyInt) != 0);
      break;
#endif /* FEATURE_QTUNES_COMMON || FEATURE_QSYNTH_COMMON */

#if defined(FEATURE_GRAPH_ADPCM) || defined (FEATURE_VOC_ADPCM)
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */
#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */
#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
#endif /* QDSP_IMAGE_QCAMCORDER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
#endif /* QDSP_IMAGE_AACENC_DEFINED */

      ret_val = (qdsp_cmd_adpcm_adec_info.buf_length == 0);
      break;
#endif /* FEATURE_GRAPH_ADPCM */

#if defined(FEATURE_VOC_ADPCM)          || \
    (defined(FEATURE_WAVE_PB) && defined(FEATURE_VOC_G711))
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif /* QDSP_IMAGE_VOC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif /* QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif /* QDSP_IMAGE_VOC_EVRC_DEFINED */
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif /* QDSP_IMAGE_VOC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif /* QDSP_IMAGE_VOC_EVRC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_FR_DEFINED */
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_EFR_DEFINED */
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif /* QDSP_IMAGE_AMR_DEFINED */
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif /* QDSP_IMAGE_AMR_WB_DEFINED */
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif /* QDSP_IMAGE_HR_DEFINED */
#if defined(FEATURE_WAVE_PB) && defined(FEATURE_VOC_G711)
#ifdef QDSP_IMAGE_G711_DEFINED
    case QDSP_IMAGE_G711:
#endif /* QDSP_IMAGE_G711_DEFINED */
#endif /* FEATURE_WAVE_PB && FEATURE_VOC_G711 */
      {
#ifdef FEATURE_GASYNTH_INTERFACE
        ret_val = ((qdsp_cmd_adpcm_adec_info.buf_length == 0) &&
                  (qdsp_cmd_adpcm_adec_info.next_ptr == NULL));
#else
        ret_val = (qdsp_cmd_adpcm_adec_info.buf_length == 0);
#endif /* FEATURE_GASYNTH_INTERFACE */
      }
      break;
#endif /* FEATURE_VOC_ADPCM || (FEATURE_WAVE_PB && FEATURE_VOC_G711) */

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */

      if ((qdsp_cmd_adec_int_cb_ptr  != NULL) &&
#ifdef FEATURE_AVS_INCALL_ADEC_PB
          (qdsp_cmd_get_state()      == QDSP_STATE_ADEC_VOC) &&
#endif /* FEATURE_AVS_INCALL_ADEC_PB */
          (qdsp_cmd_get_adec_state() == QDSP_STATE_TUNES)) {
        ret_val = (qdsp_read(QDSP_adecDataHostStickyInt) != 0);
      }
      break;
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */

    default:
      break;
  }

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_ADEC_PAUSE

DESCRIPTION
  This function sets/clears the audio decoder pause flag.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec_pause (
  boolean pause     /* TRUE if output should be paused */
) {

#if defined(FEATURE_ARM_POST_PROCESSING) || defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
  uint32 isave;
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
      if ( qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_MP3 ){
        qdsp_write(QDSP_audioPause, (uint16)pause);
        if(pause == FALSE){
          qdsp_write(QDSP_adecDataHostStickyInt, 0);
        }
      }else if ( qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_WAVE ){
#ifdef FEATURE_GASYNTH_INTERFACE
         qdsp_cmd_adec_chan_pause(0, pause);
         break;
#endif /* FEATURE_GASYNTH_INTERFACE */
      }
      break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */

#ifdef FEATURE_QTUNES_COMMON
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED*/
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
      qdsp_write(QDSP_audioPause, (uint16)pause);
      if(pause == FALSE){
        qdsp_write(QDSP_adecDataHostStickyInt, 0);
      }
      break;
#endif /* FEATURE_QTUNES_COMMON */

#ifdef FEATURE_QSYNTH_ADPCM
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
      /* fall through since GASYNTH_INTERFACE
         is prerequsite feature */
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#ifdef FEATURE_GASYNTH_INTERFACE
      qdsp_cmd_adec_chan_pause(0, pause);
      break;
#endif /* FEATURE_GASYNTH_INTERFACE */
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT
      qdsp_write(QDSP_adecPause, (uint16)pause);
#else
      qdsp_write(QDSP_audioPause, (uint16)pause);
#endif /* MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT */
      break;
#endif /* FEATURE_QSYNTH_ADPCM */

#if defined(FEATURE_GRAPH_ADPCM)        || \
    defined(FEATURE_VOC_ADPCM)          || \
    (defined(FEATURE_WAVE_PB) && defined(FEATURE_VOC_G711))
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */
#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */
#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef FEATURE_VOC_ADPCM
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif /* QDSP_IMAGE_VOC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif /* QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif /* QDSP_IMAGE_VOC_EVRC_DEFINED */
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif /* QDSP_IMAGE_VOC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif /* QDSP_IMAGE_VOC_EVRC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_FR_DEFINED */
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_EFR_DEFINED */
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif /* QDSP_IMAGE_AMR_DEFINED */
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif /* QDSP_IMAGE_AMR_WB_DEFINED */
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif /* QDSP_IMAGE_HR_DEFINED */
#endif /* FEATURE_VOC_ADPCM */
#if (defined(FEATURE_WAVE_PB) && defined(FEATURE_VOC_G711))
#ifdef QDSP_IMAGE_G711_DEFINED
    case QDSP_IMAGE_G711:
#endif /* QDSP_IMAGE_G711_DEFINED */
#endif /* FEATURE_WAVE_PB && FEATURE_VOC_G711 */
      if(qdsp_cmd_adpcm_status != QDSP_CMD_ADPCM_MODE_DISABLED) {
        if(pause) {
          qdsp_cmd_adpcm_status = QDSP_CMD_ADPCM_MODE_PAUSED;
        } else {
          qdsp_cmd_adpcm_status = QDSP_CMD_ADPCM_MODE_ENABLED;
        }
      }
      break;
#endif /* FEATURE_GRAPH_ADPCM || FEATURE_VOC_ADPCM ||
          (FEATURE_WAVE_PB && FEATURE_VOC_G711) */

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
#ifdef FEATURE_AVS_INCALL_ADEC_PB
      if ((qdsp_cmd_adec_int_cb_ptr  != NULL) &&
          (qdsp_cmd_get_state()      == QDSP_STATE_ADEC_VOC))
#endif /* FEATURE_AVS_INCALL_ADEC_PB */
#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
      if (qdsp_cmd_adec_int_cb_ptr  != NULL)
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB */
      {
        qdsp_write(QDSP_audioPause, (uint16)pause);
        if(pause == FALSE){
          qdsp_write(QDSP_adecDataHostStickyInt, 0);
        }
      }
      break;
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */

    default: /* NO OP */
      break;
  }
#if defined(FEATURE_ARM_POST_PROCESSING) || defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
  if  (qdsp_cmd_arm_pp_cb != NULL)
  {
    switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_AAC_DEFINED)          || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)      || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_SYNTH_DEFINED)        || \
    defined(QDSP_IMAGE_TUNES_DEFINED)        || \
    defined(QDSP_IMAGE_WM_DEFINED)           || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED)       || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)

#ifdef QDSP_IMAGE_TUNES_DEFINED
      case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_AAC_DEFINED
      case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
      case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
      case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
      case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
      case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */

        INTLOCK_SAV(isave);
#ifdef FEATURE_ARM_POST_PROCESSING
        if (pause)
        {
          /* We will say that DATA is not ready and so DSP will not read any of
          the buffers that are pending */
          qdsp_write(QDSP_hostOutIntfDataIsReady,
                     QDSP_CMD_ARM_PP_DATA_NOT_READY);
        }
        else if ((qdsp_cmd_pp_pause) && (qdsp_cmd_pp_write_q_pending_num >= 1))
        {
          /* We are paused, and now we need to resume,  so if we have any
          buffers on our write queue tell the DSP that data is ready */
          qdsp_write(QDSP_hostOutIntfDataIsReady, QDSP_CMD_ARM_PP_DATA_READY );
        }
#endif /* FEATURE_ARM_POST_PROCESSING*/

        qdsp_cmd_pp_pause = pause;
        INTFREE_SAV(isave);
        break;

#endif /* QDSP_IMAGE_AAC_DEFINED  || QDSP_IMAGE_QTV_AAC_DEFINED ||
          QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
      default:
        break;
    }
  }
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

  return( QDSP_CMD_SUCCESS );
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_MASTER_PAN

DESCRIPTION
  This function sets the master pan setting for audio formats.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_master_pan (
  sint7 pan
)
{
  qdsp_cmd_status_type ret_val = QDSP_CMD_SUCCESS;

  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
      if ( qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_MP3 ){
         qdsp_write(QDSP_masterPan, pan);
      }else if ( qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_WAVE ){
         qdsp_write(QDSP_adecStereoPan, pan);
      }
      break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */

#if defined(QDSP_IMAGE_TUNES_DEFINED) || \
    defined(QDSP_IMAGE_MP4D_MP3_DEFINED) || \
    defined(QDSP_IMAGE_H263D_MP3_DEFINED) || \
    defined(QDSP_IMAGE_AAC_DEFINED) || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED) || \
    defined(QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED) || \
    defined(QDSP_IMAGE_MP4D_AAC_DEFINED) || \
    defined(QDSP_IMAGE_H263D_AAC_DEFINED) || \
    defined(QDSP_IMAGE_H264D_AAC_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)  || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED) || \
    defined(QDSP_IMAGE_RA_DEFINED) || \
    defined(QDSP_IMAGE_WM) || \
    defined(QDSP_IMAGE_WM_PRO_DEFINED) || \
    defined(QDSP_IMAGE_QTV_CONC)

#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED*/
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA */
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
      qdsp_write(QDSP_masterPan, pan);
      break;
#endif

#ifdef FEATURE_QSYNTH_ADPCM
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
      qdsp_write(QDSP_adecStereoPan, pan);
      break;
#endif /* FEATURE_QSYNTH_ADPCM */

    default:
      ret_val = QDSP_CMD_FAILED;
      break;
  }
  return(ret_val);
}
#endif /* FEATURE_ADEC || FEATURE_WAVE_PB */

/* <EJECT> */
#ifdef FEATURE_ADEC
/*===========================================================================

FUNCTION QDSP_CMD_ADEC_FLUSH

DESCRIPTION
  This function flushes the DSPs ADEC buffers.

DEPENDENCIES
  Must be in QTUNES state.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec_flush ( uint16 flush_mask )
{
  uint16 flush_command[3]; /* Local buffer for the command */
  qdsp_cmd_status_type result = QDSP_CMD_SUCCESS;

#if defined(FEATURE_ARM_POST_PROCESSING) || defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
  uint32 isave = 0;
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

#ifndef FEATURE_GASYNTH_INTERFACE
#ifdef FEATURE_QSYNTH_ADPCM
  uint16 current_mode;
#endif /* FEATURE_GASYNTH_ADPCM */
#endif /* FEATURE_GASYNTH_INTERFACE */

  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
   case QDSP_IMAGE_CAM_AUDIO_CONC:
     if (qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_MP3){
       flush_command[0] = BITSTREAM_FLUSH_CMD_SIZE; /* Length of the command */
       flush_command[1] = BITSTREAM_FLUSH_CMD_HDR;  /* Command header        */
       flush_command[2] = flush_mask;               /* Channels to flush     */
       /* Now send the Bitstream Flush command to the QDSP */
#if defined(FEATURE_ARM_POST_PROCESSING) || defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
       INTLOCK_SAV(isave);
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */
       result = qdsp2_command( flush_command );
#if defined(FEATURE_ARM_POST_PROCESSING) || defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
       /* if we are doing PP now, we will have to flush out all our buffers
       and reinitialize all the PP module's internal variables
       */
       if (qdsp_cmd_arm_pp_cb != NULL)
       {
         qdsp_cmd_pp_reset();
       }
       INTFREE_SAV(isave);
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

       /* Force the DSP to interrupt for data after flush is complete */
       if (result == QDSP_CMD_SUCCESS) {
         qdsp_write(QDSP_adecDataHostStickyInt, 0);
       }
    }else if (qdsp_cmd_get_decoder_in_use() == QDSP_CMD_DEC_WAVE){
      /* Nothing to do */
    }
   break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */

#if defined(FEATURE_QTUNES_COMMON)
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED*/
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#if defined(QDSP_IMAGE_WM_DEFINED) || defined (QDSP_IMAGE_WM_PRO_DEFINED)
      qdsp_cmd_adec_data_buffer_size = 0;
#endif /* (QDSP_IMAGE_WM_DEFINED) || (QDSP_IMAGE_WM_PRO_DEFINED) */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */

      flush_command[0] = BITSTREAM_FLUSH_CMD_SIZE; /* Length of the command */
      flush_command[1] = BITSTREAM_FLUSH_CMD_HDR;  /* Command header        */
      flush_command[2] = flush_mask;               /* Channels to flush     */

      /* Now send the Bitstream Flush command to the QDSP */
#if defined(FEATURE_ARM_POST_PROCESSING) || defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
      INTLOCK_SAV(isave);
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */
      result = qdsp2_command( flush_command );
#if defined(FEATURE_ARM_POST_PROCESSING) || defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
      /* if we are doing PP now, we will have to flush out all our buffers
      and reinitialize all the PP module's internal variables
      */
      if (qdsp_cmd_arm_pp_cb != NULL)
      {
        qdsp_cmd_pp_reset();
      }
      INTFREE_SAV(isave);
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

      /* Force the DSP to interrupt for data after flush is complete */
      if (result == QDSP_CMD_SUCCESS) {
        qdsp_write(QDSP_adecDataHostStickyInt, 0);
      }
      break;

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
/* This variable should be set to zero during the flush */
      qdsp_cmd_adec_data_buffer_size = 0;
      flush_command[0] = BITSTREAM_FLUSH_CMD_SIZE; /* Length of the command */
      flush_command[1] = BITSTREAM_FLUSH_CMD_HDR;  /* Command header        */
      flush_command[2] = flush_mask;               /* Channels to flush     */

      result = qdsp_adec_command(flush_command);

      /* Force the DSP to interrupt for data after flush is complete */
      if (result == QDSP_CMD_SUCCESS) {
        qdsp_write(QDSP_adecDataHostStickyInt, 0);
      }
      break;
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */

#endif /* FEATURE_QTUNES_COMMON */

#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP) || \
    defined(FEATURE_QSYNTH_ADPCM)
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
      {
        flush_command[0] = BITSTREAM_FLUSH_CMD_SIZE; /* Length of the command */
        flush_command[1] = BITSTREAM_FLUSH_CMD_HDR;  /* Command header        */
        flush_command[2] = flush_mask;               /* Channels to flush     */
      }

#ifdef FEATURE_GASYNTH_INTERFACE
      if (qdsp_cmd_image_select != QDSP_IMAGE_SYNTH
 #ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
      )
#endif /* FEATURE_GASYNTH_INTERFACE */
      {
        /* Now send the Bitstream Flush command to the QDSP */
        result = qdsp2_command( flush_command );
      }
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#if defined(FEATURE_ARM_POST_PROCESSING) || defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
      if (
#ifdef QDSP_IMAGE_SYNTH_DEFINED
         (qdsp_cmd_image_select == QDSP_IMAGE_SYNTH
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
         ) && (qdsp_cmd_arm_pp_cb != NULL))
      {
        INTLOCK_SAV(isave);
      }
#endif /* (FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */
#if defined(FEATURE_ARM_POST_PROCESSING) || defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
      /* if we are doing PP now, we will have to flush out all our buffers
      and reinitialize all the PP module's internal variables
      */
      if (
#ifdef QDSP_IMAGE_SYNTH_DEFINED
          (qdsp_cmd_image_select == QDSP_IMAGE_SYNTH
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
           ) && (qdsp_cmd_arm_pp_cb != NULL))
      {
        qdsp_cmd_pp_reset();
        INTFREE_SAV(isave);
      }
#endif /*(FEATURE_ARM_POST_PROCESSING) || (FEATURE_AVS_WB_PCM_RX_INTERFACE) */

#ifdef FEATURE_QSYNTH_ADPCM
#ifndef FEATURE_GASYNTH_INTERFACE
      current_mode = qdsp_cmd_get_qsynth_adec_mode();
      if ((current_mode == QDSP_CMD_QSYNTH_ADEC_ADPCM)  ||
          (current_mode == QDSP_CMD_QSYNTH_ADEC_YADPCM)
#ifdef FEATURE_QSYNTH_PCM
          || (current_mode == QDSP_CMD_QSYNTH_ADEC_PCM)
#endif /* FEATURE_QSYNTH_PCM */
         )
#endif /* FEATURE_GASYNTH_INTERFACE */
      {
        if(flush_mask & 0x1) {
          qdsp_cmd_qsynth_adpcm_data[0].length = 0;
          qdsp_cmd_qsynth_adpcm_data[0].buffer = NULL;
#ifdef FEATURE_GASYNTH_INTERFACE
          qdsp_cmd_qsynth_adpcm_data[0].length2 = 0;
          qdsp_cmd_qsynth_adpcm_data[0].buffer2 = NULL;
          qdsp_cmd_qsynth_adpcm_data[0].buf_state =
                       QDSP_CMD_ADEC_STATE_BUFFER1;
          MSG_MED("Flush adpcm data adec 0",0,0,0);
#endif /* FEATURE_GASYNTH_INTERFACE */
        }
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
	{
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
        if(flush_mask & 0x2) {
          qdsp_cmd_qsynth_adpcm_data[1].length = 0;
          qdsp_cmd_qsynth_adpcm_data[1].buffer = NULL;
#ifdef FEATURE_GASYNTH_INTERFACE
          qdsp_cmd_qsynth_adpcm_data[1].length2 = 0;
          qdsp_cmd_qsynth_adpcm_data[1].buffer2 = NULL;
          qdsp_cmd_qsynth_adpcm_data[1].buf_state =
                       QDSP_CMD_ADEC_STATE_BUFFER1;
          MSG_MED("Flush adpcm data adec 1",0,0,0);
#endif /* FEATURE_GASYNTH_INTERFACE */
        }

        if(flush_mask & 0x4) {
          qdsp_cmd_qsynth_adpcm_data[2].length = 0;
          qdsp_cmd_qsynth_adpcm_data[2].buffer = NULL;
#ifdef FEATURE_GASYNTH_INTERFACE
          qdsp_cmd_qsynth_adpcm_data[2].length2 = 0;
          qdsp_cmd_qsynth_adpcm_data[2].buffer2 = NULL;
          qdsp_cmd_qsynth_adpcm_data[2].buf_state =
                       QDSP_CMD_ADEC_STATE_BUFFER1;
          MSG_MED("Flush adpcm data adec 2",0,0,0);
#endif /* FEATURE_GASYNTH_INTERFACE */

        }

        if(flush_mask & 0x8) {
          qdsp_cmd_qsynth_adpcm_data[3].length = 0;
          qdsp_cmd_qsynth_adpcm_data[3].buffer = NULL;
#ifdef FEATURE_GASYNTH_INTERFACE
          qdsp_cmd_qsynth_adpcm_data[3].length2 = 0;
          qdsp_cmd_qsynth_adpcm_data[3].buffer2 = NULL;
          qdsp_cmd_qsynth_adpcm_data[3].buf_state =
                       QDSP_CMD_ADEC_STATE_BUFFER1;
          MSG_MED("Flush adpcm data adec 3",0,0,0);
#endif /* FEATURE_GASYNTH_INTERFACE */

        }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
	}

        qdsp_cmd_adec_reset(flush_mask);
      }
#endif /* FEATURE_QSYNTH_ADPCM */
      break;
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP || FEATURE_QSYNTH_ADPCM */

#if defined(FEATURE_VOC_ADPCM) || \
    (defined(FEATURE_WAVE_PB) && defined(FEATURE_VOC_G711))
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif /* QDSP_IMAGE_VOC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif /* QDSP_IMAGE_VOC_EVRC_DEFINED */
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif /* QDSP_IMAGE_VOC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif /* QDSP_IMAGE_VOC_EVRC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_QTV_DEFINED
    case QDSP_IMAGE_VOC_EVRC_QTV:
#endif /* QDSP_IMAGE_VOC_EVRC_QTV_DEFINED */
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_FR_DEFINED */
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_EFR_DEFINED */
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif /* QDSP_IMAGE_AMR_DEFINED */
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif /* QDSP_IMAGE_HR_DEFINED */
#if defined(FEATURE_WAVE_PB) && defined(FEATURE_VOC_G711)
#ifdef QDSP_IMAGE_G711_DEFINED
      case QDSP_IMAGE_G711:
#endif /* QDSP_IMAGE_G711_DEFINED */
#endif /* FEATURE_WAVE_PB && FEATURE_VOC_G711 */
      INTLOCK();
      qdsp_cmd_adpcm_adec_info.buf_ptr        = NULL;
      qdsp_cmd_adpcm_adec_info.buf_length     = 0;
      qdsp_cmd_adpcm_adec_info.buf_index      = 0;
      qdsp_cmd_adpcm_adec_info.tmp_buf_length = 0;
      #ifdef FEATURE_GASYNTH_INTERFACE
      qdsp_cmd_adpcm_adec_info.buf_state      = QDSP_CMD_ADEC_STATE_BUFFER1;
      qdsp_cmd_adpcm_adec_info.free_ptr        = NULL;
      qdsp_cmd_adpcm_adec_info.next_ptr       = NULL;
      qdsp_cmd_adpcm_adec_info.next_length    = 0;
      #endif /* FEATURE_GASYNTH_INTERFACE */
      INTFREE();
      break;
#endif  /* FEATURE_VOC_ADPCM */

    default: /* NO OP */
      break;
  }

  return(result);
}

/* <EJECT> */
#ifdef FEATURE_WEBAUDIO
/*===========================================================================

FUNCTION QDSP_CMD_ADEC_MVOL

DESCRIPTION
  This function sets the adec master volume.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec_mvol (
  uint16 vol
) {
  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
      qdsp_write(QDSP_adecMVolume, vol);
      break;
  }
  return(QDSP_CMD_SUCCESS);
}
#endif /* FEATURE_WEBAUDIO */

/* <EJECT> */

/*===========================================================================

FUNCTION QDSP_CMD_ADEC_CHAN_VOL

DESCRIPTION
  This function sets the audio decoder channel volume setting.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec_chan_vol(
  uint32 channel,
  uint16 vol
)
{
  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
      switch (channel) {
        case 0:
          qdsp_write(QDSP_adecVolume, vol);
          break;
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
		{
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
        case 1:
          qdsp_write(QDSP_adecVolume1, vol);
          break;
        case 2:
          qdsp_write(QDSP_adecVolume2, vol);
          break;
        case 3:
          qdsp_write(QDSP_adecVolume3, vol);
          break;
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
      }
      }
      break;
  }
  return(QDSP_CMD_SUCCESS);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_ADEC_CHAN_PAN

DESCRIPTION
  This function sets the audio decoder channel stereo pan setting.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec_chan_pan (
  uint32 channel,
  sint15 pan
)
{
  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
      if(pan > QDSP_CMD_QSYNTH_ADEC_PAN_MAX) {
        pan = QDSP_CMD_QSYNTH_ADEC_PAN_MAX;
      } else if(pan < QDSP_CMD_QSYNTH_ADEC_PAN_MIN) {
        pan = QDSP_CMD_QSYNTH_ADEC_PAN_MIN;
      }
      switch (channel) {
        case 0:
          qdsp_write(QDSP_adecStereoPan, pan);
          break;
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
      {
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
        case 1:
          qdsp_write(QDSP_adecStereoPan1, pan);
          break;
        case 2:
          qdsp_write(QDSP_adecStereoPan2, pan);
          break;
        case 3:
          qdsp_write(QDSP_adecStereoPan3, pan);
          break;
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
      }
      }
      break;
  }
  return(QDSP_CMD_SUCCESS);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_ADEC_CHAN_START

DESCRIPTION
  This function starts the audio decoder channel.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec_chan_start (
  uint32  channel
) {
  qdsp_cmd_status_type retval = QDSP_CMD_FAILED;
#ifdef FEATURE_GASYNTH_INTERFACE
  word start_command[QDSP_CMD_ADEC_ACTION_BUFF_SIZE];
#endif

  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef FEATURE_GASYNTH_INTERFACE
      start_command[0]         = QDSP_CMD_ADEC_ACTION_BUFF_SIZE;
      start_command[1]         = QDSP_CMD_ADEC_ACTION_CMD_HDR;
      start_command[2]         = 1 << channel;
      start_command[channel+3] = QDSP_CMD_ADEC_ACTION_ACTIVE;
      retval = qdsp_cmd_qsynth_adec_cmd(start_command, channel);
      break;
#endif
#endif /* QDSP_IMAGE_SYNTH_DEFINED) ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */

    default:
      break;
  }
  return(retval);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_ADEC_CHAN_PAUSE

DESCRIPTION
  This function sets the audio decoder channel stereo pause flag.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec_chan_pause (
  uint32  channel,
  boolean pause_flag
) {
  qdsp_cmd_status_type retval = QDSP_CMD_SUCCESS;
#ifdef FEATURE_GASYNTH_INTERFACE
  word pause_command[QDSP_CMD_ADEC_ACTION_BUFF_SIZE];
#endif /* FEATURE_GASYNTH_INTERFACE */

  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef FEATURE_GASYNTH_INTERFACE
      pause_command[0] = QDSP_CMD_ADEC_ACTION_BUFF_SIZE;
      pause_command[1] = QDSP_CMD_ADEC_ACTION_CMD_HDR;
      pause_command[2] = 1 << channel;
      if (pause_flag == TRUE) {
        pause_command[channel+3] = QDSP_CMD_ADEC_ACTION_PAUSE;
      } else {
        pause_command[channel+3] = QDSP_CMD_ADEC_ACTION_RESUME;
      }
      retval = qdsp_cmd_qsynth_adec_cmd(pause_command, channel);
#else
#ifdef MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT
      qdsp_write_offset(QDSP_adecPause, channel, (uint16) pause_flag);
#else
      qdsp_write(QDSP_audioPause, (uint16) pause_flag);
#endif /* MSMAUD_QSYNTH_HYBRID_MODE_SUPPORT */
#endif /* FEATURE_GASYNTH_INTERFACE */
      break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#if defined(FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
      qdsp_cmd_pp_pause = pause_flag;
#endif
    default:
      break;
  }
  return(retval);
}


/* <EJECT> */
#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP) || \
    defined(FEATURE_QSYNTH_ADPCM)
/*===========================================================================

FUNCTION QDSP_CMD_ADEC_RESET

DESCRIPTION
  This function resets the audio decoder.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_adec_reset( uint32 reset_mask )
{
#ifdef FEATURE_GASYNTH_INTERFACE
  word reset_command[QDSP_CMD_ADEC_ACTION_BUFF_SIZE];

  switch(qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
    reset_command[0] = QDSP_CMD_ADEC_ACTION_BUFF_SIZE;
    reset_command[1] = QDSP_CMD_ADEC_ACTION_CMD_HDR;
    reset_command[2] = (word) reset_mask & 0x000F;
    if(reset_mask & 0x1) {
      reset_command[3] = QDSP_CMD_ADEC_ACTION_RESET;
    }
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
{
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
    if(reset_mask & 0x2) {
      reset_command[4] = QDSP_CMD_ADEC_ACTION_RESET;
    }
    if(reset_mask & 0x4) {
      reset_command[5] = QDSP_CMD_ADEC_ACTION_RESET;
    }
    if(reset_mask & 0x8) {
      reset_command[6] = QDSP_CMD_ADEC_ACTION_RESET;
    }
    qdsp_cmd_qsynth_adec_cmd(reset_command, reset_mask);
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
  	}
      break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
    default:
      break;
  }
#else /* FEATURE_GASYNTH_INTERFACE */
  switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif
#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
      if(reset_mask & 0x1) {
        qdsp_write(QDSP_adecReset, 0xffff);
      }
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
{
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
      if(reset_mask & 0x2) {
        qdsp_write(QDSP_adecReset1, 0xffff);
      }
      if(reset_mask & 0x4) {
        qdsp_write(QDSP_adecReset2, 0xffff);
      }
      if(reset_mask & 0x8) {
        qdsp_write(QDSP_adecReset3, 0xffff);
      }
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
  	}
      break;
  }
#endif /* FEATURE_GASYNTH_INTERFACE */
}
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP || FEATURE_QSYNTH_ADPCM */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_adec_pcm_stopped

DESCRIPTION
  This function checks if PCM output has stopped.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if PCM output has stopped.

SIDE EFFECTS
  None.

===========================================================================*/
boolean qdsp_cmd_adec_pcm_stopped()
{
#ifdef FEATURE_QTUNES_COMMON
  switch(qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#ifdef FEATURE_QTUNES
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
      return(qdsp_read(QDSP_pcmDmaMissed) != 0);

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */

       if ((qdsp_cmd_adec_int_cb_ptr  != NULL) &&
#ifdef FEATURE_AVS_INCALL_ADEC_PB
           (qdsp_cmd_get_state()      == QDSP_STATE_ADEC_VOC) &&
#endif /* FEATURE_AVS_INCALL_ADEC_PB */
           (qdsp_cmd_get_adec_state() == QDSP_STATE_TUNES)) {
         return(qdsp_read(QDSP_pcmDmaMissed) != 0);
       }
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */
#endif /* FEATURE_QTUNES */

#ifdef FEATURE_QTUNES_AAC
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED*/
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
      return( (qdsp_read(QDSP_pcmDmaMissed) != 0) &&
              (qdsp_read(QDSP_adecErrorReg) & QDSP_ADEC_AAC_DATA_UNDERFLOW_M) );
#endif /* FEATURE_QTUNES_AAC */

#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
      return( (qdsp_read(QDSP_pcmDmaMissed) != 0) &&
              (qdsp_read(QDSP_adecErrorReg) & QDSP_ADEC_RA_DATA_UNDERFLOW_M) );
#endif /* QDSP_IMAGE_RA_DEFINED */

#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
      return(qdsp_read(QDSP_pcmDmaMissed) != 0);


#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
      return( (qdsp_read(QDSP_pcmDmaMissed) != 0) &&
              (qdsp_read(QDSP_adecErrorReg) & QDSP_ADEC_AMR_WBP_DATA_UNDERFLOW_M) );
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */

    default:
      break;
  }
#endif /* FEATURE_QTUNES_COMMON */
  return(TRUE);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_adec_error

DESCRIPTION
  This function returns (and clears) any ADEC errors pending.

DEPENDENCIES
  None.

RETURN VALUE
  The value of the error register is returned.

SIDE EFFECTS
  None.

===========================================================================*/
uint16 qdsp_cmd_adec_error(
  boolean clear
)
{
  uint16 error_reg = 0;

#ifdef FEATURE_QTUNES_COMMON
  uint16 mask;

  switch (qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#ifdef FEATURE_QTUNES
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef FEATURE_AVS_INCALL_ADEC_PB
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#endif /* FEATURE_AVS_INCALL_ADEC_PB */
#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB */
      mask = QDSP_ADEC_MP3_ERROR_M;
      break;
#endif /* FEATURE_QTUNES */

#ifdef FEATURE_QTUNES_AAC
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED*/
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
      mask = QDSP_ADEC_AAC_ERROR_M;
      break;
#endif /* FEATURE_QTUNES_AAC */

#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
      mask = QDSP_ADEC_RA_ERROR_M;
      break;
#endif /* QDSP_IMAGE_RA_DEFINED */
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
      /* mask = QDSP_ADEC_WM_ERROR_M; */
      mask = 0; /* Feature not yet supported by firmware */
      break;
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
      mask = QDSP_ADEC_AMR_WBP_ERROR_M;
      break;
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */

    default:
      return(error_reg);
  }

  error_reg = qdsp_read(QDSP_adecErrorReg) & mask;
  if(clear) {
    qdsp_write(QDSP_adecErrorReg, 0);
  }
#endif /* FEATURE_QTUNES_COMMON */
  return(error_reg);
}

/* <EJECT> */
#if defined(FEATURE_QTUNES) || defined(FEATURE_QTUNES_AAC)
/*===========================================================================

FUNCTION qdsp_cmd_mpeg_target_header

DESCRIPTION
  This function updates the value of the target header and mask in QTUNES
  for MP3 and AAC songs

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_mpeg_target_header(
  const uint8 *mask,
  const uint8 *header,
  const uint8 mask_size    /* size in even number of bytes */
)
{
  switch(qdsp_cmd_image_select) {
#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED*/
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif

      qdsp_block_write(QDSP_targetHeader, 0, (uint16*)header,
                       mask_size/2, TRUE);
      qdsp_block_write(QDSP_targetHeaderMask,0, (uint16*)mask,
                       mask_size/2, TRUE);
      break;
  }
}
#endif /* defined(FEATURE_QTUNES) || defined(FEATURE_QTUNES_AAC) */

/* <EJECT> */
#ifdef FEATURE_QTUNES_AAC
#ifdef FEATURE_AAC_PLUS
/*===========================================================================

FUNCTION qdsp_cmd_set_aac_plus_on_flag

DESCRIPTION
  This function setup AAC Plus on/off flag to enable/disable the AAC Plus SBR
  module.
  Note: The DSP will take in the value in the next call to
        qdsp_cmd_set_aac_config.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_set_aac_plus_on_flag
(
  boolean on
)
{
  if (on == TRUE) {
    qdsp_cmd_aac_plus_on_flag = QDSP_CMD_AAC_PLUS_ON_VAL;
  } else {
    qdsp_cmd_aac_plus_on_flag = QDSP_CMD_AAC_PLUS_OFF_VAL;
  }
}

#ifdef FEATURE_ENHANCED_AAC_PLUS
/*===========================================================================

FUNCTION qdsp_cmd_set_enhanced_aac_plus_on_flag

DESCRIPTION
  This function setup Enhanced AAC Plus on/off flag to enable/disable the AAC
  Plus SBR module.
  Note: The DSP will take in the value in the next call to
        qdsp_cmd_set_aac_config.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_set_enhanced_aac_plus_on_flag
(
  boolean on
)
{
  if (on == TRUE) {
    qdsp_cmd_enhanced_aac_plus_on_flag =
        QDSP_CMD_ENHANCED_AAC_PLUS_ON_VAL;
  } else {
    qdsp_cmd_enhanced_aac_plus_on_flag =
        QDSP_CMD_ENHANCED_AAC_PLUS_OFF_VAL;
  }
}
#endif /* FEATURE_ENHANCED_AAC_PLUS */
#endif /* FEATURE_AAC_PLUS */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_set_aac_config

DESCRIPTION
  Sets up AAC specific DSP configuration parameters

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_set_aac_config(
  const qdsp_cmd_aac_config_type *config
)
{
  /* Byte threshold for the DSP to issue a data request */
  /* qdsp_write(QDSP_adecDataMinDLSize, config->buffer_factor); */
  /* Hard coded for now */
  qdsp_write(QDSP_adecDataMinDLSize, 50);

  qdsp_write(QDSP_aacFormatFlag,
             qdsp_cmd_aac_data_format_values[config->aac_format]);

  if(config->sample_freq_index == 0) {
  /* As the value for zero corresponds to 96KHZ in firmware and as this is  */
  /* not supported by DSP to avoid the playback issues configuring it to 0xb*/
    qdsp_write(QDSP_adtsSamplingFrequency, 0xb);
  } else {
    qdsp_write(QDSP_adtsSamplingFrequency, config->sample_freq_index);
  }
MSG_MED(" AAC config params",0,0,0);
MSG_MED(" AAC Sample rate->%d",config->sample_freq_index,0,0);

#if defined(QDSP_IMAGE_AAC_DEFINED)             || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED)    || \
    defined(QDSP_IMAGE_H264D_AAC_DEFINED)       || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)    || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED)   || \
    defined(QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)
  switch(qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_AAC_DEFINED)             || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED)    || \
    defined(QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED)   || \
    defined(QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)    || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
      qdsp_write(QDSP_audioObjectType,       config->audio_object);
      qdsp_write(QDSP_channelConfiguration,  config->channel_configuration);
      qdsp_write(QDSP_epConfig,              config->ep_config);

      qdsp_write(QDSP_aacSectionDataResilienceFlag,
                 config->aac_section_data_resilience_flag);

      qdsp_write(QDSP_aacScalefactorDataResilienceFlag,
                 config->aac_scalefactor_data_resilience_flag);

      qdsp_write(QDSP_aacSpectralDataResilienceFlag,
                 config->aac_spectral_data_resilience_flag);
MSG_MED("AAC channel config->%d,AAC audio object->%d",
                config->channel_configuration,config->audio_object,0);

#if (((defined(QDSP_IMAGE_QTV_AAC_DEFINED))||(defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED))|| \
     (defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED))|| \
     (defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED))) && defined(QDSP_aacConcealFlag))
    if((qdsp_cmd_image_select == QDSP_IMAGE_QTV_AAC)
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
       ||(qdsp_cmd_image_select == QDSP_IMAGE_VOC_COMBO_ICA)
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
	   ) {
      #if defined(QDSP_IMAGE_QTV_AAC_DEFINED) && defined(QDSP_aacConcealFlag)
      qdsp_write(QDSP_aacConcealFlag, qdsp_cmd_enable_err_concealment);
      MSG_MED(" AAC err_concealment->%d",qdsp_cmd_enable_err_concealment,0,0);
      #endif /* QDSP_IMAGE_QTV_AAC_DEFINED && QDSP_aacConcealFlag */	  
      }
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED || QDSP_IMAGE_VOC_COMBO_ICA_DEFINED && QDSP_aacConcealFlag */

#endif /* QDSP_IMAGE_AAC_DEFINED             ||
          QDSP_IMAGE_ENH_AAC_PLUS_DEFINED    ||
          QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED   ||
          QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED ||
          QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */

#ifdef FEATURE_AAC_PLUS
      qdsp_write(QDSP_sbrOnFlag, qdsp_cmd_aac_plus_on_flag);
      MSG_MED(" aac_plus_on_flag->%d",qdsp_cmd_aac_plus_on_flag,0,0);
#ifdef FEATURE_ENHANCED_AAC_PLUS
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
      if (qdsp_cmd_image_select == QDSP_IMAGE_ENH_AAC_PLUS) {
        qdsp_write(QDSP_sbrPsOnFlag, qdsp_cmd_enhanced_aac_plus_on_flag);
        MSG_MED("enhanced_aac_plus_on_flag->%d",qdsp_cmd_enhanced_aac_plus_on_flag,0,0);
      }
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
      if (qdsp_cmd_image_select == QDSP_IMAGE_VOC_COMBO_ICA) {
        qdsp_write(QDSP_sbrPsOnFlag, qdsp_cmd_enhanced_aac_plus_on_flag);
      }
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */

#if ((defined QDSP_IMAGE_QTV_AAC_DEFINED)||(defined QDSP_IMAGE_QTV_AAC_H264_DEFINED)|| \
     (defined QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED)||(defined QDSP_IMAGE_VOC_COMBO_ICA_DEFINED))
    if ((qdsp_cmd_image_select == QDSP_IMAGE_QTV_AAC)
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
        ||(qdsp_cmd_image_select == QDSP_IMAGE_VOC_COMBO_ICA)
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif

		) {
       qdsp_write(QDSP_sbrPsOnFlag, qdsp_cmd_enhanced_aac_plus_on_flag);
      }
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED || QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
#endif /* FEATURE_ENHANCED_AAC_PLUS */
#endif /* FEATURE_AAC_PLUS */

      /* Double the frame size for sample rate is greater than 24KHz.
      */
      if (config->sample_freq_index < 6) {
        qdsp_write(QDSP_adecFrameSize, 1024);
      } else {
        qdsp_write(QDSP_adecFrameSize, 2048);
      }
      break;

    default:
      break;
  }
#endif /* QDSP_IMAGE_AAC_DEFINED             ||
          QDSP_IMAGE_ENH_AAC_PLUS_DEFINED    ||
          QDSP_IMAGE_H264D_AAC_DEFINED       ||
          QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED   ||
          QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED ||
          QDSP_IMAGE_QTV_AAC_DEFINED */
}
#endif /* FEATURE_QTUNES_AAC */

/* <EJECT> */
#ifdef FEATURE_QTUNES
/*===========================================================================

FUNCTION qdsp_cmd_set_mp3_config

DESCRIPTION
  Sets up mp3 specific DSP configuration parameters

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_set_mp3_config(
  const qdsp_cmd_mp3_config_type *config
)
{
#ifdef FEATURE_QTUNES_COMMON
#if defined(QDSP_mp3SamplingRate)
  MSG_HIGH("MP3 config:- sample freq = %d",config->sample_freq,0,0);
  qdsp_write(QDSP_mp3SamplingRate, config->sample_freq);
#endif/*QDSP_mp3SamplingRate*/
#endif/*FEATURE_QTUNES_COMMON*/
}
#endif /* FEATURE_QTUNES */

/* <EJECT> */
#ifdef FEATURE_REAL_AUDIO
/*===========================================================================

FUNCTION qdsp_cmd_set_ra_song_config

DESCRIPTION
  Set configuration params for RealAudio song playback.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the value configuration could be set
  FALSE if the RealAudio image was not available

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_set_ra_song_config(
  const qdsp_cmd_ra_dsp_config_type *ra_config
)
{
#ifdef QDSP_IMAGE_RA_DEFINED
  qdsp_write(QDSP_adecDataMinDLSize, QDSP_QTUNES_RA_BUF_WATERMARK);
  qdsp_write(QDSP_armGeckoMode, ra_config->decoder_mode);
  qdsp_write(QDSP_armNSamples,  ra_config->samples_per_frame);
  qdsp_write(QDSP_armNChannels, ra_config->num_channels);
  qdsp_write(QDSP_armNRegions,  ra_config->num_regions);
  qdsp_write(QDSP_armFrameBits, ra_config->bits_per_frame);
  qdsp_write(QDSP_armSampRate,
             qdsp_cmd_sample_rate_values[ra_config->sample_rate]);
  qdsp_write(QDSP_armCplStart,  ra_config->coupling_start);
  qdsp_write(QDSP_armCplQBits,  ra_config->coupling_quant);
  qdsp_write(QDSP_armLostFlag,  ra_config->frame_erasure);
#endif /* QDSP_IMAGE_RA_DEFINED */
}
#endif /* FEATURE_REAL_AUDIO */

#ifdef FEATURE_WMA

/*===========================================================================

FUNCTION qdsp_cmd_get_sample_rate_value

DESCRIPTION


DEPENDENCIES
  None.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
uint16 qdsp_cmd_get_sample_rate_value(uint16 sample_rate_index)
{
  /*return the sample rate value based on the index*/
  return qdsp_cmd_sample_rate_values[sample_rate_index];
}

/*===========================================================================

FUNCTION qdsp_cmd_adec_config_cmd

DESCRIPTION
  Set adec configuration params in DSP for WindowsMediaAudio song playback.

DEPENDENCIES
  None.

RETURN VALUE
  Success if the value configuration could be set
  Failure if the WindowsMedia Audio image was not available

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_adec_config_cmd(
  const qdsp_cmd_adec_config_type *adec_config
)
{
#if defined(QDSP_IMAGE_WM_DEFINED) || defined(QDSP_IMAGE_WM_PRO_DEFINED)|| \
	 defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED)

  /*alterd size for wm/wmapro*/
  uint16 command[ADEC_CONFIG_CMD_WM_PRO_SIZE];
  int16 data_thr;

  if((qdsp_cmd_image_select == QDSP_IMAGE_WM)
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    || (qdsp_cmd_image_select == QDSP_IMAGE_VOC_COMBO_ICA)
#endif
    ) {
    command[0] = ADEC_CONFIG_CMD_SIZE;
    command[1] = ADEC_CONFIG_CMD_HDR;
    command[2] = (((adec_config->adec_type & 0xF) << 12) |
                  ((adec_config->subcommand & 0xF) << 8) |
                  (adec_config->command_length & 0xFF));
    command[3] = (((adec_config->version & 0xFF) << 8) |
                  (adec_config->channels & 0xFF));
    command[4] = adec_config->bytes_per_second;
    command[5] = qdsp_cmd_sample_rate_values[adec_config->sample_rate];
    command[6] = adec_config->encoder_options;
  }
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif

  if((qdsp_cmd_image_select == QDSP_IMAGE_WM)
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    || (qdsp_cmd_image_select == QDSP_IMAGE_VOC_COMBO_ICA)
#endif
    ) {

    data_thr   = QDSP_CMD_WMA_DATA_THR_MAX -
        (adec_config->virtual_pkt_len / 2) - QDSP_CMD_WMA_DATA_THR_OFFSET;

    if (data_thr < QDSP_CMD_WMA_DATA_REQUEST_THRESHOLD) {
      data_thr = QDSP_CMD_WMA_DATA_REQUEST_THRESHOLD;
    }

    /* Make sure it is in even bytes */
    qdsp_cmd_adec_data_buffer_threshold = (adec_config->virtual_pkt_len +
                                         (adec_config->virtual_pkt_len & 0x01));

    if (qdsp_cmd_adec_data_buffer_threshold >
        QDSP_CMD_ADEC_PRE_ALLOC_BUFFER_SIZE) {
      qdsp_cmd_adec_data_buffer_threshold =
          QDSP_CMD_ADEC_PRE_ALLOC_BUFFER_SIZE;
    }

    qdsp_write (QDSP_armDataReqThr, data_thr);

    if((qdsp_cmd_image_select == QDSP_IMAGE_WM)
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif
  ) {
      return qdsp2_command(command);
    }
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    else if (qdsp_cmd_image_select == QDSP_IMAGE_VOC_COMBO_ICA) {
      return qdsp_adec_command(command);
    }
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
  }
#endif /* QDSP_IMAGE_WM_DEFINED || QDSP_IMAGE_WM_PRO_DEFINED || QDSP_IMAGE_VOC_COMBO_ICA_DEFINED*/
  return (QDSP_CMD_SUCCESS);
}
#endif /* FEATURE_WMA */

/* <EJECT> */
#if defined(FEATURE_AMR_WBPLUS_AUDIO_DEC) && \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)
/*===========================================================================

FUNCTION qdsp_cmd_set_amr_wbp_config

DESCRIPTION
  Sets up AMR-WB+ specific DSP configuration parameters.

DEPENDENCIES
  qdsp_cmd_sample_rate_values

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_set_amr_wbp_config(
  const qdsp_cmd_amr_wbp_config_type *config
)
{
  qdsp_write(QDSP_adecDataMinDLSize, QDSP_ADEC_AMR_WBP_MIN_THRESHOLD);
  qdsp_write(QDSP_amrwbpConfigSamplingRate, config->sample_rate);
  qdsp_write(QDSP_amrwbpMonoDecStereo, config->dec_chan_mode);
}
#endif /* FEATURE_AMR_WBPLUS_AUDIO_DEC && QDSP_IMAGE_QTV_CONC_DEFINED */

#endif /* FEATURE_ADEC */

/* <EJECT> */
#ifdef FEATURE_QAUDIOFX
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_add_env_q

DESCRIPTION
  Adds the indicated command to the indicated environment command queue.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_add_env_q (
  uint16 *cmd_buf,
  uint16 cmd_size
) {
  qdsp_cmd_status_type       ret_val = QDSP_CMD_FAILED;
  qdsp_cmd_3d_pos_cmd_q_type *p_cmd_q;
  uint16                     num_words, size, num_commands = 0;
  uint16                     *cmd_array, *src;

  if((cmd_buf != NULL) && ((cmd_buf[0] == QDSP_CMD_3D_POS_ENABLE_CMD) ||
                           (cmd_buf[0] == QDSP_CMD_3D_POS_LSNR_POS_CMD) ||
                           (cmd_buf[0] == QDSP_CMD_3D_POS_LSNR_ORIENT_CMD) ||
                           (cmd_buf[0] == QDSP_CMD_3D_POS_LSNR_VEL_CMD) ||
                           (cmd_buf[0] == QDSP_CMD_3D_REVERB_CMD) ||
                           (cmd_buf[0] == QDSP_CMD_3D_REVERB_DISABLE_CMD) ||
                           (cmd_buf[0] == QDSP_CMD_3D_POS_OUTPUT_MODE_CMD) ||
                           (cmd_buf[0] == QDSP_CMD_3D_POS_ENV_RESET_CMD))) {
    INTLOCK();
    p_cmd_q   = &qdsp_cmd_3d_pos_lsnr_cmd_q.cmd_q
                                   [qdsp_cmd_3d_pos_lsnr_cmd_q.current_index];
    num_words = p_cmd_q->index;
    cmd_array = p_cmd_q->cmd_buf;

    while(num_words != 0) {
      if(*cmd_array == *cmd_buf) {
        if(num_words >= cmd_size) {
          p_cmd_q->index -= cmd_size;
          num_words      -= cmd_size;
          src             = cmd_array + cmd_size;
          while(num_words != 0) {
            *cmd_array = *src;
            cmd_array++;
            src++;
            num_words--;
          }
          p_cmd_q->num_commands--;
        } else {
          p_cmd_q->num_commands  = num_commands;
          p_cmd_q->index        -= num_words;
          num_words              = 0;
        }
      } else {
        switch (*cmd_array) {
          case QDSP_CMD_3D_POS_ENABLE_CMD:
            size = QDSP_CMD_3D_POS_ENABLE_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_LSNR_POS_CMD:
            size = QDSP_CMD_3D_POS_LSNR_POS_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_LSNR_ORIENT_CMD:
            size = QDSP_CMD_3D_POS_LSNR_ORIENT_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_LSNR_VEL_CMD:
             size = QDSP_CMD_3D_POS_LSNR_VEL_CMD_SIZE;
            break;

          case QDSP_CMD_3D_REVERB_CMD:
            size = QDSP_CMD_3D_REVERB_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_OUTPUT_MODE_CMD:
            size = QDSP_CMD_3D_POS_OUTPUT_MODE_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_ENV_RESET_CMD:
            size = QDSP_CMD_3D_POS_ENV_RESET_CMD_SIZE;
            break;

          default:
            size = num_words + 1;
            break;
        }

        if(num_words >= size) {
          num_words -= size;
          cmd_array += size;
          num_commands++;
        } else {
          p_cmd_q->num_commands  = num_commands;
          p_cmd_q->index        -= num_words;
          num_words              = 0;
        }
      }
    }

    if((cmd_size + p_cmd_q->index) <= QDSP_CMD_3D_POS_QUEUE_SIZE) {
      while(cmd_size--) {
        p_cmd_q->cmd_buf[p_cmd_q->index++] = *cmd_buf++;
      }
      p_cmd_q->num_commands++;
      qdsp_cmd_3d_pos_send_cmd(QDSP_CMD_3D_POS_CMD_Q_ENV,
                               &qdsp_cmd_3d_pos_lsnr_cmd_q);
      MSG_MED(" Set 3d positional Environment commands ", 0,0,0);
      ret_val = QDSP_CMD_SUCCESS;
    }
    INTFREE();
   } else {
   MSG_ERROR(" Invalid 3d positional Environment commands " , 0,0,0 );
  }
  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_add_src_q

DESCRIPTION
  Adds the indicated command to the indicated source command queue.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_add_src_q (
  uint32 src_num,
  uint16 *cmd_buf,
  uint16 cmd_size
) {
  qdsp_cmd_status_type            ret_val = QDSP_CMD_FAILED;
  qdsp_cmd_3d_pos_cmd_struct_type *p_cmd_struct;
  qdsp_cmd_3d_pos_cmd_q_type      *p_cmd_q;
  uint16                          num_words, size, num_commands = 0;
  uint16                          *cmd_array, *src;

  if((cmd_buf != NULL) && (src_num < 4) &&
     ((cmd_buf[0] == QDSP_CMD_3D_POS_SRC_ENABLE_CMD) ||
      (cmd_buf[0] == QDSP_CMD_3D_POS_SRC_RESET_CMD) ||
      (cmd_buf[0] == QDSP_CMD_3D_POS_SRC_VOLUME_CMD) ||
      (cmd_buf[0] == QDSP_CMD_3D_POS_SRC_VOL_ATTEN_CMD) ||
      (cmd_buf[0] == QDSP_CMD_3D_POS_SRC_POS_CMD) ||
      (cmd_buf[0] == QDSP_CMD_3D_POS_SRC_VEL_CMD) ||
      (cmd_buf[0] == QDSP_CMD_3D_REVERB_SRC_VOL_CMD))) {
    INTLOCK();
    p_cmd_struct = &qdsp_cmd_3d_pos_src_cmd_q[src_num];
    p_cmd_q      = &p_cmd_struct->cmd_q[p_cmd_struct->current_index];

    num_words = p_cmd_q->index;
    cmd_array = p_cmd_q->cmd_buf;

    while(num_words != 0) {
      if(*cmd_array == *cmd_buf) {
        if(num_words >= cmd_size) {
          p_cmd_q->index -= cmd_size;
          num_words      -= cmd_size;
          src             = cmd_array + cmd_size;
          while(num_words != 0) {
            *cmd_array = *src;
            cmd_array++;
            src++;
            num_words--;
          }
          p_cmd_q->num_commands--;
        } else {
          p_cmd_q->num_commands  = num_commands;
          p_cmd_q->index        -= num_words;
          num_words              = 0;
        }
      } else {
        switch (*cmd_array) {

          case QDSP_CMD_3D_POS_SRC_ENABLE_CMD:
            size = QDSP_CMD_3D_POS_SRC_ENABLE_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_SRC_RESET_CMD:
            size = QDSP_CMD_3D_POS_SRC_RESET_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_SRC_VOLUME_CMD:
            size = QDSP_CMD_3D_POS_SRC_VOLUME_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_SRC_VOL_ATTEN_CMD:
            size = QDSP_CMD_3D_POS_SRC_VOL_ATTEN_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_SRC_POS_CMD:
            size = QDSP_CMD_3D_POS_SRC_POS_CMD_SIZE;
            break;

          case QDSP_CMD_3D_POS_SRC_VEL_CMD:
            size = QDSP_CMD_3D_POS_SRC_VEL_CMD_SIZE;
            break;

          default:
            size = num_words + 1;
            break;
        }
        if(num_words >= size) {
          num_words -= size;
          cmd_array += size;
          num_commands++;
        } else {
          p_cmd_q->num_commands  = num_commands;
          p_cmd_q->index        -= num_words;
          num_words              = 0;
        }
      }
    }

    if((cmd_size + p_cmd_q->index) <= QDSP_CMD_3D_POS_QUEUE_SIZE) {
      while(cmd_size--) {
        p_cmd_q->cmd_buf[p_cmd_q->index++] = *cmd_buf++;
      }
      p_cmd_q->num_commands++;
      qdsp_cmd_3d_pos_send_cmd((qdsp_cmd_3d_pos_cmd_q_enum_type)
                                      (src_num + QDSP_CMD_3D_POS_CMD_Q_SRC0),
                               p_cmd_struct);
      MSG_ERROR("Set 3d Source Positon commands " , 0,0,0);
      ret_val = QDSP_CMD_SUCCESS;
    }
    INTFREE();
  } else {
  MSG_ERROR("Invalid 3d Source position commands " , 0,0,0);
  }
  return(ret_val);
}

/* <EJECT> */

/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_enable
DESCRIPTION
  This function enable/disable 3D environment.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_enable (
  qdsp_cmd_3d_pos_mode_enum_type mode
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint16               command[2];

  if (qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {
    command[0] = QDSP_CMD_3D_POS_ENABLE_CMD;
    if (mode == QDSP_CMD_3D_POS_MODE_DISABLE) {
      command[1] = 0x0000;
      MSG_MED(" Disable 3d environment",0,0,0 );
      ret_val = qdsp_cmd_3d_pos_add_env_q(command, QDSP_CMD_3D_POS_ENABLE_CMD_SIZE);
    } else if (mode == QDSP_CMD_3D_POS_MODE_ENABLE) {
      command[1] = 0xFFFF;
      MSG_MED(" Enable 3d environment",0,0,0 );
      ret_val = qdsp_cmd_3d_pos_add_env_q(command, QDSP_CMD_3D_POS_ENABLE_CMD_SIZE);
    } else {
      MSG_ERROR("Invalid 3D enable mode", 0, 0, 0);
    }
  }

  return ret_val;
}

/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_assign_query_buffs

DESCRIPTION
  Assign 3D query buffers

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_3d_pos_assign_query_buffs() {

  qdsp_write(QDSP_adecPPStateExtPtr1, (uint32) qdsp_cmd_3d_pos_query_buffer1);
  qdsp_write(QDSP_adecPPStateExtPtr2, (uint32) qdsp_cmd_3d_pos_query_buffer2);
}

/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_reset_env

DESCRIPTION
  Resets 3D environment.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_reset_env () {
  uint16 command[1];

  if(qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {
    command[0] = QDSP_CMD_3D_POS_ENV_RESET_CMD;
    MSG_MED("Reset 3d Environment ",0,0,0 );
    return(qdsp_cmd_3d_pos_add_env_q(command,
                                     QDSP_CMD_3D_POS_ENV_RESET_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0 );
    return(QDSP_CMD_FAILED);
  }
}
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_set_output_mode

DESCRIPTION
  Sets the 3D positional output mode.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_set_output_mode (
  qdsp_cmd_3d_pos_output_mode_enum_type output_mode
) {
  uint16 command[3];

     MSG_MED(" Attempt to set 3d output mode ",0,0,0 );
  if(qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {
    command[0] = QDSP_CMD_3D_POS_OUTPUT_MODE_CMD;

    switch(output_mode) {
      case QDSP_CMD_3D_POS_OUTPUT_MODE_HEADPHONE:
	MSG_MED( "Output_mode_Headphone ",0,0,0 );
        command[1] = 0xffff;
        break;

      case QDSP_CMD_3D_POS_OUTPUT_MODE_SPEAKER_FRONT:
	MSG_MED(" Output_mode_Speaker_Front ",0,0,0 );
        command[1] = 0;
        break;

      case QDSP_CMD_3D_POS_OUTPUT_MODE_SPEAKER_SIDE:
	MSG_MED(" Output_mode_Speaker_Side ",0,0,0 );
        command[1] = 1;
        break;

      case QDSP_CMD_3D_POS_OUTPUT_MODE_SPEAKER_DESK:
	MSG_MED(" Output_mode_Speaker_Desk ",0,0,0 );
        command[1] = 2;
        break;

      default:
        MSG_ERROR(" Invalid Output Mode ",0,0,0 );
        return(QDSP_CMD_FAILED);
        break;
    }
    command[2] = 0;

    return(qdsp_cmd_3d_pos_add_env_q(command, QDSP_CMD_3D_POS_OUTPUT_MODE_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0 );
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_set_lsnr_pos

DESCRIPTION
  Sets the 3D positional listener position.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_set_lsnr_pos (
  qdsp_cmd_3d_pos_coord_type *coord,
  uint32                     duration_ms
) {
  uint16 command[9];

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (coord != NULL)) {
    command[0] = QDSP_CMD_3D_POS_LSNR_POS_CMD;
    command[1] = (coord->x_coord >> 16) & 0xffff;
    command[2] = coord->x_coord & 0xffff;
    command[3] = (coord->y_coord >> 16) & 0xffff;
    command[4] = coord->y_coord & 0xffff;
    command[5] = (coord->z_coord >> 16) & 0xffff;
    command[6] = coord->z_coord & 0xffff;

    duration_ms = duration_ms * QDSP_CMD_3D_POS_NATIVE_SAMPLING_RATE_INDEX;

    command[7] = (duration_ms >> 16) & 0xffff;
    command[8] = duration_ms & 0xffff;
    MSG_MED("3d Listener position X = %ld ,Y = %ld,Z = %ld ",
		coord->x_coord,coord->y_coord,coord->z_coord );

    return(qdsp_cmd_3d_pos_add_env_q(command,
                                     QDSP_CMD_3D_POS_LSNR_POS_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0 );
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_set_lsnr_orient

DESCRIPTION
  Sets the 3D positional listener orientation.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_set_lsnr_orient (
  qdsp_cmd_3d_pos_orient_type *orient,
  uint32                      duration_ms
) {
  uint16 command[15];

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (orient != NULL)) {
    command[0]  = QDSP_CMD_3D_POS_LSNR_ORIENT_CMD;
    command[1]  = (orient->forward.x_coord >> 16) & 0xffff;
    command[2]  = orient->forward.x_coord & 0xffff;
    command[3]  = (orient->forward.y_coord >> 16) & 0xffff;
    command[4]  = orient->forward.y_coord & 0xffff;
    command[5]  = (orient->forward.z_coord >> 16) & 0xffff;
    command[6]  = orient->forward.z_coord & 0xffff;
    command[7]  = (orient->up.x_coord >> 16) & 0xffff;
    command[8]  = orient->up.x_coord & 0xffff;
    command[9]  = (orient->up.y_coord >> 16) & 0xffff;
    command[10] = orient->up.y_coord & 0xffff;
    command[11] = (orient->up.z_coord >> 16) & 0xffff;
    command[12] = orient->up.z_coord & 0xffff;

    duration_ms = duration_ms * QDSP_CMD_3D_POS_NATIVE_SAMPLING_RATE_INDEX;

    command[13] = (duration_ms >> 16) & 0xffff;
    command[14] = duration_ms & 0xffff;
    MSG_MED("3d Listener Orientation forward X = %ld ,Y = %ld,Z = %ld \n ",
      orient->forward.x_coord,orient->forward.y_coord,orient->forward.z_coord);
    MSG_MED("3d Listener Orientation up  X = %ld ,Y = %ld,Z = %ld ",
	          orient->up.x_coord ,orient->up.y_coord ,orient->up.z_coord);

    return(qdsp_cmd_3d_pos_add_env_q(command,
                                     QDSP_CMD_3D_POS_LSNR_ORIENT_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0);
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================
FUNCTION qdsp_cmd_3d_pos_set_lsnr_vel

DESCRIPTION
  Sets the 3D positional listener position.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_set_lsnr_vel (
  qdsp_cmd_3d_pos_coord_type *coord,
  uint32                     duration_ms
) {
  uint16 command[9];

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (coord != NULL)) {
    command[0] = QDSP_CMD_3D_POS_LSNR_VEL_CMD;
    command[1] = (coord->x_coord >> 16) & 0xffff;
    command[2] = coord->x_coord & 0xffff;
    command[3] = (coord->y_coord >> 16) & 0xffff;
    command[4] = coord->y_coord & 0xffff;
    command[5] = (coord->z_coord >> 16) & 0xffff;
    command[6] = coord->z_coord & 0xffff;

    duration_ms = duration_ms * QDSP_CMD_3D_POS_NATIVE_SAMPLING_RATE_INDEX;

    command[7] = (duration_ms >> 16) & 0xffff;
    command[8] = duration_ms & 0xffff;
    MSG_MED(" 3d Listener Velocity  X = %ld ,Y = %ld,Z = %ld ",
	      coord->x_coord,coord->y_coord,coord->z_coord );
    return(qdsp_cmd_3d_pos_add_env_q(command,
                                     QDSP_CMD_3D_POS_LSNR_VEL_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0 );
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_reverb_reset

DESCRIPTION
  This function clears reverb preset and set the reverb enable flag to
  FALSE.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_3d_reverb_reset (void) {

  qdsp_cmd_3d_reverb_enabled = FALSE;
  qdsp_cmd_3d_reverb_cur_env = QDSP_CMD_3D_INVALID_ENVIRONMENTS;
  MSG_MED(" Issue 3d Reverb reset command ",0,0,0 );
  memset( &qdsp_cmd_3d_reverb_current[1],
          0x00,
          QDSP_CMD_3D_REVERB_ENV_SIZE*2);

}

/*===========================================================================

FUNCTION qdsp_cmd_3d_reverb_set

DESCRIPTION
  Sets the 3D reverb parameters.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_reverb_set (
  qdsp_cmd_3d_reverb_cmd_type    cmd,
  qdsp_cmd_3d_reverb_param_type *param
){
  if(param != NULL) {
    switch( cmd){
      case QDSP_CMD_3D_REVERB_PRESET:
        if ( param->env_type < QDSP_CMD_3D_KNOWN_ENVIRONMENTS ) {
          memcpy( &qdsp_cmd_3d_reverb_current[1],
                  &qdsp_cmd_3d_reverb_env[param->env_type],
                  QDSP_CMD_3D_REVERB_ENV_SIZE*2);
          qdsp_cmd_3d_reverb_cur_env = param->env_type;
        } else{
          qdsp_cmd_3d_reverb_current[1] = param->room_gain;
          qdsp_cmd_3d_reverb_current[2] = (param->decay_ms >> 16) & 0xffff;
          qdsp_cmd_3d_reverb_current[3] = param->decay_ms & 0xffff;
          qdsp_cmd_3d_reverb_current[4] = (param->decay_ratio >> 16) & 0xffff;
          qdsp_cmd_3d_reverb_current[5] = param->decay_ratio & 0xffff;
          qdsp_cmd_3d_reverb_current[6] = param->ref_delay & 0xffff;
          qdsp_cmd_3d_reverb_current[7] = param->reverb_gain & 0xffff;
          qdsp_cmd_3d_reverb_current[8] = param->reverb_delay & 0xffff;
          qdsp_cmd_3d_reverb_cur_env = param->env_type;
          MSG_MED("3d Reverb Environment type = %ld \n",param->env_type,0,0 );
          MSG_MED("3d Reverb gain = %ld,decay_time = %ld,decay_ratio = %ld \n",
	                 param->room_gain,param->decay_ms,param->decay_ratio);
	  MSG_MED("3d Reverbdelay = %ld,Reverbdelay = %ld,Reverbgain = %ld \n",
                   param->ref_delay,param->reverb_delay,param->reverb_gain );
        }

        break;

      case QDSP_CMD_3D_REVERB_LEVEL:
        qdsp_cmd_3d_reverb_current[7] = param->reverb_gain & 0xffff;
	  MSG_MED("3d Reverb gain = %ld",param->reverb_gain ,0,0 );
        break;

      case QDSP_CMD_3D_REVERB_TIME:
          qdsp_cmd_3d_reverb_current[2] = (param->decay_ms >> 16) & 0xffff;
          qdsp_cmd_3d_reverb_current[3] = param->decay_ms & 0xffff;
          MSG_MED("3d Reverb time  = %ld",param->decay_ms,0,0 );
        break;

      case QDSP_CMD_3D_REVERB_RATIO:
          qdsp_cmd_3d_reverb_current[4] = (param->decay_ratio >> 16) & 0xffff;
          qdsp_cmd_3d_reverb_current[5] = param->decay_ratio & 0xffff;
          MSG_MED("3d Reverb ratio  = %ld",param->decay_ratio,0,0 );
        break;

      default:
	 MSG_ERROR(" Invalid 3d reverb parameters  ",0,0,0);
        return(QDSP_CMD_FAILED);
    }

    if( (qdsp_cmd_3d_reverb_enabled == TRUE) &&
        (qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) ) {
      return(qdsp_cmd_3d_pos_add_env_q(qdsp_cmd_3d_reverb_current,
                                     QDSP_CMD_3D_REVERB_CMD_SIZE));
  } else {
      return( QDSP_CMD_SUCCESS);
    }
  } else {
      MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0);
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_reverb_disable

DESCRIPTION
  Enables/Disables the 3D reverb.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_reverb_enable (
  boolean    enable
 ){
  uint16 command[1];

  qdsp_cmd_3d_reverb_enabled = enable;

  if(qdsp_cmd_image_select == QDSP_IMAGE_SYNTH ) {
    command[0] = QDSP_CMD_3D_REVERB_DISABLE_CMD;

    if( enable == TRUE){
       MSG_MED("Enable 3d Reverb",0,0,0);
      return(qdsp_cmd_3d_pos_add_env_q(qdsp_cmd_3d_reverb_current,
                                       QDSP_CMD_3D_REVERB_CMD_SIZE));
    } else {
        MSG_MED("Disable 3d Reverb",0,0,0);
      return(qdsp_cmd_3d_pos_add_env_q(command,
                                       QDSP_CMD_3D_REVERB_DISABLE_CMD_SIZE));
    }
  } else {
    return(QDSP_CMD_SUCCESS);
  }
}

/*===========================================================================

FUNCTION qdsp_cmd_3d_reverb_check

DESCRIPTION
  Enables/Disables the 3D reverb on DSP when loaded.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void qdsp_cmd_3d_reverb_check ( void ){
  if( qdsp_cmd_3d_reverb_enabled == TRUE &&
      qdsp_cmd_image_select == QDSP_IMAGE_SYNTH){
    if( qdsp_cmd_3d_pos_add_env_q( qdsp_cmd_3d_reverb_current,
                                   QDSP_CMD_3D_REVERB_CMD_SIZE) !=
        QDSP_CMD_SUCCESS){
      MSG_ERROR( "Unable to Enable Reverb on Qsynth!!", 0, 0, 0);
    }
  }
}

/* <EJECT> */

/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_src_enable
DESCRIPTION
  This function enable/disable 3D effect on given sound source.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_src_enable (
  uint32 src_adec_num,
  qdsp_cmd_3d_pos_mode_enum_type mode
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint16               command[2];

  if (qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {
    command[0] = QDSP_CMD_3D_POS_SRC_ENABLE_CMD;
    if (mode == QDSP_CMD_3D_POS_MODE_DISABLE) {
      command[1] = 0x0000;
      ret_val = qdsp_cmd_3d_pos_add_src_q(src_adec_num,
                                          command,
                                          QDSP_CMD_3D_POS_SRC_ENABLE_CMD_SIZE);
      MSG_MED(" Disable 3d Source Effect",0,0,0 );
    } else if (mode == QDSP_CMD_3D_POS_MODE_ENABLE) {
      command[1] = 0xFFFF;
      ret_val = qdsp_cmd_3d_pos_add_src_q(src_adec_num,
                                          command,
                                          QDSP_CMD_3D_POS_SRC_ENABLE_CMD_SIZE);
      MSG_MED(" Enable 3d Source Effect",0,0,0 );
    } else {
      MSG_ERROR("Invalid 3D enable mode", 0, 0, 0);
    }
  }

  return ret_val;
}

/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_reset_src

DESCRIPTION
  Resets the 3D positional source.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_reset_src (
  uint32 src_adec_num
) {
  uint16 counter = 0;
  uint16 command[2];

  if(qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {
    command[0] = QDSP_CMD_3D_POS_SRC_RESET_CMD;
    MSG_MED( " Reset 3d Source Effect ",0,0,0 );
    while(counter < 7) {
      if(qdsp_cmd_qsynth_adpcm_data[src_adec_num].sampling_rate <=
         qdsp_cmd_3d_pos_sample_rate_index[counter].sr_threshold) {
        break;
      }
      counter++;
    }

    command[1] = qdsp_cmd_3d_pos_sample_rate_index[counter].index;
    return(qdsp_cmd_3d_pos_add_src_q(src_adec_num, command,
                                     QDSP_CMD_3D_POS_SRC_RESET_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0 );
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_set_src_vol

DESCRIPTION
  Sets the 3D positional source volume.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_set_src_vol (
  uint32 src_adec_num,
  uint16 volume,
  uint32 duration_ms
) {
  uint16 command[4];

  if(qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {
    if(volume > 0x7fff) {
      volume = 0x7fff;
    }
    command[0] = QDSP_CMD_3D_POS_SRC_VOLUME_CMD;
    command[1] = volume;

    duration_ms = duration_ms *
                (qdsp_cmd_qsynth_adpcm_data[src_adec_num].sampling_rate / 1000);

    command[2] = (duration_ms >> 16) & 0xffff;
    command[3] = duration_ms & 0xffff;
    MSG_MED("3d Source volume  =%d, duration = %d  ",volume,duration_ms,0 );

    return(qdsp_cmd_3d_pos_add_src_q(src_adec_num, command,
                                     QDSP_CMD_3D_POS_SRC_VOLUME_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0);
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_set_src_vol_atten

DESCRIPTION
  Sets the 3D positional source volume attenuation.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_set_src_vol_atten (
  uint32                             src_adec_num,
  qdsp_cmd_3d_pos_src_vol_atten_type *vol_atten
) {
  uint16 command[7];
  uint32 rolloff;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (vol_atten != NULL)) {
    if(vol_atten->rolloff > 0x7FFF) {
      rolloff = 0x7FFF;
    } else {
      rolloff = vol_atten->rolloff;
    }
    command[0] = QDSP_CMD_3D_POS_SRC_VOL_ATTEN_CMD;
    command[1] = (vol_atten->max_distance >> 16) & 0xffff;
    command[2] = vol_atten->max_distance & 0xffff;
    command[3] = (vol_atten->min_distance >> 16) & 0xffff;
    command[4] = vol_atten->min_distance & 0xffff;
    command[5] = rolloff;
    if( vol_atten->mute == TRUE){
      command[6] = 0xFFFF;
    } else {
      command[6] = 0;
    }
    MSG_MED("3d Source volume Attenuation  Max = %d, Min = %d , Rolloff = %d",
		     vol_atten->max_distance,vol_atten->min_distance,rolloff);
    return(qdsp_cmd_3d_pos_add_src_q(src_adec_num, command,
                                     QDSP_CMD_3D_POS_SRC_VOL_ATTEN_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld  ",qdsp_cmd_image_select,0,0);
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_set_src_pos

DESCRIPTION
  Sets the 3D positional source position.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_set_src_pos (
  uint32                     src_adec_num,
  qdsp_cmd_3d_pos_coord_type *coord,
  uint32                     duration_ms
) {
  uint16 command[9];

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (coord != NULL)) {
    command[0] = QDSP_CMD_3D_POS_SRC_POS_CMD;
    command[1] = (coord->x_coord >> 16) & 0xffff;
    command[2] = coord->x_coord & 0xffff;
    command[3] = (coord->y_coord >> 16) & 0xffff;
    command[4] = coord->y_coord & 0xffff;
    command[5] = (coord->z_coord >> 16) & 0xffff;
    command[6] = coord->z_coord & 0xffff;

    duration_ms = duration_ms *
                (qdsp_cmd_qsynth_adpcm_data[src_adec_num].sampling_rate / 1000);

    command[7] = (duration_ms >> 16) & 0xffff;
    command[8] = duration_ms & 0xffff;
    MSG_MED("3d Source position X = %ld ,Y = %ld,Z = %ld  ",
             coord->x_coord,coord->y_coord,coord->z_coord );
    return(qdsp_cmd_3d_pos_add_src_q(src_adec_num, command,
                                     QDSP_CMD_3D_POS_SRC_POS_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0);
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================
FUNCTION qdsp_cmd_3d_pos_set_src_vel

DESCRIPTION
  Sets the 3D positional source velocity.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_set_src_vel (
  uint32                     src_adec_num,
  qdsp_cmd_3d_pos_coord_type *coord,
  uint32                     duration_ms
) {
  uint16 command[9];

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (coord != NULL)) {
    command[0] = QDSP_CMD_3D_POS_SRC_VEL_CMD;
    command[1] = (coord->x_coord >> 16) & 0xffff;
    command[2] = coord->x_coord & 0xffff;
    command[3] = (coord->y_coord >> 16) & 0xffff;
    command[4] = coord->y_coord & 0xffff;
    command[5] = (coord->z_coord >> 16) & 0xffff;
    command[6] = coord->z_coord & 0xffff;

    duration_ms = duration_ms *
                (qdsp_cmd_qsynth_adpcm_data[src_adec_num].sampling_rate / 1000);

    command[7] = (duration_ms >> 16) & 0xffff;
    command[8] = duration_ms & 0xffff;
    MSG_MED("3d Source velocity  X = %ld ,Y = %ld,Z = %ld ",
             coord->x_coord,coord->y_coord,coord->z_coord );
    return(qdsp_cmd_3d_pos_add_src_q(src_adec_num, command,
                                     QDSP_CMD_3D_POS_SRC_VEL_CMD_SIZE));
  } else {
      MSG_ERROR(" Qsynth image not loaded %ld  ",qdsp_cmd_image_select,0,0);
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_reverb_set_src_vol

DESCRIPTION
  Sets the reverb source volume.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_reverb_set_src_vol (
  uint32                channel,
  uint16                volume
) {
  uint16 command[2];

  if(qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) {

    if(volume > 0x7fff) {
      volume = 0x7fff;
    }

    command[0] = QDSP_CMD_3D_REVERB_SRC_VOL_CMD;
    command[1] = volume;
    MSG_MED("3d Reverb source volume = %d ",volume,0,0 );
    return(qdsp_cmd_3d_pos_add_src_q(channel, command,
                                     QDSP_CMD_3D_REVERB_SRC_VOL_CMD_SIZE));
  } else {
    MSG_ERROR(" Qsynth image not loaded %ld ",qdsp_cmd_image_select,0,0);
    return(QDSP_CMD_FAILED);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_env_enabled

DESCRIPTION
  Queries if 3D environment is currently enabled or not.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_env_enabled(
  boolean *flag
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) &&(flag != NULL)) {
    query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
    query_buffer = (uint16 *) query_addr;
    if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
       (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
      query_buffer += QDSP_CMD_3D_POS_QUERY_ENV_ENABLE_OFFSET;

      *flag = (*query_buffer == 0xFFFF?TRUE:FALSE);
       MSG_MED("Query 3d Environment flag = %d ", *flag,0,0);
      ret_val = QDSP_CMD_SUCCESS;
    } else{
      MSG_ERROR(" Qsynth image not loaded %ld",qdsp_cmd_image_select, 0,0);
    }
  }

  return(ret_val);
}
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_lsnr_pos

DESCRIPTION
  Queries the 3D positional listener position.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_lsnr_pos (
  qdsp_cmd_3d_pos_coord_type *coord
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (coord != NULL)) {
    query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
    query_buffer = (uint16 *) query_addr;
    if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
       (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
      query_buffer += QDSP_CMD_3D_POS_QUERY_LSNR_POS_OFFSET;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      coord->x_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      coord->y_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer;
      coord->z_coord = query_addr;
      MSG_MED("Query 3d Listner Position X = %ld,Y = %ld,Z = %ld  ",
		      coord->x_coord,coord->y_coord,coord->z_coord );
      ret_val = QDSP_CMD_SUCCESS;
    } else{
      MSG_ERROR( "DSP not loaded %ld", coord, 0,0);
    }
  }

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_lsnr_orient

DESCRIPTION
  Queries the 3D positional listener orientation.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_lsnr_orient (
  qdsp_cmd_3d_pos_orient_type *orient
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (orient != NULL)) {
    query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
    query_buffer = (uint16 *) query_addr;
    if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
       (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
      query_buffer += QDSP_CMD_3D_POS_QUERY_LSNR_ORIENT_OFFSET;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      orient->forward.x_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      orient->forward.y_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      orient->forward.z_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      orient->up.x_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      orient->up.y_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer;
      orient->up.z_coord = query_addr;
      MSG_MED("Query 3d Listner Orientation X = %ld ,Y = %ld,Z = %ld ",
              orient->up.x_coord,orient->up.y_coord,orient->up.z_coord );
      MSG_MED("Query 3d Listner Orientation  X = %ld ,Y = %ld,Z = %ld  ",
      orient->forward.x_coord,orient->forward.y_coord,orient->forward.z_coord);
      ret_val = QDSP_CMD_SUCCESS;
   }
  } else{
      MSG_ERROR(" Qsynth image not loaded %ld  ",qdsp_cmd_image_select,0,0);
  }
  return(ret_val);
}
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_lsnr_vel

DESCRIPTION
  Queries the 3D positional listener velocity.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_lsnr_vel (
  qdsp_cmd_3d_pos_vector_type *vel_vector
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (vel_vector != NULL)) {
    query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
    query_buffer = (uint16 *) query_addr;
    if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
       (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
      query_buffer += QDSP_CMD_3D_POS_QUERY_LSNR_VEL_OFFSET;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      vel_vector->x_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer++;
      vel_vector->y_coord = query_addr;

      query_addr = *query_buffer++;
      query_addr = (query_addr << 16) | *query_buffer;
      vel_vector->z_coord = query_addr;
      MSG_MED("Query 3d Listner Orientation  X = %ld ,Y = %ld,Z = %ld ",
               vel_vector->x_coord,vel_vector->y_coord,vel_vector->z_coord );
      ret_val = QDSP_CMD_SUCCESS;
    }
    } else{
      MSG_ERROR(" Qsynth image not loaded %ld  ",qdsp_cmd_image_select,0,0);
  }

  return(ret_val);
}
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_reverb_enabled

DESCRIPTION
  Queries if reverb is currently enabled or not.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_reverb_enabled(
  boolean *flag
) {
  if( flag != NULL){
    *flag = qdsp_cmd_3d_reverb_enabled;
    return(QDSP_CMD_SUCCESS);
  } else{
    MSG_ERROR("Qsynth DSP image not loaded",0,0,0);
   return(QDSP_CMD_FAILED);
  }
}

/*==========================================================================
  FUNCTION qdsp_cmd_3d_pos_query_reverb_setting

DESCRIPTION
  Queries current reverb setting

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
 ==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_reverb_setting(
  qdsp_cmd_3d_reverb_param_type *reverb
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;

  if(reverb != NULL) {
    reverb->env_type  = qdsp_cmd_3d_reverb_cur_env;
    reverb->room_gain = qdsp_cmd_3d_reverb_current[1];
    reverb->decay_ms =  (qdsp_cmd_3d_reverb_current[2] << 16) |
                        qdsp_cmd_3d_reverb_current[3];
    reverb->decay_ratio = (qdsp_cmd_3d_reverb_current[4] << 16) |
                          qdsp_cmd_3d_reverb_current[5];
    reverb->ref_delay   = qdsp_cmd_3d_reverb_current[6];
    reverb->reverb_gain = qdsp_cmd_3d_reverb_current[7];
    reverb->reverb_delay = qdsp_cmd_3d_reverb_current[8];
    ret_val = QDSP_CMD_SUCCESS;
   }else{
      MSG_ERROR("Qsynth DSP image not loaded ",0,0,0);
  }

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_src_final

DESCRIPTION
  Queries the 3D positional source settings at end of playback.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_src_final (
  uint32                            src_adec_num,
  qdsp_cmd_3d_pos_src_final_cb_type cb_func
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (cb_func != NULL)) {
    if((src_adec_num < 4) &&
       (qdsp_cmd_synth_adec_enabled[src_adec_num] == TRUE)) {
      qdsp_cmd_3d_pos_query_src_final_cb[src_adec_num] = cb_func;
      ret_val = QDSP_CMD_SUCCESS;
    }
  }

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_src_enabled

DESCRIPTION
  Queries if source 3D effect is currently enabled or not.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_src_enabled(
  uint32  src_adec_num,
  boolean *flag
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (flag != NULL)) {
    if((src_adec_num < 4) &&
       (qdsp_cmd_synth_adec_enabled[src_adec_num] == TRUE)) {
      query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
      query_buffer = (uint16 *) query_addr;
      if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
         (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
        query_buffer += QDSP_CMD_3D_POS_QUERY_SRC_OFFSET;
        query_buffer += (src_adec_num * QDSP_CMD_3D_POS_QUERY_SRC_SIZE) +
                        QDSP_CMD_3D_POS_QUERY_SRC_ENABLE_OFFSET;

        *flag = (*query_buffer == 0xFFFF?TRUE:FALSE);

        ret_val = QDSP_CMD_SUCCESS;
      }
    }
  }

  return(ret_val);
}
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_src_pos

DESCRIPTION
  Queries the 3D positional source position.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_src_pos (
  uint32                     src_adec_num,
  qdsp_cmd_3d_pos_coord_type *coord
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (coord != NULL)) {
    if((src_adec_num < 4) &&
       (qdsp_cmd_synth_adec_enabled[src_adec_num] == TRUE)) {
      query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
      query_buffer = (uint16 *) query_addr;
      if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
         (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
        query_buffer += QDSP_CMD_3D_POS_QUERY_SRC_OFFSET;
        query_buffer += (src_adec_num * QDSP_CMD_3D_POS_QUERY_SRC_SIZE) +
                        QDSP_CMD_3D_POS_QUERY_SRC_POS_OFFSET;

        query_addr = *query_buffer++;
        query_addr = (query_addr << 16) | *query_buffer++;
        coord->x_coord = query_addr;

        query_addr = *query_buffer++;
        query_addr = (query_addr << 16) | *query_buffer++;
        coord->y_coord = query_addr;

        query_addr = *query_buffer++;
        query_addr = (query_addr << 16) | *query_buffer;
        coord->z_coord = query_addr;

        ret_val = QDSP_CMD_SUCCESS;
      }
    }
  }

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_src_vol

DESCRIPTION
  Queries the 3D positional source volume.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_src_vol (
  uint32 src_adec_num,
  uint16 *volume
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (volume != NULL)) {
    if((src_adec_num < 4) &&
       (qdsp_cmd_synth_adec_enabled[src_adec_num] == TRUE)) {
      query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
      query_buffer = (uint16 *) query_addr;
      if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
         (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
        query_buffer += QDSP_CMD_3D_POS_QUERY_SRC_OFFSET;
        query_buffer += (src_adec_num * QDSP_CMD_3D_POS_QUERY_SRC_SIZE) +
                        QDSP_CMD_3D_POS_QUERY_SRC_VOL_OFFSET;

        *volume = *query_buffer;

        ret_val = QDSP_CMD_SUCCESS;
      }
    }
  }

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_src_vol_atten

DESCRIPTION
  Queries the 3D positional source volume attenuation.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_src_vol_atten (
  uint32                             src_adec_num,
  qdsp_cmd_3d_pos_src_vol_atten_type *vol_atten
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (vol_atten != NULL)) {
    if((src_adec_num < 4) &&
       (qdsp_cmd_synth_adec_enabled[src_adec_num] == TRUE)) {
      query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
      query_buffer = (uint16 *) query_addr;
      if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
         (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
        query_buffer += QDSP_CMD_3D_POS_QUERY_SRC_OFFSET;
        query_buffer += (src_adec_num * QDSP_CMD_3D_POS_QUERY_SRC_SIZE) +
                        QDSP_CMD_3D_POS_QUERY_SRC_VOL_ATTEN_OFFSET;

        query_addr = *query_buffer++;
        query_addr = (query_addr << 16) | *query_buffer++;
        vol_atten->max_distance = query_addr;

        query_addr = *query_buffer++;
        query_addr = (query_addr << 16) | *query_buffer++;
        vol_atten->min_distance = query_addr;

        vol_atten->rolloff = *query_buffer++;
        vol_atten->mute    = (*query_buffer == 0)? FALSE : TRUE;

        ret_val = QDSP_CMD_SUCCESS;
      }
    }
  }

  return(ret_val);
}

/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_src_vel

DESCRIPTION
  Queries the 3D positional source velocity.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_src_vel (
  uint32                     src_adec_num,
  qdsp_cmd_3d_pos_vector_type *src_vel
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (src_vel != NULL)) {
    if((src_adec_num < 4) &&
       (qdsp_cmd_synth_adec_enabled[src_adec_num] == TRUE)) {
      query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
      query_buffer = (uint16 *) query_addr;
      if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
         (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
        query_buffer += QDSP_CMD_3D_POS_QUERY_SRC_OFFSET;
        query_buffer += (src_adec_num * QDSP_CMD_3D_POS_QUERY_SRC_SIZE) +
                        QDSP_CMD_3D_POS_QUERY_SRC_VEL_OFFSET;

        query_addr = *query_buffer++;
        query_addr = (query_addr << 16) | *query_buffer++;
        src_vel->x_coord = query_addr;

        query_addr = *query_buffer++;
        query_addr = (query_addr << 16) | *query_buffer++;
        src_vel->y_coord = query_addr;

        query_addr = *query_buffer++;
        query_addr = (query_addr << 16) | *query_buffer;
        src_vel->z_coord = query_addr;

        ret_val = QDSP_CMD_SUCCESS;
      }
    }
  }

  return(ret_val);
}

/*===========================================================================

FUNCTION qdsp_cmd_3d_pos_query_src_revol

DESCRIPTION
  Queries the 3D positional source reverb volume.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_3d_pos_query_src_revol (
  uint32 src_adec_num,
  uint16 *reverb_volume
) {
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;
  uint32               query_addr;
  uint16               *query_buffer;

  if((qdsp_cmd_image_select == QDSP_IMAGE_SYNTH) && (reverb_volume != NULL)) {
    if((src_adec_num < 4) &&
       (qdsp_cmd_synth_adec_enabled[src_adec_num] == TRUE) &&
        qdsp_cmd_3d_reverb_enabled == TRUE) {
      query_addr   = qdsp_read(QDSP_adecPPStateExtPtrCurr);
      query_buffer = (uint16 *) query_addr;
      if((query_buffer == qdsp_cmd_3d_pos_query_buffer1) ||
         (query_buffer == qdsp_cmd_3d_pos_query_buffer2)) {
        query_buffer += QDSP_CMD_3D_POS_QUERY_SRC_OFFSET;
        query_buffer += (src_adec_num * QDSP_CMD_3D_POS_QUERY_SRC_SIZE) +
                        QDSP_CMD_3D_POS_QUERY_SRC_REVOL_OFFSET;

        *reverb_volume = *query_buffer;

        ret_val = QDSP_CMD_SUCCESS;
      }
    }
  }

  return(ret_val);
}
#endif /* FEATURE_QAUDIOFX */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_DTMF_PATH (DMA TYPE Writable Information)

DESCRIPTION

  This function selects the audio path for DTMF generation.


DEPENDENCIES

  This command is only valid when the DSP is in IDLE, Vocoder
  or DFM state.

RETURN VALUE

  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS

  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_set_dtmf_path (
  uint16 dtmf_path
)
{
  qdsp_write(QDSP_dtmfGenPathSelect, dtmf_path);

  return( QDSP_CMD_SUCCESS );
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_VOC_CONFIG (command 0x0100)

DESCRIPTION
  This function will send a command to the DSP to configure the vocoder.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_voc_config (
  uint16 config,
  uint16 enc_val,
  uint16 dec_val
)
{
  qdsp_cmd_status_type result;             /* Store the return value       */

  uint16 voc_config_command[VOC_CONFIG_CMD_SIZE];            /* Local buffer for the command */

  voc_config_command[0] = VOC_CONFIG_CMD_SIZE; /* Length of the command */
  voc_config_command[1] = VOC_CONFIG_CMD_HDR;  /* Command header        */
  voc_config_command[2] = config;              /* Configuration         */
#if defined(QDSP_IMAGE_VOC_COMBO_DEFINED) || defined(QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED)
  voc_config_command[3] = enc_val;             /* Encoder mode          */
  voc_config_command[4] = dec_val;             /* Decoder mode          */
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED || QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED */

  /* Now send the VOCODER CONFIGURATION command to the QDSP2 */
  if( (result = qdsp2_command( voc_config_command ))
       != QDSP_CMD_SUCCESS )
  {
     MSG_ERROR("QDSP2 Vocoder Configuration Error!", 0, 0, 0);
  }
  else {
    /* Update qdsp_voc_mode */
    qdsp_voc_mode = (config & QDSP_VOC_MODE_M);

    /* Update voc_qdsp2_packet_data_size base on configuration */
    switch (qdsp_voc_mode)
    {
      case QDSP_VOC_MODE_IS733_V:
        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_13k;
        break;

      case QDSP_VOC_MODE_IS127_V:
#ifdef MSMAUD_VOC_IS127_VOIP
      case QDSP_VOC_MODE_IS127_VOIP_V:
#endif
        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_EVRC;
        break;

#ifdef MSMAUD_VOC_4GV
      case QDSP_VOC_MODE_4GV_V:
#ifdef MSMAUD_VOC_4GV_VOIP
#error code not present
#endif  /* MSMAUD_VOC_4GV_VOIP */
        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_4GV;
        break;
#endif  /* MSMAUD_VOC_4GV */

#ifdef MSMAUD_VOC_4GV_WB
      case QDSP_VOC_MODE_4GV_WB_V:
#ifdef MSMAUD_VOC_4GV_WB_VOIP
      case QDSP_VOC_MODE_4GV_WB_VOIP_V:
#endif  /* MSMAUD_VOC_4GV_WB_VOIP */
        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_4GV_WB;
        break;
#endif  /* MSMAUD_VOC_4GV_WB */

#if defined(MSMAUD_VOC_AMR_COMMON) || defined(MSMAUD_VOC_EFR) || \
    defined(MSMAUD_VOC_FR)         || defined(MSMAUD_VOC_HR)
#if defined(MSMAUD_VOC_FR)
#error code not present
#endif /* defined(MSMAUD_VOC_FR) */
#if defined(MSMAUD_VOC_EFR)
#error code not present
#endif /* defined(MSMAUD_VOC_EFR) */
#if defined(MSMAUD_VOC_AMR_COMMON)
      case QDSP_VOC_MODE_AMR_V :
#endif /* defined(MSMAUD_VOC_AMR) */
#if defined(MSMAUD_VOC_HR)
      case QDSP_VOC_MODE_GSM_HR_V :
#endif  /* MSMAUD_VOC_HR */
#ifdef MSMAUD_VOC_AMR
        /* Drop the first 2 packets from FR/EFR/HR/AMR vocoders */
        qdsp_cmd_voc_enc_pkt_drop = QDSP_CMD_VOC_ENC_PKT_DROP_NUM;
#endif
        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_amr;
        break;
#endif /* MSMAUD_VOC_AMR_COMMON || MSMAUD_VOC_EFR ||
          MSMAUD_VOC_FR         || MSMAUD_VOC_HR */

#ifdef MSMAUD_VOC_AMR_WB_COMMON
      case QDSP_VOC_MODE_AMR_WB_V :
        /* Drop the first 2 packets from AMR-WB vocoders */
        qdsp_cmd_voc_enc_pkt_drop = QDSP_CMD_VOC_ENC_PKT_DROP_NUM;
        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_amr_wb;
        break;
#endif  /* MSMAUD_VOC_AMR_WB_COMMON */

#ifdef MSMAUD_VOC_G711
      case QDSP_VOC_MODE_G711_V:
        /* Not needed, only 1 size */
        voc_qdsp2_packet_data_size = NULL;
        /* Drop the first 2 packets from vocoders */
        qdsp_cmd_voc_enc_pkt_drop = QDSP_CMD_VOC_ENC_PKT_DROP_NUM;
        break;
#endif /* MSMAUD_VOC_G711 */

#ifdef MSMAUD_VOC_G723
      case QDSP_VOC_MODE_G723_V:
        voc_qdsp2_packet_data_size = qdsp_cmd_packet_size_g723;
        /* Drop the first 2 packets from vocoders */
        qdsp_cmd_voc_enc_pkt_drop = QDSP_CMD_VOC_ENC_PKT_DROP_NUM;
        break;
#endif /* MSMAUD_VOC_G723 */

      default:
        MSG_ERROR("QDSP2 Vocoder Configuration Error!", 0, 0, 0);

        /* Default to 13K vocoder */
        qdsp_voc_mode = QDSP_VOC_MODE_IS733_V;
        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_13k;
        result = QDSP_CMD_FAILED;
        break;
    }
  }
  return( result );
}

/* <EJECT> */
#ifdef FEATURE_GRAPH_AUDIO
/*===========================================================================

FUNCTION QDSP_CMD_SELECT_VOCODER (command 0x0300)

DESCRIPTION
  This function will send a command to the DSP to select vocoder mode.

DEPENDENCIES
  This command is only valid when the DSP is in INIT state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_select_vocoder (
  uint16 voc_select
) {
  qdsp_cmd_status_type result = QDSP_CMD_SUCCESS; /* Store the return value */

#if defined(QDSP_IMAGE_MP4E_DEFINED)               || \
    defined(QDSP_IMAGE_MP4E_BAYER_DEFINED)         || \
    defined(QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED)
  /* Local buffer for the command */
  uint16 voc_select_command[VOC_SELECT_CMD_SIZE];

  voc_select_command[0] = VOC_SELECT_CMD_SIZE; /* Length of the command */
  voc_select_command[1] = VOC_SELECT_CMD_HDR;  /* Command header        */
  voc_select_command[2] = voc_select;

  /* Set flag to indicate command in progress */
  qdsp_write(QDSP_vocoderSwitchFlag, 1);

  /* Now send the vocoder select command to the QDSP2 */
  if( (result = qdsp2_command( voc_select_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_ERROR("QDSP2 Vocoder Select Error!", 0, 0, 0);
  }
#endif /* QDSP_IMAGE_MP4E_DEFINED               ||
          QDSP_IMAGE_MP4E_BAYER_DEFINED         ||
          QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED */
  return(result);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_VERIFY_VOC_SELECT_DONE

DESCRIPTION
  This function will check the vocoder select done flag.

DEPENDENCIES
  This command is only valid when the DSP is in INIT state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_verify_voc_select_done ()
{
  boolean ret_val = TRUE;
#if defined(QDSP_IMAGE_MP4E_DEFINED)               || \
    defined(QDSP_IMAGE_MP4E_BAYER_DEFINED)         || \
    defined(QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED)
  ret_val = (qdsp_read(QDSP_vocoderSwitchFlag) == 0);
#endif /* QDSP_IMAGE_MP4E_DEFINED               ||
          QDSP_IMAGE_MP4E_BAYER_DEFINED         ||
          QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED */

  return(ret_val);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_REC_FRAME_RATES

DESCRIPTION
  This function will set the previously stored frame rates.

DEPENDENCIES
  qdsp_cmd_rec_max_frame_rate, qdsp_cmd_rec_min_frame_rate

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_set_rec_frame_rates(void)
{
  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_MP4E_DEFINED)        || \
    defined(QDSP_IMAGE_MP4E_BAYER_DEFINED)  || \
    defined(QDSP_IMAGE_MP4E_13K_DEFINED)    || \
    defined(QDSP_IMAGE_MP4E_EVRC_DEFINED)   || \
    defined(QDSP_IMAGE_AUDDUB_13K_DEFINED)  || \
    defined(QDSP_IMAGE_AUDDUB_EVRC_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_DEFINED)  || \
    defined(QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_AACENC_DEFINED)

#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
#endif
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
#endif
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
#endif
#ifdef QDSP_IMAGE_AUDDUB_13K_DEFINED
    case QDSP_IMAGE_AUDDUB_13K:
#endif
#ifdef QDSP_IMAGE_AUDDUB_EVRC_DEFINED
    case QDSP_IMAGE_AUDDUB_EVRC:
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
#endif

      if((qdsp_cmd_rec_min_frame_rate != QDSP_RATE_HALF_V) &&
         (qdsp_cmd_rec_min_frame_rate != QDSP_RATE_FULL_V)) {
        qdsp_write(QDSP_encMinRate, QDSP_RATE_HALF_V);
      }
      else {
        qdsp_write(QDSP_encMinRate, qdsp_cmd_rec_min_frame_rate);
      }

      if((qdsp_cmd_rec_max_frame_rate != QDSP_RATE_HALF_V) &&
         (qdsp_cmd_rec_max_frame_rate != QDSP_RATE_FULL_V)) {
        qdsp_write(QDSP_encMaxRate, QDSP_RATE_FULL_V);
      }
      else {
        qdsp_write(QDSP_encMaxRate, qdsp_cmd_rec_max_frame_rate);
      }
      break;

#endif /* QDSP_IMAGE_MP4E_DEFINED       || QDSP_IMAGE_MP4E_BAYER_DEFINED  ||
          QDSP_IMAGE_MP4E_13K_DEFINED   || QDSP_IMAGE_MP4E_EVRC_DEFINED   ||
          QDSP_IMAGE_AUDDUB_13K_DEFINED || QDSP_IMAGE_AUDDUB_EVRC_DEFINED ||
          QDSP_IMAGE_QCAMCORDER_DEFINED || QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
          QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED || QDSP_IMAGE_AACENC */

    default:
      break;
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_AUDIO_CONFIG (command 0x0303)

DESCRIPTION
  This function will send a command to the DSP to configure the audio.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_audio_config (
  qdsp_cmd_audio_config_type *config
) {
  qdsp_cmd_status_type result;             /* Store the return value       */

  /* Local buffer for the command */
  uint16 voc_config_command[AUDIO_CONFIG_CMD_SIZE];

  voc_config_command[0] = AUDIO_CONFIG_CMD_SIZE; /* Length of the command */
  voc_config_command[1] = AUDIO_CONFIG_CMD_HDR;  /* Command header        */

  switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
      voc_config_command[2] = config->coder_flag;   /* Configuration         */
      break;
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
      voc_config_command[2] = config->coder_flag;   /* Configuration         */
      break;
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
      voc_config_command[2] = config->coder_flag;   /* Configuration         */
          break;
#endif


    default:
      voc_config_command[2] = config->audio_config;  /* Configuration         */
#if defined(FEATURE_GRAPH_ADPCM) || defined(FEATURE_VOC_ADPCM)
     voc_config_command[3] = config->num_channels;  /* Number of channels    */
     voc_config_command[4] = config->sampling_rate; /* Samples per second    */
     voc_config_command[5] = config->block_size;    /* Block size            */
#endif /* FEATURE_GRAPH_ADPCM || FEATURE_VOC_ADPCM */
      break;
  }

#if defined(FEATURE_ADEC) || defined(FEATURE_WAVE_PB)
  qdsp_cmd_adpcm_status = QDSP_CMD_ADPCM_MODE_DISABLED;
#endif

  /* Now send the audio CONFIGURATION command to the QDSP2 */
  if( (result = qdsp2_command( voc_config_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_ERROR("QDSP2 Audio Configuration Error!", 0, 0, 0);
  }
  else
  {
#if defined(FEATURE_GRAPH_ADPCM) || defined(FEATURE_VOC_ADPCM)
    if ( config->audio_config == QDSP_AUDIO_MODE_ADPCM ) {
      /* Initialize graph/vocoder ADPCM parameters */
      qdsp_cmd_adpcm_data   = FALSE;

      qdsp_cmd_adpcm_adec_info.buf_ptr        = NULL;
      qdsp_cmd_adpcm_adec_info.buf_length     = 0;
      qdsp_cmd_adpcm_adec_info.buf_index      = 0;
      qdsp_cmd_adpcm_adec_info.tmp_buf_length = 0;
#ifdef FEATURE_GASYNTH_INTERFACE
      qdsp_cmd_adpcm_adec_info.buf_state      = QDSP_CMD_ADEC_STATE_BUFFER1;
      qdsp_cmd_adpcm_adec_info.free_ptr        = NULL;
      qdsp_cmd_adpcm_adec_info.next_ptr       = NULL;
      qdsp_cmd_adpcm_adec_info.next_length    = 0;
#endif /* FEATURE_GASYNTH_INTERFACE */
      qdsp_cmd_adpcm_status = QDSP_CMD_ADPCM_MODE_ENABLED;
      /* This takes care of 32 KHz ADPCM playback (using Vocoder image)
      failing immediately after G711 .wav file playback. */
      qdsp_voc_mode = QDSP_VOC_MODE_NONE_V;
    } else
#endif /* FEATURE_GRAPH_ADPCM || FEATURE_VOC_ADPCM */
    {
#ifdef FEATURE_GRAPH_ADPCM
      switch(qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_MP4E_DEFINED)       || \
    defined(QDSP_IMAGE_MP4E_BAYER_DEFINED) || \
    defined(QDSP_IMAGE_MP4E_13K_DEFINED)   || \
    defined(QDSP_IMAGE_MP4E_EVRC_DEFINED)  || \
    defined(QDSP_IMAGE_MP4E_AMR_DEFINED)   || \
    defined(QDSP_IMAGE_QCAMCORDER_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_AACENC_DEFINED)

#ifdef QDSP_IMAGE_MP4E_DEFINED
        case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
        case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
        case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
        case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
        case QDSP_IMAGE_MP4E_AMR:
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
        case QDSP_IMAGE_QCAMCORDER:
#endif /* QDSP_IMAGE_QCAMCORDER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
        case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
        case QDSP_IMAGE_AACENC:
#endif /* QDSP_IMAGE_AACENC_DEFINED */

          /* Initialize graph ADPCM parameters */
          qdsp_cmd_adpcm_adec_info.buf_ptr        = NULL;
          qdsp_cmd_adpcm_adec_info.buf_length     = 0;
          qdsp_cmd_adpcm_adec_info.tmp_buf_length = 0;
#ifdef FEATURE_GASYNTH_INTERFACE
      qdsp_cmd_adpcm_adec_info.buf_state      = QDSP_CMD_ADEC_STATE_BUFFER1;
      qdsp_cmd_adpcm_adec_info.free_ptr        = NULL;
      qdsp_cmd_adpcm_adec_info.next_ptr       = NULL;
      qdsp_cmd_adpcm_adec_info.next_length    = 0;
#endif /* FEATURE_GASYNTH_INTERFACE */
      qdsp_cmd_adpcm_status = QDSP_CMD_ADPCM_MODE_ENABLED;
          break;
#endif /* QDSP_IMAGE_MP4E_DEFINED     || QDSP_IMAGE_MP4E_BAYER_DEFINED ||
          QDSP_IMAGE_MP4E_13K_DEFINED || QDSP_IMAGE_MP4E_EVRC_DEFINED  ||
          QDSP_IMAGE_MP4E_AMR_DEFINED || QDSP_IMAGE_QCAMCORDER_DEFINED ||
          QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED || QDSP_IMAGE_AACENC_DEFINED */

        default:
          break;
      }
#endif /* FEATURE_GRAPH_ADPCM */

      /* Update voc_qdsp2_packet_data_size base on configuration */
      if (config->audio_config == QDSP_AUDIO_MODE_13K ||
          config->audio_config == QDSP_AUDIO_MODE_MP3) {

        qdsp_voc_mode = QDSP_VOC_MODE_IS733_V;

        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_13k;

#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
        if (qdsp_cmd_image_select == QDSP_IMAGE_VOC_EVRC_MP3) {
          qdsp_voc_mode = QDSP_VOC_MODE_IS127_V;
          voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_EVRC;
        }
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
        if (qdsp_cmd_image_select == QDSP_IMAGE_AMR_MP3) {
          qdsp_voc_mode = QDSP_VOC_MODE_AMR_V;
          voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_amr;
        }
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
        if (qdsp_cmd_image_select == QDSP_IMAGE_HR_MP3) {
               qdsp_voc_mode = QDSP_VOC_MODE_GSM_HR_V;
        }
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
        if (qdsp_cmd_image_select == QDSP_IMAGE_EFR_MP3) {
               qdsp_voc_mode = QDSP_VOC_MODE_GSM_EFR_V;
        }
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
        if (qdsp_cmd_image_select == QDSP_IMAGE_FR_MP3) {
               qdsp_voc_mode = QDSP_VOC_MODE_GSM_FR_V;
        }
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
      } else
      if ( config->audio_config == QDSP_AUDIO_MODE_EVRC ) {
        qdsp_voc_mode = QDSP_VOC_MODE_IS127_V;

        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_EVRC;

      } else
#ifdef MSMAUD_VOC_AMR_COMMON
      if ( config->audio_config == QDSP_AUDIO_MODE_AMR ) {
        qdsp_voc_mode = QDSP_VOC_MODE_AMR_V;

        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_amr;
      } else
#endif /* MSMAUD_VOC_AMR_COMMON */
#ifdef MSMAUD_VOC_4GV
      if (config->audio_config == QDSP_AUDIO_MODE_4GV_NB) {
        qdsp_voc_mode = QDSP_VOC_MODE_4GV_V;

        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_4GV;
      } else
#endif /* MSMAUD_VOC_4GV */
      {
        MSG_ERROR("QDSP2 Audio Configuration Error!", 0, 0, 0);

        /* Default to 13K vocoder */

        qdsp_voc_mode = QDSP_VOC_MODE_IS733_V;

        voc_qdsp2_packet_data_size = voc_qdsp2_packet_size_13k;

        result = QDSP_CMD_FAILED;
      }
    }
  }
  return( result );
}
#endif /* FEATURE_GRAPH_AUDIO */

#ifdef FEATURE_MM_REC
/*===========================================================================

FUNCTION qdsp_cmd_mm_encoder_config (command 0x0304)

DESCRIPTION
  This function will send a command to the DSP to configure the
  audio encoder.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE state.
  FEATURE_MM_REC is defined.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_mm_encoder_config (
  qdsp_cmd_aac_encoder_config_type *config
)
{
  qdsp_cmd_status_type result;             /* Store the return value       */

  /* Local buffer for the command */
  uint16 config_command[MM_ENCODER_CONFIG_CMD_SIZE + 1];

#ifdef FEATURE_AAC_REC
  uint32               start_addr;
#endif /* FEATURE_AAC_REC */


#ifdef FEATURE_AAC_REC
  start_addr = (uint32)(&qdsp_cmd_aac_enc_buffer[0]);

  config->pkt_start_addr_msw = (uint16)(start_addr >> 16);
  config->pkt_start_addr_lsw = (uint16)(start_addr & 0xFFFF);
  config->buffer_frame_num   = QDSP_CMD_MM_AAC_ENC_MAX_FRAME;
#endif /* FEATURE_AAC_REC */

  config_command[0] = MM_ENCODER_CONFIG_CMD_SIZE;/*Length of the command*/
  config_command[1] = MM_ENCODER_CONFIG_CMD_HDR; /*Command header       */
  config_command[2] = config->pkt_start_addr_msw;
  config_command[3] = config->pkt_start_addr_lsw;
  config_command[4] = config->buffer_frame_num;
  config_command[5] = config->sample_rate_index;
  config_command[6] = config->channel_select;
  config_command[7] = config->bit_per_sample_chan;

  /* Now send the audio encoder CONFIGURATION command to the QDSP2 */
  if ((result = qdsp2_command(config_command)) != QDSP_CMD_SUCCESS) {
    MSG_ERROR("QDSP2 Audio Configuration Error!", 0, 0, 0);
  }

  return (result);
}

/*===========================================================================

FUNCTION QDSP_CMD_MM_REC_AUDIO_CONFIG (command 0x0303)

DESCRIPTION
  This function will send a command to the DSP to configure the audio.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE state.
  FEATURE_MM_REC is defined.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
extern qdsp_cmd_status_type qdsp_cmd_mm_rec_audio_config (void)
{
  qdsp_cmd_status_type result;             /* Store the return value       */

  uint16 config_command[MM_AUDIO_CONFIG_CMD_SIZE];

  config_command[0] = MM_AUDIO_CONFIG_CMD_SIZE; /* Length of the command */
  config_command[1] = AUDIO_CONFIG_CMD_HDR;     /* Command header        */

  /* Now send the audio encoder CONFIGURATION command to the QDSP2 */
  if ((result = qdsp2_command(config_command)) !=
      QDSP_CMD_SUCCESS ) {

    MSG_ERROR("QDSP2 Audio Configuration Error!", 0, 0, 0);

  }

  return (result);
}

/*===========================================================================

FUNCTION qdsp_cmd_mm_rec_update_read_count

DESCRIPTION
  Used to update the read index to DSP during MultiMedia recording.

DEPENDENCIES
  FEATURE_MM_REC is defined.

RETURN VALUE
  None

SIDE EFFECTS

===========================================================================*/
void qdsp_cmd_mm_rec_update_read_count(uint32 read_cnt)
{
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
  if (qdsp_cmd_image_select == QDSP_IMAGE_QCAMCORDER_AACENC) {
    qdsp_write(QDSP_arecArmReadPacketCnt,
               read_cnt);
  }
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */

#ifdef QDSP_IMAGE_AACENC_DEFINED
  if (qdsp_cmd_image_select == QDSP_IMAGE_AACENC) {
    qdsp_write(QDSP_arecArmReadPacketCnt,
               read_cnt);
        }
#endif /* QDSP_IMAGE_AACENC_DEFINED */
}

/*===========================================================================

FUNCTION qdsp_cmd_mm_rec_swap

DESCRIPTION
  This function does the byte swap for the DSP output buffer.

DEPENDENCIES
  FEATURE_AAC_REC

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_mm_rec_swap (
  uint8  *data,
  uint32 wlen
)
{
  uint32 i = 0;
  uint8  tempData;

  i = 0;
  while (i < wlen) {

    tempData   = data[i];
    data[i]    = data[i+1];
    data[i+1]  = tempData;

    i += 2;

  } /* while (i < wlen) */
}

/*===========================================================================

FUNCTION qdsp_cmd_mm_rec_get_data

DESCRIPTION
  Retrieve encoded multimedia data frame from dsp

DEPENDENCIES
  FEATURE_MM_REC

RETURN VALUE
  TRUE  - success
  FALSE - failed

SIDE EFFECTS

===========================================================================*/
boolean qdsp_cmd_mm_rec_get_data (
  qdsp_cmd_record_buf_type *buf,
  qdsp_cmd_record_data_type *frame_info
)
{
  boolean ret_val;

#ifdef FEATURE_AAC_REC
#if defined(QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED) || \
  defined(QDSP_IMAGE_AACENC_DEFINED)
  uint32       read_index;
  const uint16 *buf_ptr = NULL;

  qdsp_cmd_aac_buf_type  *aac_buf;
  qdsp_cmd_aac_data_type *aac_frame;

  uint32                frame_count;
  uint16                byte_num;
#endif
#endif /* FEATURE_AAC_REC */

  ret_val   = TRUE;

#ifdef FEATURE_AAC_REC
#if defined(QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED) || \
  defined(QDSP_IMAGE_AACENC_DEFINED)
  if ((qdsp_cmd_mm_rec_format == QDSP_CMD_MM_REC_AAC)) {
    switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
      case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
      case QDSP_IMAGE_AACENC:
#endif /* QDSP_IMAGE_AACENC_DEFINED */

    aac_buf   = (qdsp_cmd_aac_buf_type *)buf;
    aac_frame = (qdsp_cmd_aac_data_type*)frame_info;

    aac_frame->buf1_frame_num = 0;
    aac_frame->buf1_flush     = FALSE;
    aac_frame->buf1_avsync    = FALSE;

    aac_frame->buf2_frame_num = 0;
    aac_frame->buf2_flush     = FALSE;
    aac_frame->buf2_avsync    = FALSE;

    qdsp_cmd_mm_rec_read_cnt  = qdsp_read(QDSP_arecArmReadPacketCnt);
    qdsp_cmd_mm_rec_write_cnt = qdsp_read(QDSP_arecDspWritePacketCnt);


    while (qdsp_cmd_mm_rec_read_cnt < qdsp_cmd_mm_rec_write_cnt) {

      read_index = qdsp_cmd_mm_rec_read_cnt -
                   ((qdsp_cmd_mm_rec_read_cnt / QDSP_CMD_MM_AAC_ENC_MAX_FRAME) *
                    QDSP_CMD_MM_AAC_ENC_MAX_FRAME);

      buf_ptr    = (const uint16 *)&qdsp_cmd_aac_enc_buffer[read_index];
#ifdef FEATURE_NO_CACHE_LINES
    mmu_invalidate_data_cache();
#else
    mmu_invalidate_data_cache_lines((uint32*)buf_ptr,
                                    sizeof(qdsp_cmd_mm_enc_buffer_type)) ;
#endif

      /*
       * retrieve encoded frame counter first
       */
      frame_count = *buf_ptr & 0xFFFF;

      buf_ptr++;
      frame_count = (frame_count | (*buf_ptr << 16));

      if (frame_count == 0xFFFFFFFF) {
        qdsp_cmd_cnt_wrap_around = TRUE;
      }

      /*
       * get number of bytes in the raw bitstream field
       */
      buf_ptr++;
      byte_num = *buf_ptr;

      /*
       * skip "PCM samples erased this frame" field;
       * now buf_ptr should point to the real data
       */
      buf_ptr++;

      /*
       * now it hits the data section
       */
      buf_ptr++;

      if ((byte_num == 0 || frame_count <= 4) &&
          qdsp_cmd_cnt_wrap_around == FALSE) {

        qdsp_cmd_mm_rec_read_cnt++;

        read_index = qdsp_cmd_mm_rec_read_cnt -
                 ((qdsp_cmd_mm_rec_read_cnt / QDSP_CMD_MM_AAC_ENC_MAX_FRAME) *
                  QDSP_CMD_MM_AAC_ENC_MAX_FRAME);

        qdsp_cmd_mm_rec_frame_cnt_prev = frame_count;

        continue;
      }

      if (aac_frame->buf1_flush == FALSE) {

        aac_buf->buf1 += aac_buf->hdr_offset;

        /* swap first */
        qdsp_cmd_mm_rec_swap((uint8 *)buf_ptr, (uint32)(byte_num+1));

        memcpy(aac_buf->buf1, buf_ptr, byte_num);

        qdsp_cmd_mm_rec_read_cnt++;

        aac_frame->buf1_frame_info[aac_frame->buf1_frame_num].frame_cnt   =
            frame_count;

        aac_frame->buf1_frame_info[aac_frame->buf1_frame_num].data_length =
            byte_num;

        aac_frame->buf1_frame_num += 1;
        aac_buf->buf1_space       -= byte_num;

        if (aac_buf->sync_samples > 0) {
          if ((frame_count - qdsp_cmd_mm_rec_frame_cnt_prev) > 1) {

            aac_frame->buf1_flush  = TRUE;
            aac_frame->buf1_avsync = TRUE;
            aac_frame->lost_frame1 = frame_count - qdsp_cmd_mm_rec_frame_cnt_prev;
            aac_frame->sync_frame1 = frame_count;

            qdsp_cmd_mm_rec_frame_cnt_prev = frame_count;
            continue;

          } else if (((frame_count - aac_buf->sync_frames) * 1028) >=
                      aac_buf->sync_samples) {

            aac_frame->buf1_flush  = TRUE;
            aac_frame->buf1_avsync = TRUE;
            aac_frame->lost_frame1 = 0;
            aac_frame->sync_frame1 = frame_count;

            aac_buf->sync_frames   = frame_count;

            qdsp_cmd_mm_rec_frame_cnt_prev = frame_count;
            continue;
          }
        }

        if (aac_buf->buf1_space < sizeof(qdsp_cmd_aac_enc_frame_type)) {

          aac_frame->buf1_flush  = TRUE;
          aac_frame->buf1_avsync = FALSE;
          aac_frame->lost_frame1 = 0;
          continue;
        }

      } else if (aac_buf->buf2 != NULL) {

        if (aac_frame->buf2_flush == FALSE) {

          aac_buf->buf2 += aac_buf->hdr_offset;

          /* swap first */
          qdsp_cmd_mm_rec_swap((uint8 *)buf_ptr, (uint32)(byte_num+1));

          memcpy(aac_buf->buf2, buf_ptr, byte_num);

          qdsp_cmd_mm_rec_read_cnt++;

          aac_frame->buf2_frame_info[aac_frame->buf2_frame_num].frame_cnt   =
              frame_count;

          aac_frame->buf2_frame_info[aac_frame->buf2_frame_num].data_length =
              byte_num;

          aac_frame->buf2_frame_num += 1;
          aac_buf->buf2_space       -= byte_num;

          if (aac_buf->sync_samples > 0) {

            if ((frame_count - qdsp_cmd_mm_rec_frame_cnt_prev) > 1) {

              aac_frame->buf2_flush  = TRUE;
              aac_frame->buf2_avsync = TRUE;
              aac_frame->lost_frame2 = frame_count -
                  qdsp_cmd_mm_rec_frame_cnt_prev;
              aac_frame->sync_frame2 = frame_count;

              qdsp_cmd_mm_rec_frame_cnt_prev = frame_count;
              break;

            } else if (((frame_count - aac_buf->sync_frames) * 1028) >=
                        aac_buf->sync_samples) {

              aac_frame->buf2_flush  = TRUE;
              aac_frame->buf2_avsync = TRUE;
              aac_frame->lost_frame2 = 0;
              aac_frame->sync_frame2 = frame_count;

              qdsp_cmd_mm_rec_frame_cnt_prev = frame_count;
              break;
            }
        }

          if (aac_buf->buf2_space < sizeof(qdsp_cmd_aac_enc_frame_type)) {

            aac_frame->buf2_flush  = TRUE;
            aac_frame->buf2_avsync = FALSE;
            aac_frame->lost_frame2 = 0;
            break;
        }
        }
      } else {

        break;
      }
    } /* while */
        break;

      default:
        ret_val = FALSE;
    } /* end of switch (qdsp_cmd_image_select) */

  } else {
    ret_val = FALSE;
  }
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED || QDSP_IMAGE_AACENC_DEFINED */
#endif /* FEATURE_AAC_REC */

  if (ret_val == TRUE) {
    qdsp_cmd_mm_rec_update_read_count(qdsp_cmd_mm_rec_read_cnt);
  }

  return (ret_val);
}
#endif /* FEATURE_MM_REC */


/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_VOCODER_TIMING (command 0x0101)

DESCRIPTION
  This function will send a command to the DSP to command the DSP to start
  looking for the Vocoder Frame Reference Strobe and start encoding/decoding
  at the appropriate offsets.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_voc_timing (
  const qdsp_cmd_voc_timing_type *timing
)
{
  qdsp_cmd_status_type result;           /* Store the return value       */
  uint16 voc_timing_command[5];          /* Local buffer for the command */
  uint16 rx_budget;                      /* Store Rx Budget              */

  voc_timing_command[0] = VOC_TIMING_CMD_SIZE; /* Length of the command */
  voc_timing_command[1] = VOC_TIMING_CMD_HDR;  /* Command header        */
  voc_timing_command[2] = timing->enc_frame_offset;   /* ENC_FRAME_OFFSET */
  voc_timing_command[3] = timing->dec_frame_offset;   /* DEC_FRAME_OFFSET */
  voc_timing_command[4] = timing->dec_int_advance;    /* DEC_INT_ADVANCE  */

  /* Before the command is sent, verify DEC_INT_ADVANCE
     does not match Rx Budget */
  rx_budget = qdsp_read( QDSP_rxBudget );
  if ( timing->dec_int_advance == rx_budget )
  {
     ERR( "DEC_INT_ADVANCE matches Rx Budget = %d", rx_budget, 0, 0 );
     return( QDSP_CMD_FAILED );
  }

#ifdef MSMAUD_FAST_QDSP_CLOCK
  qdsp_write(QDSP_txMargin, 0x10);
#endif

  /* Now send the VOCODER Timing command to the QDSP2 */
  if( (result = qdsp2_command( voc_timing_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_ERROR("QDSP2 Vocoder Timing Command Error!", 0, 0, 0);
  }

  return( result );
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_VOCODER_FRAME_REFERENCE (DMA Type Writable Information)

DESCRIPTION
  This function will send a command to the DSP to perform a frame strobe.

DEPENDENCIES
  This command requests the DSP to behave as if a vocoder frame reference
  strobe (VFR) is received.  This command is used mainly for testing.
  The DSP will receive the fake vocoder frame reference strobe as if
  this interrupt was generated by the real hardware.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_voc_frame_reference ( void )
{

  qdsp_cmd_status_type result;             /* Store the return value       */

#ifdef MSMAUD_SUPPORTS_FRAME_REF_CMD
  uint16 voc_frame_reference_command[2];


  voc_frame_reference_command[0] = VOC_FRAME_REFERENCE_CMD_SIZE;
  voc_frame_reference_command[1] = VOC_FRAME_REFERENCE_CMD_HDR;
  /* Now send the VOCODER Frame Reference command to the QDSP2 */
  if( (result = qdsp2_command( voc_frame_reference_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_ERROR("QDSP2 Vocoder Frame Reference Command Error!", 0, 0, 0);
  }
#else
  /* Generating an "external request 1" interrupt to the DSP simulates a
  ** vocoder frame reference.  This is bit 1 in the INT_STATUS register.
  */
  qdsp_gen_interrupt(MSMAUD_FRAME_REF_INT_BIT);

  result = QDSP_CMD_SUCCESS;

#endif /* MSMAUD_SUPPORTS_FRAME_REF_CMD */

  return( result );

}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SLEEP (command 0x0002)

DESCRIPTION
  This function will send a command to the DSP to request the DSP to go to
  low power mode.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE state.
  DSP should stop the PCM DMA and put itself into SLEEP/INIT state.
  DSP keeps most of the audio front end module memory intact.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_sleep ( boolean aux_pcm_clk_enable )
{
#ifdef MSMAUD_PCM_DC_OFFSET
  qdsp_cmd_codec_gain_ctrl_type codec_gain;
#endif
  /* Local buffer for the command */
  word sleep_command[2]={SLEEP_CMD_SIZE, SLEEP_CMD_HDR};

  qdsp_cmd_status_type result;             /* Store the return value       */

  byte i;

  /* Reset the quarter rate count index. */
  qdsp_cmd_rate_index = 0;

  /* Reset the quarter rate enable flag. */
  qdsp_cmd_qrate_enable = FALSE;

  /* Reset array of quarter rate frames. */
  for (i=0;i<8;i++)
  {
    qdsp_cmd_rate_array[i] = QDSP_RATE_ERASURE_V;
  }

#ifdef MSMAUD_INIT_AUX_CODEC
  if (aux_pcm_clk_enable == TRUE)
  {
    MSMAUD_INIT_AUX_CODEC();
  }
  else if (qdsp_cmd_arm_ctrl_aux_pcm_clk == TRUE)
       {
         MSMAUD_INIT_CODEC();
       }

  qdsp_cmd_arm_ctrl_aux_pcm_clk = aux_pcm_clk_enable;
#endif

  /* overwrite codec gain to 0 before sleep command */
#ifdef MSMAUD_PCM_DC_OFFSET
  codec_gain.codec_tx_gain = 0;
  codec_gain.codec_rx_gain = 0;
  codec_gain.codec_st_gain = 0;
  qdsp_cmd_codec_gain_ctrl(&codec_gain, QDSP_CMD_CODEC_GAIN_FORCE_LOCK_WR);

  if (qdsp_cmd_codec_offset_inuse() == TRUE)
  {
    /* wait for 200us for DMA buffer to saturate */
    
    #if defined (FEATURE_CMI_MM) || !defined(FEATURE_CMI)
	clk_busy_wait(200);
    #else  
#error code not present
	#endif
  }
#endif  /* MSMAUD_PCM_DC_OFFSET */

#ifdef  MSMAUD_SCMM
#error code not present
#endif /* MSMAUD_SCMM */

  /* Now send the Sleep command to the QDSP2 */
  if( (result = qdsp2_command( sleep_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_HIGH("QDSP2 Vocoder Sleep Command Error!", 0, 0, 0);
  }

#ifdef MSMAUD_PCM_DC_OFFSET
  qdsp_cmd_codec_gain_ctrl(NULL, QDSP_CMD_CODEC_GAIN_UNLOCK_ALL_NOP);
#endif  /* MSMAUD_PCM_DC_OFFSET */


  return( result );
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_LOOPBACK_TEST (command 0x0005)

DESCRIPTION
  This function will send a command to the DSP to put the DSP into the
  loopback mode.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_loopback_test (
  uint16 lb_ctrl
)
{
     /* First Word   : LOOPBACK_CONTROL */
     /* DFM loopback enable */
     /* Packet loopback enable */
     /* PCM loopback enable */
     /* Audio loopback enable */

  qdsp_cmd_status_type result;             /* Store the return value       */

  uint16 loopback_test_command[3];         /* Local buffer for the command */

  loopback_test_command[0] = LOOPBACK_TEST_CMD_SIZE;
  /* Length of the command   */
  loopback_test_command[1] = LOOPBACK_TEST_CMD_HDR;
  /* Command header          */
  loopback_test_command[2] = lb_ctrl;
  /* LOOPBACK_CONTROL        */


  /* Now send the Loopback Test command to the QDSP2 */
  if( (result = qdsp2_command( loopback_test_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_ERROR("QDSP2 Vocoder Loopback Test Command Error!", 0, 0, 0);
  }
  return( result );
}

/* <EJECT> */
#ifdef FEATURE_UP_LOOPBACK_TEST
/*===========================================================================

FUNCTION QDSP_CMD_UP_PACKET_LOOPBACK (uP packet loopback)

DESCRIPTION
 This function enables or disables the microprocessor packet loopback
 interrupt service routine.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_up_packet_loopback ( boolean enable )
{
  qdsp_cmd_status_type result;             /* Store the return value       */

  if (enable==TRUE)
  {
    switch (qdsp_voc_mode)
    {
#if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) \
    || defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_HR)
#ifdef MSMAUD_VOC_FR
#error code not present
#endif
#ifdef MSMAUD_VOC_EFR
#error code not present
#endif
#ifdef MSMAUD_VOC_HR
      case QDSP_VOC_MODE_GSM_HR_V :
#endif
#ifdef MSMAUD_VOC_AMR
      case QDSP_VOC_MODE_AMR_V :
#endif
        qdsp_cmd_gsm_lb_taf_cnt = QDSP_GSM_LB_FIRST_TAF_FRAME;
        qdsp_cmd_set_isr( qdsp_cmd_gsm_up_packet_loopback_isr );
        break;
#endif  /* MSMAUD_VOC_AMR || MSMAUD_VOC_FR || MSMAUD_VOC_EFR || MSMAUD_VOC_HR */

#ifdef MSMAUD_VOC_AMR_WB
      case QDSP_VOC_MODE_AMR_WB_V :
        qdsp_cmd_set_isr( qdsp_cmd_amr_wb_up_packet_loopback_isr );
        break;
#endif  /* MSMAUD_VOC_AMR_WB */

#if defined(MSMAUD_VOC_1X_COMMON) || defined(MSMAUD_VOC_IS127_VOIP) || \
    defined(MSMAUD_VOC_4GV) || defined(MSMAUD_VOC_4GV_VOIP) || \
    defined(MSMAUD_VOC_4GV_WB) || defined(MSMAUD_VOC_4GV_WB_VOIP)
#ifdef MSMAUD_VOC_1X_COMMON
      case QDSP_VOC_MODE_IS733_V :
      case QDSP_VOC_MODE_IS127_V :
#endif
#ifdef MSMAUD_VOC_IS127_VOIP
      case QDSP_VOC_MODE_IS127_VOIP_V:
#endif
#ifdef MSMAUD_VOC_4GV
      case QDSP_VOC_MODE_4GV_V :
#endif
#ifdef MSMAUD_VOC_4GV_VOIP
#error code not present
#endif
#ifdef MSMAUD_VOC_4GV_WB
      case QDSP_VOC_MODE_4GV_WB_V :
#endif
#ifdef MSMAUD_VOC_4GV_WB_VOIP
      case QDSP_VOC_MODE_4GV_WB_VOIP_V :
#endif
        qdsp_cmd_set_isr( qdsp_cmd_up_packet_loopback_isr );
        break;
#endif  /* (MSMAUD_VOC_1X_COMMON) || (MSMAUD_VOC_IS127_VOIP) || \
                 (MSMAUD_VOC_4GV) || (MSMAUD_VOC_4GV_VOIP) || \
    defined(MSMAUD_VOC_4GV_WB) || defined(MSMAUD_VOC_4GV_WB_VOIP)*/


#ifdef MSMAUD_VOC_G711
      case QDSP_VOC_MODE_G711_V :
        qdsp_cmd_set_isr( qdsp_cmd_wlan_up_packet_loopback_isr );
        break;
#endif /* MSMAUD_VOC_G711 */

#if defined(QDSP_IMAGE_QVP_H263P3_G723_DEFINED) || \
    defined(QDSP_IMAGE_QVP_MPEG4_G723_DEFINED)
      case QDSP_VOC_MODE_G723_V :
        qdsp_cmd_set_isr( qdsp_cmd_wlan_up_packet_loopback_isr );
        break;
#endif /* defined(QDSP_IMAGE_QVP_H263P3_G723_DEFINED) ||
          defined(QDSP_IMAGE_QVP_MPEG4_G723_DEFINED)*/
    }
  }
  else
  {
    qdsp_cmd_set_isr(qdsp_cmd_image_isr_table[qdsp_cmd_image_select]);
  }

  result = QDSP_CMD_SUCCESS;

  return( result );
}

#endif  /* FEATURE_UP_LOOPBACK_TEST */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_IDLE (command 0x0007)

DESCRIPTION
  This function will send a command to the DSP to request the DSP to go to
  idle mode.

DEPENDENCIES
  This command is valid when the DSP is in Vocoder or DFM state.
  The microprocessor may need to clear rxVolume control register
  to mute the audio.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_idle ( void )
{
  /* Local buffer for the command */
  word idle_command[2]={IDLE_CMD_SIZE, IDLE_CMD_HDR};

  qdsp_cmd_status_type result;             /* Store the return value       */

  /* Now send the IDLE command to the QDSP2 */
  if( (result = qdsp2_command( idle_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_ERROR("QDSP2 Vocoder IDLE Command Error!", 0, 0, 0);
  }
  return( result );
}

/* <EJECT> */
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GET_DIAGS (DMA Type Readable Information)

DESCRIPTION
  This function reads the QDSP2 Diagnostic Data.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

void qdsp_cmd_get_diags (
  qdsp_cmd_diag_type *diag_data
)
{
  diag_data->qdsp_state  = (sint15) qdsp_read(QDSP_qdspState);
  diag_data->rom_version = qdsp_read(QDSP_romVersion);
#if QDSP_ramVersion_SIZE == 0
  diag_data->ram_version = *((uint16)QDSP_ramVersion);
#else
  diag_data->ram_version = qdsp_read(QDSP_ramVersion);
#endif
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GET_STATE (DMA Type Readable Information)

DESCRIPTION
  This function reads the QDSP2 State.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

sint15 qdsp_cmd_get_state ( void )
{

/* Read QDSP2 memory to fill in result to hold state values
*/

  sint15 result;             /* Store the return value       */

  switch(qdsp_cmd_image_select) {
#ifdef FEATURE_GRAPH_AUDIO
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */
#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */
#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_13K_DEFINED
    case QDSP_IMAGE_AUDDUB_13K:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_AUDDUB_13K_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_EVRC_DEFINED
    case QDSP_IMAGE_AUDDUB_EVRC:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_AUDDUB_EVRC_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_AMR_DEFINED
    case QDSP_IMAGE_AUDDUB_AMR:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_AUDDUB_AMR_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_AACENC_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
      result = (sint15) qdsp_read(QDSP_audioState);
      break;
#endif /* QDSP_IMAGE_QCAMCORDER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#endif /* FEATURE_GRAPH_AUDIO */

    default:
      result = (sint15) qdsp_read(QDSP_qdspState);
      break;
  }

  return( result );
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_ENC_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function sends encoder rate control parameters to the QDSP2 vocoder.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_enc_ctrl (
  const qdsp_cmd_enc_ctrl_type *rate_info
)
{
#ifdef MSMAUD_VOC_1X_COMMON
  qdsp_write(QDSP_reinitVocBNE, rate_info->reinit_bne);
  qdsp_write(QDSP_rateModulationCmd, rate_info->rate_modulation_cmd);
  qdsp_write(QDSP_reducedRateLevel, rate_info->reduced_rate_level);
#endif

  /* Save the minimum and maximum rate settings - to be set by the isr
  */
  qdsp_cmd_min_frame_rate = rate_info->enc_min_rate;
  qdsp_cmd_max_frame_rate = rate_info->enc_max_rate;

  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
#ifdef FEATURE_VOC_PACKET_INTERFACE
/*===========================================================================

FUNCTION QDSP_CMD_FRAME_RATE_CTRL

DESCRIPTION
  This function sends max and min encoder rate control parameters
  to the QDSP vocoder.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_frame_rate_ctrl (
  const qdsp_cmd_enc_ctrl_type *rate_info
)
{
  /* Save the minimum and maximum rate settings - to be set by the isr
  */
  qdsp_cmd_min_frame_rate = rate_info->enc_min_rate;
  qdsp_cmd_max_frame_rate = rate_info->enc_max_rate;

  qdsp_write(QDSP_encMaxRate, qdsp_cmd_max_frame_rate);
  qdsp_write(QDSP_encMinRate, qdsp_cmd_min_frame_rate);
  return QDSP_CMD_SUCCESS;
}
#endif /* FEATURE_VOC_PACKET_INTERFACE */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SAMPLE_SLIP_MODE (DMA Type Writable Information)

DESCRIPTION
  This function enables or disables the QDSP2 automatic sample slipping.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_sample_slip_mode (
  uint16 slip_mode
)
{
  /* Read Data containing automatic sample slipping switch values
     to fill in QDSP2 memory.
  */
  qdsp_write(QDSP_autoSampSlipSwitch, slip_mode);

  return QDSP_CMD_SUCCESS;

}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SAMPLE_SLIP_CTRL (command 0x0304)

DESCRIPTION

  This function sends command to the QDSP2 to manually advance or retard
  PCM clock by one cycle.

DEPENDENCIES

  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE

  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS

  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_sample_slip_ctrl (
  uint16 slip_ctrl
)
{
  qdsp_cmd_status_type result;             /* Store the return value       */

  /* First Word   : SAMPLE_SLIP_CONTROL */
  /* bit[2:1] : Manual Sample Slip */
  /* 10: sample slip, slow down the PCM speed */
  /* 11: sample retard, speed up the PCM speed */

  uint16 sample_slip_control_command[3];
  /* Local buffer for the command */

  sample_slip_control_command[0] = SAMPLE_SLIP_CONTROL_CMD_SIZE;
  /* Length of the command   */

  sample_slip_control_command[1] = SAMPLE_SLIP_CONTROL_CMD_HDR;
  /* Command header          */

  sample_slip_control_command[2] = slip_ctrl;
  /* SAMPLE_SLIP_CONTROL        */


  /* Now send the Sample Slip Control command to the QDSP2 */
  if( (result = qdsp2_command( sample_slip_control_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_ERROR("QDSP2 Vocoder Sample Slip Control Command Error!", 0, 0, 0);
  }
  return( result );
}

/* <EJECT> */

#if defined(MSMAUD_VOC_AMR_COMMON) || defined(MSMAUD_VOC_EFR) \
    || defined(MSMAUD_VOC_FR) || defined(MSMAUD_VOC_HR) \
    || defined(MSMAUD_VOC_AMR_WB_COMMON)

/*===========================================================================

FUNCTION qdsp_cmd_set_gsm_enc_dtx

DESCRIPTION
  This function switches encoder DTX mode on or off.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE, Vocoder.

RETURN VALUE
  QDSP_CMD_SUCCESS - The command was successful
  QDSP_CMD_FAILED  - The command failed...

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_gsm_enc_dtx
(
  qdsp_cmd_gsm_dtx_mode_type dtx_mode
)
{
 qdsp_write(QDSP_encDtxMode, (uint16)dtx_mode);


 return QDSP_CMD_SUCCESS;
}
#endif /* MSMAUD_VOC_AMR_COMMON || MSMAUD_VOC_EFR ||
          MSMAUD_VOC_FR || MSMAUD_VOC_HR || MSMAUD_VOC_AMR_WB_COMMON */


/* <EJECT> */
#ifdef MSMAUD_VOC_AMR_COMMON
/*===========================================================================

FUNCTION qdsp_cmd_set_amr_codec_mode

DESCRIPTION
  This function will configure the codec mode for the next AMR packet.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE, Vocoder.

RETURN VALUE
  QDSP_CMD_SUCCESS - The command was successful
  QDSP_CMD_FAILED  - The command failed...

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_amr_codec_mode
(
  qdsp_cmd_gsm_frame_rate_type amr_tx_rate
)
{
 if ((amr_tx_rate < QDSP_AMR_RATE_475) || (amr_tx_rate > QDSP_AMR_RATE_1220))
 {
  return QDSP_CMD_FAILED;
 }

 qdsp_write(QDSP_encCodecMode, ((uint16)amr_tx_rate & QDSP_AMR_CODEC_MODE_M));


 return QDSP_CMD_SUCCESS;
}
#endif /* MSMAUD_VOC_AMR_COMMON */

/* <EJECT> */
#ifdef MSMAUD_VOC_AMR_WB_COMMON
/*===========================================================================

FUNCTION qdsp_cmd_set_amr_wb_codec_mode

DESCRIPTION
  This function will configure the codec mode for the next AMR_WB packet.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE, Vocoder.

RETURN VALUE
  QDSP_CMD_SUCCESS - The command was successful
  QDSP_CMD_FAILED  - The command failed...

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_amr_wb_codec_mode
(
  qdsp_cmd_amr_wb_frame_rate_type amr_wb_tx_rate
)
{
 if ((amr_wb_tx_rate < QDSP_AMR_WB_RATE_0660)
     || (amr_wb_tx_rate > QDSP_AMR_WB_RATE_2385))
 {
  return QDSP_CMD_FAILED;
 }

 qdsp_write(QDSP_encCodecMode,
            ((uint16)amr_wb_tx_rate & QDSP_AMR_WB_CODEC_MODE_M));


 return QDSP_CMD_SUCCESS;
}
#endif /* MSMAUD_VOC_AMR_WB_COMMON */

/* <EJECT> */
#ifdef MSMAUD_VOC_G711
/*===========================================================================

FUNCTION qdsp_cmd_set_g711_mode

DESCRIPTION
  This function will configure the codec mode for the next G711 frame.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE, Vocoder.

RETURN VALUE
  QDSP_CMD_SUCCESS - The command was successful
  QDSP_CMD_FAILED  - The command failed...

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_g711_mode
(
  qdsp_cmd_g711_mode_type g711_mode
)
{
  if ((g711_mode < QDSP_G711_MODE_MULAW) || (g711_mode > QDSP_G711_MODE_ALAW)) {
    return(QDSP_CMD_FAILED);
  }

  qdsp_write(QDSP_encCodecMode, ((uint16)g711_mode));

  return(QDSP_CMD_SUCCESS);
}
#endif /* MSMAUD_VOC_G711 */

/* <EJECT> */
#ifdef MSMAUD_VOC_G723
/*===========================================================================

FUNCTION qdsp_cmd_set_g723_mode

DESCRIPTION
  This function will configure the codec mode for the next G723 frame.

DEPENDENCIES
  This command is only valid when the DSP is in IDLE, Vocoder.

RETURN VALUE
  QDSP_CMD_SUCCESS - The command was successful
  QDSP_CMD_FAILED  - The command failed...

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_g723_mode
(
  qdsp_cmd_g723_mode_type g723_mode
)
{
  if ((g723_mode & QDSP_CMD_G723_MODE_MASK) != g723_mode) {
    return(QDSP_CMD_FAILED);
  }

  qdsp_write(QDSP_encCodecMode, ((uint16)g723_mode));

  return(QDSP_CMD_SUCCESS);
}
#endif /* MSMAUD_VOC_G723 */

#ifdef FEATURE_GSM
#error code not present
#endif /* FEATURE_GSM */

#if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) || \
    defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_HR) || \
    defined(MSMAUD_VOC_1X_COMMON) ||defined(MSMAUD_VOC_4GV) || \
    defined(MSMAUD_VOC_4GV_VOIP) || defined(MSMAUD_VOC_IS127_VOIP) || \
    defined(MSMAUD_VOC_G711)
#ifdef FEATURE_AUDIO_QENSEMBLE
#error code not present
#endif /* FEATURE_AUDIO_QENSEMBLE */
#if defined(QDSP_IMAGE_VOC_COMBO_DEFINED) || \
	defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED) || \
	defined(QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED)
/*===========================================================================

FUNCTION QDSP_CMD_VOC_COMBO_IMAGE_ISR

DESCRIPTION
  This function de-multipexes 1X and UMTS modes and call the appropriate
  ISR handler.

DEPENDENCIES
  qdsp_voc_mode

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_voc_combo_image_isr (void)
{
  switch (qdsp_voc_mode) {
    #if defined(MSMAUD_VOC_1X_COMMON) || defined(MSMAUD_VOC_IS127_VOIP) || \
        defined(MSMAUD_VOC_4GV) || defined(MSMAUD_VOC_4GV_VOIP)
      #ifdef MSMAUD_VOC_1X_COMMON
      case QDSP_VOC_MODE_IS733_V :
      case QDSP_VOC_MODE_IS127_V :
      #endif
      #ifdef MSMAUD_VOC_IS127_VOIP
      case QDSP_VOC_MODE_IS127_VOIP_V:
      #endif
      #ifdef MSMAUD_VOC_4GV
      case QDSP_VOC_MODE_4GV_V :
      #endif
      #ifdef MSMAUD_VOC_4GV_VOIP
#error code not present
      #endif
      qdsp_cmd_voc_qdsp2_isr();
      break;
    #endif /* (MSMAUD_VOC_1X_COMMON) || (MSMAUD_VOC_IS127_VOIP) || \
                    (MSMAUD_VOC_4GV) ||(MSMAUD_VOC_4GV_VOIP)  */

    #ifdef MSMAUD_VOC_G711
      case QDSP_VOC_MODE_G711_V :
      qdsp_cmd_wlan_voc_isr();
      break;
    #endif /* (MSMAUD_VOC_G711) */

    #if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) || \
        defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_HR)
      #ifdef MSMAUD_VOC_FR
#error code not present
      #endif
      #ifdef MSMAUD_VOC_EFR
#error code not present
      #endif
      #ifdef MSMAUD_VOC_HR
      case QDSP_VOC_MODE_GSM_HR_V :
      #endif
      #ifdef MSMAUD_VOC_AMR
      case QDSP_VOC_MODE_AMR_V :
      #endif
      qdsp_cmd_gsm_voc_qdsp_isr();
      break;
    #endif  /* MSMAUD_VOC_AMR || MSMAUD_VOC_FR ||
             MSMAUD_VOC_EFR || MSMAUD_VOC_HR */
      default:
    #if defined(MSMAUD_VOC_1X_COMMON) || defined(MSMAUD_VOC_IS127_VOIP) || \
        defined(MSMAUD_VOC_4GV) || defined(MSMAUD_VOC_4GV_VOIP)
      qdsp_cmd_voc_qdsp2_isr();
    #elif defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) || \
        defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_HR)
      qdsp_cmd_gsm_voc_qdsp_isr();
    #else
    #error "Unsupported vocoder service"
    #endif /* MSMAUD_VOC_1X_COMMON */
      break;
  }

#ifdef FEATURE_AUDIO_QENSEMBLE
#error code not present
#endif /* FEATURE_AUDIO_QENSEMBLE */

}
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED ||
	      QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED ||
	      QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED */

#endif  /* MSMAUD_VOC_AMR || MSMAUD_VOC_FR ||
           MSMAUD_VOC_EFR || MSMAUD_VOC_HR  ||
           MSMAUD_VOC_1X_COMMON || MSMAUD_VOC_4GV
           MSMAUD_VOC_4GV_VOIP || MSMAUD_VOC_IS127_VOIP
           MSMAUD_VOC_G711 */

#if defined(FEATURE_AVS_INCALL_MIXER_CMX) && \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
/*===========================================================================

FUNCTION QDSP_CMD_VOC_COMBO_IMAGE_ISR

DESCRIPTION
  This function de-multipexes 1X and UMTS modes and call the appropriate
  ISR handler.

DEPENDENCIES
  qdsp_voc_mode

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_voc_combo_synth_isr (void)
{
  switch (qdsp_voc_mode) {
    #ifdef MSMAUD_VOC_1X_COMMON
    case QDSP_VOC_MODE_IS733_V :
    case QDSP_VOC_MODE_IS127_V :
      qdsp_cmd_voc_qdsp2_isr();
      qdsp_cmd_synth_qdsp2_isr();
      break;
    #endif /* MSMAUD_VOC_1X_COMMON */

    #if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) || \
        defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_HR)
      #ifdef MSMAUD_VOC_FR
#error code not present
      #endif
      #ifdef MSMAUD_VOC_EFR
#error code not present
      #endif
      #ifdef MSMAUD_VOC_HR
      case QDSP_VOC_MODE_GSM_HR_V :
      #endif
      #ifdef MSMAUD_VOC_AMR
      case QDSP_VOC_MODE_AMR_V :
      #endif
        qdsp_cmd_gsm_voc_qdsp_isr();
        qdsp_cmd_synth_qdsp2_isr();
        break;
    #endif  /* MSMAUD_VOC_AMR || MSMAUD_VOC_FR ||
             MSMAUD_VOC_EFR || MSMAUD_VOC_HR */
    default:
      break;
  }

#ifdef FEATURE_AUDIO_QENSEMBLE
#error code not present
#endif /* FEATURE_AUDIO_QENSEMBLE */

}
#endif /* FEATURE_AVS_INCALL_MIXER_CMX  &&
          QDSP_IMAGE_VOC_COMB_SNTH */
/* <EJECT> */

#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
/*===========================================================================

FUNCTION qdsp_cmd_voc_qtv_image_isr

DESCRIPTION
  This function de-multipexes 1X and UMTS modes and call the appropriate
  ISR handler.

DEPENDENCIES
  qdsp_voc_mode

RETURN VALUE
  None.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_voc_qtv_image_isr (void)
{
  switch (qdsp_voc_mode) {
    #if defined(MSMAUD_VOC_1X_COMMON) || defined(MSMAUD_VOC_IS127_VOIP) || \
        defined(MSMAUD_VOC_4GV) || defined(MSMAUD_VOC_4GV_VOIP)
      #ifdef MSMAUD_VOC_1X_COMMON
      case QDSP_VOC_MODE_IS733_V :
      case QDSP_VOC_MODE_IS127_V :
      #endif
      #ifdef MSMAUD_VOC_IS127_VOIP
      case QDSP_VOC_MODE_IS127_VOIP_V:
      #endif
      #ifdef MSMAUD_VOC_4GV
      case QDSP_VOC_MODE_4GV_V :
      #endif
      #ifdef MSMAUD_VOC_4GV_VOIP
#error code not present
      #endif
      qdsp_cmd_voc_qdsp2_isr();
      break;
    #endif /* (MSMAUD_VOC_1X_COMMON) || (MSMAUD_VOC_IS127_VOIP) || \
                    (MSMAUD_VOC_4GV) ||(MSMAUD_VOC_4GV_VOIP)  */

    #ifdef MSMAUD_VOC_G711
      case QDSP_VOC_MODE_G711_V :
      qdsp_cmd_wlan_voc_isr();
      break;
    #endif /* (MSMAUD_VOC_G711) */

    #if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) || \
        defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_HR)
      #ifdef MSMAUD_VOC_FR
#error code not present
      #endif
      #ifdef MSMAUD_VOC_EFR
#error code not present
      #endif
      #ifdef MSMAUD_VOC_HR
      case QDSP_VOC_MODE_GSM_HR_V :
      #endif
      #ifdef MSMAUD_VOC_AMR
      case QDSP_VOC_MODE_AMR_V :
      #endif
      qdsp_cmd_gsm_voc_qdsp_isr();
      break;
    #endif  /* MSMAUD_VOC_AMR || MSMAUD_VOC_FR ||
             MSMAUD_VOC_EFR || MSMAUD_VOC_HR */
      default:
    #ifdef MSMAUD_VOC_1X_COMMON
      qdsp_cmd_voc_qdsp2_isr();
    #endif
      break;
  }
}
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */
/*===========================================================================

FUNCTION QDSP_CMD_VOL_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function controls the QDSP2 rx and tx volume and muting.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_vol_ctrl (
  const qdsp_cmd_vol_ctrl_type *vol_set
)
{
  uint16 rx_mute_v = QDSP_RX_MUTE_ENA_V;

  switch(vol_set->rx_mute)
  {
  case QDSP_RX_MUTE_CONDITIONAL_V:
    rx_mute_v = QDSP_RX_MUTE_ENA_V;

#ifdef FEATURE_AVS_VOC_DTMF_MIXING
    switch( qdsp_cmd_image_select )
    {
#if defined(QDSP_IMAGE_AMR_DEFINED)             || \
    defined(QDSP_IMAGE_AMR_WB_DEFINED)          || \
    defined(QDSP_IMAGE_EFR_DEFINED)             || \
    defined(QDSP_IMAGE_FR_DEFINED)              || \
    defined(QDSP_IMAGE_HR_DEFINED)              || \
    defined(QDSP_IMAGE_VOC_DEFINED)             || \
    defined(QDSP_IMAGE_VOC_EVRC_DEFINED)        || \
    defined(QDSP_IMAGE_VOC_QTV_DEFINED)         || \
    defined(QDSP_IMAGE_VOC_COMBO_DEFINED)       || \
    defined(QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED)  || \
    defined(QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED)   || \
    defined(QDSP_IMAGE_QVP_H263P3_AMR_DEFINED)  || \
    defined(QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED)  || \
    defined(QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED) || \
    defined (QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED)  || \
    defined (QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED) || \
    defined(QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED)	|| \
    defined(QDSP_IMAGE_G711_DEFINED)
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_AMR_DEFINED
    case QDSP_IMAGE_QVP_H263P3_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED
    case QDSP_IMAGE_QVP_H263P3_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_G711_DEFINED
    case QDSP_IMAGE_G711:
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED
    case QDSP_IMAGE_QCAMCORDER_COMBO:
#endif
      if(qdsp_cmd_dtmf_mixing_enabled) {
        rx_mute_v = QDSP_RX_MUTE_DIS_V;
      } else {
        rx_mute_v = QDSP_RX_MUTE_ENA_V;
      }
      break;
#endif
    default:
      rx_mute_v = QDSP_RX_MUTE_ENA_V;
      break;
    }
#endif /* FEATURE_AVS_VOC_DTMF_MIXING */
    break;
  case QDSP_RX_MUTE_ENA_V:
    rx_mute_v = QDSP_RX_MUTE_ENA_V;
    break;
  case QDSP_RX_MUTE_DIS_V:
    rx_mute_v = QDSP_RX_MUTE_DIS_V;
    break;
  default:
    break;
  }

  MSG_HIGH("qdsp rx_volume = %d, mute = %d",
                                  vol_set->rx_vol, rx_mute_v, 0);

#ifdef FEATURE_NO_TX_COMFORT_NOISE
  if((vol_set->tx_comfort_noise_ena == QDSP_COMFORT_NOISE_ENA_V) &&
     ((qdsp_voc_mode == QDSP_VOC_MODE_GSM_FR_V) ||
      (qdsp_voc_mode == QDSP_VOC_MODE_GSM_EFR_V) ||
      (qdsp_voc_mode == QDSP_VOC_MODE_AMR_V) ||
      (qdsp_voc_mode == QDSP_VOC_MODE_GSM_HR_V))) {
    qdsp_cmd_mute_tx = TRUE;
  } else {
    qdsp_cmd_mute_tx = FALSE;
  }
  /* Save TX vol for restore later */
  qdsp_cmd_tx_volume = vol_set->tx_vol;
#endif /* FEATURE_NO_TX_COMFORT_NOISE */


  switch(qdsp_cmd_image_select) {
#ifdef FEATURE_QTUNES_COMMON
#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
    case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif
#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
    case QDSP_IMAGE_MP4D_AAC_PLUS:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif
#ifdef QDSP_IMAGE_RA_DEFINED
    case QDSP_IMAGE_RA:
#endif
#ifdef QDSP_IMAGE_WM_DEFINED
    case QDSP_IMAGE_WM:
#endif /* QDSP_IMAGE_WM_DEFINED */
#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_WM_PRO_DEFINED */
#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif
#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
    case QDSP_IMAGE_H263D_MP3:
#endif
#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif
#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
    case QDSP_IMAGE_QTV_AAC:
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */
#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */
      qdsp_write(QDSP_rxVolume, 0x4000);
      break;
#endif /* FEATURE_QTUNES_COMMON */

#ifdef FEATURE_GRAPH_AUDIO
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, 0);
      break;
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */

#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, 0);
      break;
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */

#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, 0);
      break;
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */

#ifdef QDSP_IMAGE_MP4D_DEFINED
    case QDSP_IMAGE_MP4D:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      break;
#endif /* QDSP_IMAGE_MP4D_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AMR_DEFINED
    case QDSP_IMAGE_MP4D_AMR:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      break;
#endif /* QDSP_IMAGE_MP4D_AMR_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED
    case QDSP_IMAGE_MP4D_AMR_EVRC_V13K:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      break;
#endif /* QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED */

#ifdef QDSP_IMAGE_QTV_DEFINED
    case QDSP_IMAGE_QTV:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      break;
#endif /* QDSP_IMAGE_QTV_DEFINED */

#ifdef QDSP_IMAGE_QTV_VOC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_DEFINED */

#ifdef QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED */

#ifdef QDSP_IMAGE_H263D_DEFINED
    case QDSP_IMAGE_H263D:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      break;
#endif /* QDSP_IMAGE_H263D_DEFINED */

#ifdef QDSP_IMAGE_H263D_AMR_DEFINED
    case QDSP_IMAGE_H263D_AMR:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      break;
#endif /* QDSP_IMAGE_H263D_AMR_DEFINED */

#ifdef QDSP_IMAGE_QVP_MPEG4_G723_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_G723:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_QVP_MPEG4_G723_DEFINED */

#ifdef QDSP_IMAGE_QVP_H263P3_G723_DEFINED
    case QDSP_IMAGE_QVP_H263P3_G723:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_QVP_H263P3_G723_DEFINED */

#ifdef QDSP_IMAGE_H264D_AMR_DEFINED
    case QDSP_IMAGE_H264D_AMR:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      break;
#endif /* QDSP_IMAGE_H264D_AMR_DEFINED */

#ifdef QDSP_IMAGE_H264D_EVRC_DEFINED
#error code not present
#endif /* QDSP_IMAGE_H264D_EVRC_DEFINED */

#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, 0);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_MP4E_DEFINED */

#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, 0);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */

#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, 0);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, 0);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, 0);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, 0);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_QCAMCORDER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_13K_DEFINED
    case QDSP_IMAGE_AUDDUB_13K:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_AUDDUB_13K_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_EVRC_DEFINED
    case QDSP_IMAGE_AUDDUB_EVRC:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_AUDDUB_EVRC_DEFINED */
#ifdef QDSP_IMAGE_AUDDUB_AMR_DEFINED
    case QDSP_IMAGE_AUDDUB_AMR:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_AUDDUB_AMR_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */
#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_AACENC_DEFINED */
#ifdef QDSP_IMAGE_I2SSBC_DEFINED
    case QDSP_IMAGE_I2SSBC:
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);
      break;
#endif /* QDSP_IMAGE_I2SSBC_DEFINED */
#endif /* FEATURE_GRAPH_AUDIO */

#if defined(FEATURE_AVS_INCALL_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB)
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif /* QDSP_IMAGE_AMR_MP3_DEFINED */
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif /* QDSP_IMAGE_HR_MP3_DEFINED */
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif /* QDSP_IMAGE_EFR_MP3_DEFINED */
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif /* QDSP_IMAGE_FR_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */

      if ((qdsp_cmd_adec_int_cb_ptr  != NULL) &&
#ifdef FEATURE_AVS_INCALL_ADEC_PB
          (qdsp_cmd_get_state()      == QDSP_STATE_ADEC_VOC) &&
#endif /* FEATURE_AVS_INCALL_ADEC_PB */
#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
          (qdsp_cmd_get_state()      == QDSP_STATE_VOCODER) &&
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB */
          (qdsp_cmd_get_adec_state() == QDSP_STATE_TUNES)) {
        qdsp_write(QDSP_masterVolume, 0x2000);
      }
      /* Fall through */
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB */

    default:
      qdsp_write(QDSP_rxVolume, vol_set->rx_vol);
      qdsp_write(QDSP_rxMute, rx_mute_v);
      qdsp_write(QDSP_txVolume, vol_set->tx_vol);

#ifdef FEATURE_VOC_ADPCM
      if (qdsp_cmd_voc_adpcm_is_supported()) {
        qdsp_write(QDSP_adpcmcodecRxGain, vol_set->rx_vol);
      }
#endif

#if defined (FEATURE_PHONE_VR) || defined (FEATURE_VOICE_RECORD)
      qdsp_cmd_tx_comfort_noise = vol_set->tx_comfort_noise_ena;

      if (
#ifdef FEATURE_VOICE_RECORD
           ((qdsp_cmd_rec_dir == QDSP_CMD_REC_FORWARD) ||
            (qdsp_cmd_rec_dir == QDSP_CMD_REC_NONE))
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
#endif /* FEATURE_VOICE_RECORD */

#if defined (FEATURE_PHONE_VR) && defined (FEATURE_VOICE_RECORD)
           /* If both features are defined AND both statements together */
           &&
#endif /* FEATURE_PHONE_VR && FEATURE_VOICE_RECORD */

#ifdef FEATURE_PHONE_VR
           (qdsp_cmd_vr_utterance_capture == FALSE)
#endif /* FEATURE_PHONE_VR */
        )
#endif /* (FEATURE_PHONE_VR) || (FEATURE_VOICE_RECORD) */
      {
#ifdef FEATURE_NO_TX_COMFORT_NOISE
        if(qdsp_cmd_mute_tx == TRUE) {
          qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
          qdsp_write(QDSP_txVolume, QDSP_TX_MUTE_GAIN);
        } else
#endif /* FEATURE_NO_TX_COMFORT_NOISE */
#ifdef FEATURE_VOICE_PLAYBACK
        if (qdsp_cmd_vp_incall_mux)
        {
          qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
        }
        else
#endif /* FEATURE_VOICE_PLAYBACK */
        {
          qdsp_write(QDSP_txComfortNoiseEnable, vol_set->tx_comfort_noise_ena);
        }
      }
      break;
  }
  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
#ifdef MSMAUD_PCM_DC_OFFSET
/*===========================================================================

FUNCTION QDSP_CMD_CODEC_OFFSET_INUSE

DESCRIPTION
  This function checks if PCM offset compensation is in effect.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  boolean

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_codec_offset_inuse(void)
{
  boolean status = FALSE;


#if defined(QDSP_codecRxOffsetL)
  if ((uint32*)QDSP_codecRxOffsetL != QDSP_NOP_ADDRESS)
  {
    if (qdsp_read(QDSP_codecRxOffsetL) != 0)
    {
      status = TRUE;
    }
  }
#endif

#if defined(QDSP_codecRxOffsetR)
  if ((uint32*)QDSP_codecRxOffsetR != QDSP_NOP_ADDRESS)
  {
    if (qdsp_read(QDSP_codecRxOffsetR) != 0)
    {
      status = TRUE;
    }
  }
#endif

#if defined(QDSP_midiCodecRxOffsetL)
  if ((uint32*)QDSP_midiCodecRxOffsetL != QDSP_NOP_ADDRESS)
  {
    if (qdsp_read(QDSP_midiCodecRxOffsetL) != 0)
    {
      status = TRUE;
    }
  }
#endif

#if defined(QDSP_midiCodecRxOffsetR)
  if ((uint32*)QDSP_midiCodecRxOffsetR != QDSP_NOP_ADDRESS)
  {
    if (qdsp_read(QDSP_midiCodecRxOffsetR) != 0)
    {
      status = TRUE;
    }
  }
#endif


  return status;
}


/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_CODEC_OFFSET_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function controls the QDSP2 internal codec offset.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_codec_offset_ctrl (
  const qdsp_cmd_codec_offset_ctrl_type *codec_offset
)
{
  qdsp_cmd_status_type status = QDSP_CMD_FAILED;


#if defined(QDSP_codecRxOffsetL)
  if ((uint32*)QDSP_codecRxOffsetL != QDSP_NOP_ADDRESS)
  {
    qdsp_write(QDSP_codecRxOffsetL, codec_offset->codec_rxL_offset);
    status = QDSP_CMD_SUCCESS;
  }
#endif

#if defined(QDSP_codecRxOffsetR)
  if ((uint32*)QDSP_codecRxOffsetR != QDSP_NOP_ADDRESS)
  {
    qdsp_write(QDSP_codecRxOffsetR, codec_offset->codec_rxR_offset);
    status = QDSP_CMD_SUCCESS;
  }
#endif

#if defined(QDSP_midiCodecRxOffsetL)
  if ((uint32*)QDSP_midiCodecRxOffsetL != QDSP_NOP_ADDRESS)
  {
    qdsp_write(QDSP_midiCodecRxOffsetL, codec_offset->codec_rxL_offset);
    status = QDSP_CMD_SUCCESS;
  }
#endif

#if defined(QDSP_midiCodecRxOffsetR)
  if ((uint32*)QDSP_midiCodecRxOffsetR != QDSP_NOP_ADDRESS)
  {
    qdsp_write(QDSP_midiCodecRxOffsetR, codec_offset->codec_rxR_offset);
    status = QDSP_CMD_SUCCESS;
  }
#endif


  if (status != QDSP_CMD_SUCCESS)
  {
    MSG_HIGH("Warning: codec offset not supported in image %d",  \
             qdsp_cmd_image_select, 0, 0);
  }

  return status;
}

#endif  /* MSMAUD_PCM_DC_OFFSET */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_CODEC_GAIN_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function controls the QDSP2 internal codec gain.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_codec_gain_ctrl (
  const qdsp_cmd_codec_gain_ctrl_type *codec_set,
  qdsp_cmd_codec_gain_ctrl_lock_type lock
)
{
  static uint32 mutex = 0;
  uint32 isave;
  uint16 codecRxGain;
  qdsp_cmd_vol_ctrl_type *vol_ctrl;

  INTLOCK_SAV(isave);

  switch (lock)
  {
    case QDSP_CMD_CODEC_GAIN_LOCK_NOP:
      mutex++;
      INTFREE_SAV(isave);
      return QDSP_CMD_SUCCESS;

    case QDSP_CMD_CODEC_GAIN_UNLOCK_NOP:
      mutex = (mutex>0)? mutex-1 : 0;
      INTFREE_SAV(isave);
      return QDSP_CMD_SUCCESS;

    case QDSP_CMD_CODEC_GAIN_LOCK_WR:
      if (mutex>0)
      {
        MSG_HIGH("Concurrency: codec gain control locked %d", mutex, 0, 0);
        INTFREE_SAV(isave);
        return QDSP_CMD_FAILED;
      }

      mutex++;
      break;

    case QDSP_CMD_CODEC_GAIN_UNLOCK_WR:
      if (mutex>1)
      {
        MSG_HIGH("Concurrency: codec gain control locked %d", mutex, 0, 0);
        INTFREE_SAV(isave);
        return QDSP_CMD_FAILED;
      }

      mutex = 0;
      break;

    case QDSP_CMD_CODEC_GAIN_FORCE_LOCK_WR:
      mutex++;
      break;

    case QDSP_CMD_CODEC_GAIN_UNLOCK_ALL_WR:
      mutex = 0;
      break;

    case QDSP_CMD_CODEC_GAIN_UNLOCK_ALL_NOP:
      mutex = 0;
      INTFREE_SAV(isave);
      return QDSP_CMD_SUCCESS;

    case QDSP_CMD_CODEC_GAIN_OP_NORMAL:
    default:
      if (mutex>0)
      {
        MSG_HIGH("Concurrency: codec gain control locked %d", mutex, 0, 0);
        INTFREE_SAV(isave);
        return QDSP_CMD_FAILED;
      }
      break;
  }

  MSG_HIGH("codec TxGain = %d, codec RxGain = %d, codec STGain = %d",
  codec_set->codec_tx_gain,codec_set->codec_rx_gain,codec_set->codec_st_gain);

  if(codec_set->codec_rx_gain != 0)
  {
    codecRxGain = 0;
    do
    {
      qdsp_write(QDSP_codecRxGain, codecRxGain);
      codecRxGain += qdsp_deltaRxGain;
    }while(codecRxGain < codec_set->codec_rx_gain && qdsp_deltaRxGain!=0);

    MSG_HIGH("CodecRxGain increase in step:%d",qdsp_deltaRxGain,0,0);
  }

  switch(qdsp_cmd_image_select) {
#ifdef FEATURE_GRAPH_AUDIO
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */

#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */

#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */

#ifdef QDSP_IMAGE_MP4D_DEFINED
    case QDSP_IMAGE_MP4D:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4D_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AMR_DEFINED
    case QDSP_IMAGE_MP4D_AMR:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4D_AMR_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED
    case QDSP_IMAGE_MP4D_AMR_EVRC_V13K:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED */

#ifdef QDSP_IMAGE_QTV_DEFINED
    case QDSP_IMAGE_QTV:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_QTV_DEFINED */

#ifdef QDSP_IMAGE_QTV_VOC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_DEFINED */

#ifdef QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED */

#ifdef QDSP_IMAGE_H263D_DEFINED
    case QDSP_IMAGE_H263D:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_H263D_DEFINED */

#ifdef QDSP_IMAGE_H263D_AMR_DEFINED
    case QDSP_IMAGE_H263D_AMR:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_H263D_AMR_DEFINED */

#ifdef QDSP_IMAGE_H264D_AMR_DEFINED
    case QDSP_IMAGE_H264D_AMR:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_H264D_AMR_DEFINED */

#ifdef QDSP_IMAGE_H264D_EVRC_DEFINED
#error code not present
#endif /* QDSP_IMAGE_H264D_EVRC_DEFINED */

#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4E_DEFINED */

#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */

#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */

#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */

#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */

#ifdef QDSP_IMAGE_AUDDUB_13K_DEFINED
    case QDSP_IMAGE_AUDDUB_13K:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_AUDDUB_13K_DEFINED */

#ifdef QDSP_IMAGE_AUDDUB_EVRC_DEFINED
    case QDSP_IMAGE_AUDDUB_EVRC:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_AUDDUB_EVRC_DEFINED */

#ifdef QDSP_IMAGE_AUDDUB_AMR_DEFINED
    case QDSP_IMAGE_AUDDUB_AMR:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_AUDDUB_AMR_DEFINED */

#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */

#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_AACENC_DEFINED */

#endif /* FEATURE_GRAPH_AUDIO */

#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */

#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_TUNES_DEFINED */

#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
   case QDSP_IMAGE_CAM_AUDIO_CONC:
     qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
     break;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */

#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_AAC_DEFINED */

#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */

#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */

#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */

#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */

#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED */

#ifdef QDSP_IMAGE_QSYNTH_DEFINED
    case QDSP_IMAGE_QSYNTH:
      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
#endif /* QDSP_IMAGE_QSYNTH_DEFINED */

#ifdef QDSP_IMAGE_QTV_CONC_DEFINED
    case QDSP_IMAGE_QTV_CONC:
#if defined(QDSP_codecRxGainPtr) && defined(QDSP_codecRxGainPtrMSW)
      /* The codecRxGain has a unique address for each DSP decoder
      ** implementation; it is used in vocoder and ADEC contexts for
      ** concurrent images. codecRxGainPtr and codecRxGainPtrMSW
      ** combined, forms an address when dereferenced, returns a
      ** relative offset from codecRxGainPtr to the instance of
      ** codecRxGain currently used by the DSP.
      */
      if(((uint32*) QDSP_codecRxGainPtr != QDSP_NOP_ADDRESS) &&
         ((uint32*) QDSP_codecRxGainPtrMSW != QDSP_NOP_ADDRESS)) {
#if (QDSP_codecRxGainPtr_SIZE == 16)
        qdsp_write((uint16*)
                   (((uint32)QDSP_codecRxGainPtr) +
                    ((qdsp_read(QDSP_codecRxGainPtrMSW) <<
                      QDSP_codecRxGainPtr_SIZE) |
                     qdsp_read(QDSP_codecRxGainPtr))),
                   codec_set->codec_rx_gain);
#else
#error Unsupported memory write data width!
#endif /* (QDSP_codecRxGainPtr_SIZE == 16) */
      } else
#endif /* QDSP_codecRxGainPtr && QDSP_codecRxGainPtrMSW */
      {
        qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      }
      break;
#endif /* QDSP_IMAGE_QTV_CONC_DEFINED */

    default:
      qdsp_write(QDSP_codecTxGain, codec_set->codec_tx_gain);

#ifdef FEATURE_VOC_ADPCM
      if (qdsp_cmd_voc_adpcm_is_supported())
      {
        /* updating adpcmCodecRxGain with current volume level */
        vol_ctrl = voc_data_get_volume(VOC_DATA_NORM_VOL);
        qdsp_write(QDSP_adpcmcodecRxGain, vol_ctrl->rx_vol);
      }
#endif

      /* Checks if sidetone is disabled */
      if(qdsp_cmd_sidetone_enable == FALSE)
      {
        qdsp_write(QDSP_codecSTGain, QDSP_SIDETONE_DIS_V);
      }
      else if(qdsp_cmd_sidetone_enable == TRUE)
      {
        qdsp_write(QDSP_codecSTGain, codec_set->codec_st_gain);
      }

      qdsp_write(QDSP_codecRxGain, codec_set->codec_rx_gain);
      break;
  }

  INTFREE_SAV(isave);

  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
#ifdef FEATURE_AUDIO_AGC
/*===========================================================================

FUNCTION QDSP_CMD_AGC_CONFIG (DMA Type Writable Information)

DESCRIPTION
  This function sets the QDSP2 AGC parameters.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_agc_config (
  const qdsp_cmd_agc_config_type *data
)
{
  /*
  ** Read Data structure containing values for AGC Configuration Command
     to fill in QDSP2 memory
  */


  qdsp_write(QDSP_rxAgcEnableFlag, data->rx_agc_enable);
  qdsp_write(QDSP_rxAvcEnableFlag, data->rx_avc_enable);
  qdsp_write(QDSP_txAgcEnableFlag, data->tx_agc_enable);

  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_AGC_PARAM (DMA Type Writable Information)

DESCRIPTION
  This function sets the QDSP2 AGC parameters.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_agc_param (
  const qdsp_cmd_agc_param_type *data
)
{
  /*
  ** Read Data structure containing values for AGC parameters Command
     to fill in QDSP2 memory
  */
  qdsp_write(QDSP_compFlinkStaticGain, data->rx_agc_static_gain);
  qdsp_write(QDSP_compFlinkAIGFlag, data->rx_agc_aig);
  qdsp_write(QDSP_expFlinkThreshold, data->rx_agc_exp_thres);
  qdsp_write(QDSP_expFlinkSlope, data->rx_agc_exp_slope);
  qdsp_write(QDSP_compFlinkThreshold, data->rx_agc_compr_thres);
  qdsp_write(QDSP_compFlinkSlope, data->rx_agc_compr_slope);
  qdsp_write(QDSP_avcRlinkSensitivityOffset, data->rx_avc_sensitivity);
  qdsp_write(QDSP_avcFlinkHeadroom, data->rx_avc_headroom);
  qdsp_write(QDSP_compRlinkStaticGain, data->tx_agc_static_gain);
  qdsp_write(QDSP_compRlinkAIGFlag, data->tx_agc_aig);
  qdsp_write(QDSP_expRlinkThreshold, data->tx_agc_exp_thres);
  qdsp_write(QDSP_expRlinkSlope, data->tx_agc_exp_slope);
  qdsp_write(QDSP_compRlinkThreshold, data->tx_agc_compr_thres);
  qdsp_write(QDSP_compRlinkSlope, data->tx_agc_compr_slope);

  return QDSP_CMD_SUCCESS;
}
#endif /* FEATURE_AUDIO_AGC */

/* <EJECT>  */

/*===========================================================================

  FUNCTION qdsp_cmd_rve_is_supported

  DESCRIPTION

  	This function checks whether RVE support is available or not.

  DEPENDENCIES
  	None

  RETURN VALUE
  	A value of qdsp_cmd_status_type indicating whether the RVE is present
        in firmware or not.

 ===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_rve_is_supported( void )
{
#if defined( QDSP_rxRveEnableflag )
    return QDSP_CMD_SUCCESS;
#else
    return QDSP_CMD_FAILED;
#endif
}

/* <EJECT> */

/*===========================================================================

FUNCTION QDSP_CMD_RVE_CONFIG (DMA Type Writable Information)

DESCRIPTION
  This function sets the QDSP2 RVE parameters.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_rve_config (
  const qdsp_cmd_rve_config_type *data
)
{
#if defined( QDSP_rxRveEnableflag )
  /*
  ** Read Data structure containing values for RVE Configuration Command
     to fill in QDSP2 memory
  */

  qdsp_write(QDSP_rxRveEnableflag, data->rx_rve_enable);

#endif
  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_RVE_PARAM (DMA Type Writable Information)

DESCRIPTION
  This function sets the QDSP2 RVE SINGLE  parameters.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_rve_param (
  const qdsp_cmd_rve_param_type *data
)
{
#if defined( QDSP_rxRveEnableflag )
  /*
  ** Read Data structure containing values for RVE parameters Command
     to fill in QDSP2 memory
  */
 qdsp_write(QDSP_smAlphaNoise, data->rx_rve_sm_alpha_noise );
 qdsp_write(QDSP_smAlphaRef , data->rx_rve_sm_alpha_ref );
 qdsp_write(QDSP_smAlphaRec , data->rx_rve_sm_alpha_rec );
 qdsp_write(QDSP_smAlphaGainIncrease, data->rx_rve_sm_alpha_gain_increase );
 qdsp_write(QDSP_smAlphaGainDecrease, data->rx_rve_sm_alpha_gain_decrease );
 qdsp_write(QDSP_smAlphaAmp , data->rx_rve_sm_alpha_amp );
 qdsp_write(QDSP_smAlphaPLAttack ,data->rx_rve_sm_alpha_plattack );
 qdsp_write(QDSP_smAlphaPLDecay , data->rx_rve_sm_alpha_pldecay );
 qdsp_write(QDSP_lowGainLimit , data->rx_rve_low_gain_limit );
 qdsp_write(QDSP_headroom , data->rx_rve_headroom );
 qdsp_write(QDSP_dshift , data->rx_rve_dshift );
 qdsp_write(QDSP_hfDshift , data->rx_rve_hf_dshift );
 qdsp_write(QDSP_scaleFact1 , data->rx_rve_scale_fact1 );
 qdsp_write(QDSP_scaleFact2 ,data->rx_rve_scale_fact2 );
 qdsp_write(QDSP_peakLim , data->rx_rve_peak_lim );
 qdsp_write(QDSP_hardPeakLim, data->rx_rve_hard_peak_lim );
 qdsp_block_write(QDSP_noiseSensThresh, 0, data->rx_rve_noise_sens_thresh, 4, FALSE);
 qdsp_block_write(QDSP_gainMultVector, 0,  data->rx_rve_gain_mult_vector, 4, FALSE );
 qdsp_write(QDSP_upperOutLim , data->rx_rve_upper_out_lim);
 qdsp_write(QDSP_opMode , data->rx_rve_op_mode);
 qdsp_write(QDSP_aeqVadThreshold, data->rx_rve_aeqVadThreshold);
 qdsp_write(QDSP_refVadHangoverMax, data->rx_rve_refVadHangoverMax);

#endif

 return QDSP_CMD_SUCCESS;
}

/*===========================================================================

FUNCTION QDSP_CMD_SINGLE_RVE_PARAM (DMA Type Writable Information)

DESCRIPTION
  This function sets the QDSP2 RVE DUAL MIC parameters.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_dual_rve_param (
  const qdsp_cmd_dual_rve_param_type *data
)
{

#if defined( QDSP_rxRveEnableflag )
  /*
  ** Read Data structure containing values for RVE parameters Command
     to fill in QDSP2 memory
  */
 qdsp_write(QDSP_smAlphaNoise, data->rx_dual_rve_sm_alpha_noise );
 qdsp_write(QDSP_smAlphaRef , data->rx_dual_rve_sm_alpha_ref );
 qdsp_write(QDSP_smAlphaRec , data->rx_dual_rve_sm_alpha_rec );
 qdsp_write(QDSP_smAlphaGainIncrease, data->rx_dual_rve_sm_alpha_gain_increase );
 qdsp_write(QDSP_smAlphaGainDecrease, data->rx_dual_rve_sm_alpha_gain_decrease );
 qdsp_write(QDSP_smAlphaAmp , data->rx_dual_rve_sm_alpha_amp );
 qdsp_write(QDSP_smAlphaPLAttack ,data->rx_dual_rve_sm_alpha_plattack );
 qdsp_write(QDSP_smAlphaPLDecay , data->rx_dual_rve_sm_alpha_pldecay );
 qdsp_write(QDSP_lowGainLimit , data->rx_dual_rve_low_gain_limit );
 qdsp_write(QDSP_headroom , data->rx_dual_rve_headroom );
 qdsp_write(QDSP_dshift , data->rx_dual_rve_dshift );
 qdsp_write(QDSP_hfDshift , data->rx_dual_rve_hf_dshift );
 qdsp_write(QDSP_scaleFact1 , data->rx_dual_rve_scale_fact1 );
 qdsp_write(QDSP_scaleFact2 ,data->rx_dual_rve_scale_fact2 );
 qdsp_write(QDSP_peakLim , data->rx_dual_rve_peak_lim );
 qdsp_write(QDSP_hardPeakLim, data->rx_dual_rve_hard_peak_lim );
 qdsp_block_write(QDSP_noiseSensThresh, 0, data->rx_dual_rve_noise_sens_thresh, 4, FALSE);
 qdsp_block_write(QDSP_gainMultVector, 0,  data->rx_dual_rve_gain_mult_vector, 4, FALSE );
 qdsp_write(QDSP_upperOutLim , data->rx_dual_rve_upper_out_lim);
 qdsp_write(QDSP_opMode , data->rx_dual_rve_op_mode);
 qdsp_write(QDSP_aeqVadThreshold, data->rx_rve_aeqVadThreshold);
 qdsp_write(QDSP_refVadHangoverMax, data->rx_rve_refVadHangoverMax);

#endif

 return QDSP_CMD_SUCCESS;
}


/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GET_EC_GEN_ID (DMA Type Writable Information)

DESCRIPTION
  This function gets EC generation ID.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  qdsp_cmd_ec_gen_id_type

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_ec_gen_id_type qdsp_cmd_get_ec_gen_id(void)
{
  uint16 ec_gen_id;


#ifdef QDSP_uPCrystalSpeechOrEcns
  if ((uint32*)QDSP_uPCrystalSpeechOrEcns != QDSP_NOP_ADDRESS)
  {
    ec_gen_id = qdsp_read(QDSP_uPCrystalSpeechOrEcns);

#ifdef FEATURE_AVS_CRYSTAL_SPEECH
    if (ec_gen_id==0xffff)
    {
      return QDSP_CMD_EC_GEN_CRYSTAL_SPEECH;
    }
#endif  /* FEATURE_AVS_CRYSTAL_SPEECH */

#ifdef FEATURE_AVS_NEXTGEN_EC
    if (ec_gen_id==0)
    {
      return QDSP_CMD_EC_GEN_NEXT;
    }
#endif

    MSG_ERROR("Unsupported EC %x", ec_gen_id, 0, 0);
    return QDSP_CMD_EC_GEN_MAX;
  }
#endif  /* QDSP_uPCrystalSpeechOrEcns */

#if defined(QDSP_ecnsNewOrOld)
  if((uint32*)QDSP_ecnsNewOrOld == QDSP_NOP_ADDRESS) {
    return QDSP_CMD_EC_GEN_LEGACY;
  }

  ec_gen_id = qdsp_read(QDSP_ecnsNewOrOld);

  switch (ec_gen_id)
  {
    case QDSP_CMD_EC_GEN_LEGACY:
#ifdef FEATURE_AVS_NEXTGEN_EC
    case QDSP_CMD_EC_GEN_NEXT:
#endif
      return (qdsp_cmd_ec_gen_id_type)ec_gen_id;

    default:
      MSG_ERROR("Unsupported EC %x", ec_gen_id, 0, 0);
      return QDSP_CMD_EC_GEN_MAX;
  }

#else

  return QDSP_CMD_EC_GEN_LEGACY;

#endif /* defined(QDSP_ecnsNewOrOld) */
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_EC_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function sets the QDSP2 echo cancellation mode.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_ec_ctrl (
  const qdsp_cmd_ec_config_type *ec_config,
  const qdsp_cmd_ec_params_type *ec_params
)
{
  qdsp_cmd_ec_gen_id_type ec_gen_id;

  ec_gen_id = qdsp_cmd_get_ec_gen_id();
  if (ec_gen_id != QDSP_CMD_EC_GEN_LEGACY)
  {
    MSG_ERROR("Wrong EC control %d", ec_gen_id, 0, 0);
    return QDSP_CMD_FAILED;
  }

  if ( ec_config->ec_switch != QDSP_ECHO_CANCEL_DIS_V
    && ec_params == NULL )
  {
    MSG_ERROR("NULL EC Params Table",0,0,0);
    return QDSP_CMD_FAILED;
  }

  /* Read Data structure containing echo canceller configuration data
     to fill in QDSP2 memory
  */

#ifdef QDSP_ecSwitch
  qdsp_write(QDSP_ecSwitch, ec_config->ec_switch);
#endif

  if ( ec_config->ec_switch == QDSP_ECHO_CANCEL_ENA_V )
  {
#ifdef QDSP_ecFarendHangoverThres
    qdsp_write(QDSP_ecFarendHangoverThres,
      ec_params->farend_hangover_thresh);
#endif

#ifdef QDSP_ecStartupMuteHangoverThres
    qdsp_write(QDSP_ecStartupMuteHangoverThres,
      ec_params->startup_mute_hangover_thresh);
#endif

#ifdef QDSP_ecStartupMuteMode
    qdsp_write(QDSP_ecStartupMuteMode,
      ec_params->startup_mute_mode);
#endif

#ifdef QDSP_ecStartupErleThres
    qdsp_write(QDSP_ecStartupErleThres,
      ec_params->startup_erle_thresh);
#endif

    switch(ec_config->ec_mode) {
#ifdef QDSP_esecDoubletalkHangoverThres
    case QDSP_ECHO_CANCEL_ESEC_V:
      qdsp_write(QDSP_esecDoubletalkHangoverThres,
        ec_params->doubletalk_hangover_thresh);
      break;
#endif

#ifdef QDSP_hecDoubletalkHangoverThres
    case QDSP_ECHO_CANCEL_HEADSET_V:
      qdsp_write(QDSP_hecDoubletalkHangoverThres,
        ec_params->doubletalk_hangover_thresh);
      break;
#endif

#ifdef QDSP_aecDoubletalkHangoverThres
    case QDSP_ECHO_CANCEL_AEC_V:
    case QDSP_ECHO_CANCEL_SPEAKER_V:
      qdsp_write(QDSP_aecDoubletalkHangoverThres,
        ec_params->doubletalk_hangover_thresh);
      break;
#endif

    default:
      MSG_ERROR("Bad EC mode.",0,0,0);
      return QDSP_CMD_FAILED;
      break;
    }

    /* For speakerphone, use AEC with modified parameters */
    if (ec_config->ec_mode == QDSP_ECHO_CANCEL_SPEAKER_V )
    {
      /* -12dB = 0x1000, -24dB = 0x0400, -30dB = 0x0200 */
#ifdef FEATURE_ACP
#error code not present
#endif

#ifdef QDSP_ecFarCoeff
      qdsp_write_offset(QDSP_ecFarCoeff, 0, 0x18bd);
      qdsp_write_offset(QDSP_ecFarCoeff, 1, 0x612f);
      qdsp_write_offset(QDSP_ecFarCoeff, 2, 0x003a);
      qdsp_write_offset(QDSP_ecFarCoeff, 3, 0xb9d1);
      qdsp_write_offset(QDSP_ecFarCoeff, 4, 0x06ed);
      qdsp_write_offset(QDSP_ecFarCoeff, 5, 0x0fc6);
      qdsp_write_offset(QDSP_ecFarCoeff, 6, 0x0013);
      qdsp_write_offset(QDSP_ecFarCoeff, 7, 0x09c8);
#endif

#ifdef FEATURE_PHONE_VR
      if (qdsp_cmd_image_select != QDSP_IMAGE_VRBC)
#endif
      {
#ifdef QDSP_ecForceHalfDuplex
         qdsp_write(QDSP_ecForceHalfDuplex, 0xffff);
#endif
      }

#ifdef QDSP_ecMode
      qdsp_write(QDSP_ecMode, QDSP_ECHO_CANCEL_AEC_V);
#endif
    }
    else
    {

#ifdef FEATURE_PHONE_VR
      if (qdsp_cmd_image_select != QDSP_IMAGE_VRBC)
#endif
      {
#ifdef QDSP_ecForceHalfDuplex
         qdsp_write(QDSP_ecForceHalfDuplex, 0);
#endif
      }

      /* -6dB = 0x2000 */
#ifdef FEATURE_ACP
#error code not present
#endif

#ifdef QDSP_ecFarCoeff
      qdsp_write_offset(QDSP_ecFarCoeff, 0, 0x25a8);
      qdsp_write_offset(QDSP_ecFarCoeff, 1, 0x2b88);
      qdsp_write_offset(QDSP_ecFarCoeff, 2, 0x0012);
      qdsp_write_offset(QDSP_ecFarCoeff, 3, 0x2b9a);
      qdsp_write_offset(QDSP_ecFarCoeff, 4, 0x00e8);
      qdsp_write_offset(QDSP_ecFarCoeff, 5, 0x05cb);
      qdsp_write_offset(QDSP_ecFarCoeff, 6, 0x0000);
      qdsp_write_offset(QDSP_ecFarCoeff, 7, 0x6fc2);
#endif

#ifdef QDSP_ecMode
      qdsp_write(QDSP_ecMode, ec_config->ec_mode);
#endif
    }
  }

#ifdef QDSP_ecResetFlag
  qdsp_write(QDSP_ecResetFlag, ec_config->ec_reset_flag);
#endif

  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
#ifdef FEATURE_AVS_NEXTGEN_EC
/*===========================================================================

FUNCTION QDSP_CMD_NEXTGEN_EC_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function sets the QDSP echo cancellation mode.

DEPENDENCIES
  This command is valid when the DSP is in IDLE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_nextgen_ec_ctrl (
  uint16                                ec_switch,
  const qdsp_cmd_nextgen_ec_parms_type  *ec_parms
) {

  qdsp_cmd_ec_gen_id_type ec_gen_id;

  ec_gen_id = qdsp_cmd_get_ec_gen_id();
  if (ec_gen_id != QDSP_CMD_EC_GEN_NEXT)
  {
    MSG_ERROR("Wrong EC control %d", ec_gen_id, 0, 0);
    return QDSP_CMD_FAILED;
  }

  if ( ec_switch != QDSP_ECHO_CANCEL_DIS_V && ec_parms == NULL ) {
    MSG_ERROR("NULL EC Params Table",0,0,0);
    return QDSP_CMD_FAILED;
  }
  if (qdsp_read(QDSP_ecParametersUpdated) == 0xffff) {
      MSG_ERROR("nextgen_ec_ctrl() ecParametersUpdated is 0xfff",0,0,0);
  }

  if(ec_switch != QDSP_ECHO_CANCEL_DIS_V) {
    qdsp_write(QDSP_NLPP_limit,ec_parms->NLPP_limit);
    qdsp_write(QDSP_NLPP_gain,ec_parms->NLPP_gain);
    qdsp_write(QDSP_AF_limit,ec_parms->AF_limit);
    qdsp_write(QDSP_ecModeNew,ec_parms->mode);
    qdsp_write(QDSP_tuning_mode,ec_parms->tuning_mode);
    qdsp_write(QDSP_echo_path_delay,ec_parms->echo_path_delay);
    qdsp_write(QDSP_echo_path_delay_by_80,ec_parms->echo_path_delay/80);
    qdsp_write(QDSP_OutputGain,ec_parms->OutputGain);
    qdsp_write(QDSP_InputGain,ec_parms->InputGain);
    qdsp_write(QDSP_AF_twoalpha,ec_parms->AF_twoalpha);
    qdsp_write(QDSP_AF_erl,ec_parms->AF_erl);
    qdsp_write(QDSP_AF_taps,ec_parms->AF_taps);
    qdsp_write(QDSP_AF_preset_coefs,ec_parms->AF_preset_coefs);
    qdsp_write(QDSP_AF_offset,ec_parms->AF_offset);
    qdsp_write(QDSP_AF_erl_bg,ec_parms->AF_erl_bg);
    qdsp_write(QDSP_AF_taps_bg,ec_parms->AF_taps_bg);
    qdsp_write(QDSP_PCD_threshold,ec_parms->PCD_threshold);
    qdsp_write(QDSP_MinimumErl_par,ec_parms->minimum_erl);
    qdsp_write(QDSP_ErlStep,ec_parms->erl_step);
    qdsp_write(QDSP_MAX_NOISE_FLOOR,ec_parms->max_noise_floor);
    qdsp_write(QDSP_DET_THRESHOLD,ec_parms->det_threshold);
    qdsp_write(QDSP_SPDET_far,ec_parms->SPDET_far);
    qdsp_write(QDSP_SPDET_mic,ec_parms->SPDET_mic);
    qdsp_write(QDSP_SPDET_xclip,ec_parms->SPDET_xclip);
    qdsp_write(QDSP_DENS_tail_alpha,ec_parms->DENS_tail_alpha);
    qdsp_write(QDSP_DENS_tail_portion,ec_parms->DENS_tail_portion);
    qdsp_write(QDSP_DENS_gamma_e_alpha,ec_parms->DENS_gamma_e_alpha);
    qdsp_write(QDSP_DENS_gamma_e_high,ec_parms->DENS_gamma_e_high);
    qdsp_write(QDSP_DENS_gamma_e_dt,ec_parms->DENS_gamma_e_dt);
    qdsp_write(QDSP_DENS_gamma_e_low,ec_parms->DENS_gamma_e_low);
    qdsp_write(QDSP_DENS_gamma_e_rescue,ec_parms->DENS_gamma_e_rescue);
    qdsp_write(QDSP_DENS_spdet_near,ec_parms->DENS_spdet_near);
    qdsp_write(QDSP_DENS_spdet_act,ec_parms->DENS_spdet_act);
    qdsp_write(QDSP_DENS_gamma_n,ec_parms->DENS_gamma_n);
    qdsp_write(QDSP_DENS_NFE_blocksize,ec_parms->DENS_NFE_blocksize);
    qdsp_write(QDSP_DENS_limit_NS,ec_parms->DENS_limit_NS);
    qdsp_write(QDSP_DENS_NL_atten,ec_parms->DENS_NL_atten);
    qdsp_write(QDSP_DENS_CNI_level,ec_parms->DENS_CNI_level);
    qdsp_write(QDSP_WB_echo_ratio,ec_parms->WB_echo_ratio);
  } else {
    /* Disable the EC */
    qdsp_write(QDSP_ecModeNew,QDSP_EC_MODE_OFF);
  }

  /* Flag that EC parameters have been updated */
  qdsp_write(QDSP_ecParametersUpdated, 0xffff);
  return QDSP_CMD_SUCCESS;
}
#endif  /* FEATURE_AVS_NEXTGEN_EC */

/* <EJECT> */
#ifdef FEATURE_AVS_CRYSTAL_SPEECH
/*===========================================================================

FUNCTION QDSP_CMD_CRYSTAL_SPEECH_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function sets the QDSP echo cancellation noise suppression mode.

DEPENDENCIES
  This command is valid when the DSP is in IDLE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_crystal_speech_ctrl (
  uint16                                    cs_switch,
  const qdsp_cmd_crystal_speech_parms_type  *cs_parms
)
{
  qdsp_cmd_ec_gen_id_type ec_gen_id;


  ec_gen_id = qdsp_cmd_get_ec_gen_id();
  if (ec_gen_id != QDSP_CMD_EC_GEN_CRYSTAL_SPEECH)
  {
    MSG_ERROR("Wrong EC control %d", ec_gen_id, 0, 0);
    return QDSP_CMD_FAILED;
  }

  if ( cs_switch != QDSP_ECHO_CANCEL_DIS_V && cs_parms == NULL ) {
    MSG_ERROR("NULL EC Params Table",0,0,0);
    return QDSP_CMD_FAILED;
  }
#if defined(QDSP_fluenceParametersUpdated)
#error code not present
#else
  if(qdsp_read(QDSP_ecParametersUpdated) == 0xffff) {
      MSG_ERROR("nextgen_ec_ctrl() ecParametersUpdated = 0xffff",0,0,0);
  }
#endif

  if (cs_switch != QDSP_ECHO_CANCEL_DIS_V)
  {
    qdsp_write(QDSP_CSMode, cs_parms->CSMode);
    qdsp_write(QDSP_CS_TuningMode, cs_parms->CS_TuningMode);
    qdsp_write(QDSP_CS_echo_path_delay, cs_parms->CS_echo_path_delay);
    qdsp_write(QDSP_CS_echo_path_delay_by_80, cs_parms->CS_echo_path_delay /80);
    qdsp_write(QDSP_AF1_twoalpha, cs_parms->AF1_twoalpha);
    qdsp_write(QDSP_AF1_erl, cs_parms->AF1_erl);
    qdsp_write(QDSP_AF1_taps, cs_parms->AF1_taps);
    qdsp_write(QDSP_AF1_preset_coefs, cs_parms->AF1_preset_coefs);
    qdsp_write(QDSP_AF1_offset, cs_parms->AF1_offset);
    qdsp_write(QDSP_AF2_twoalpha, cs_parms->AF2_twoalpha);
    qdsp_write(QDSP_AF2_erl, cs_parms->AF2_erl);
    qdsp_write(QDSP_AF2_taps, cs_parms->AF2_taps);
    qdsp_write(QDSP_AF2_preset_coefs, cs_parms->AF2_preset_coefs);
    qdsp_write(QDSP_AF2_offset, cs_parms->AF2_offset);
    qdsp_write(QDSP_PCD_twoalpha, cs_parms->PCD_twoalpha);
    qdsp_write(QDSP_PCD_offset, cs_parms->PCD_offset);
    qdsp_write(QDSP_CSPCD_threshold, cs_parms->CSPCD_threshold);
    qdsp_write(QDSP_WgThreshold, cs_parms->WgThreshold);
    qdsp_write(QDSP_MpThreshold, cs_parms->MpThreshold);
    qdsp_block_write(QDSP_SF_init_table0, 0,
                     cs_parms->SF_init_table0, 8, FALSE);
    qdsp_block_write(QDSP_SF_init_table1, 0,
                     cs_parms->SF_init_table1, 8, FALSE);
    qdsp_write(QDSP_SF_taps, cs_parms->SF_taps);
    qdsp_write(QDSP_SF_twoalpha, cs_parms->SF_twoalpha);
    qdsp_write(QDSP_DNNS_EchoAlphaRev, cs_parms->DNNS_EchoAlphaRev);
    qdsp_write(QDSP_DNNS_EchoYcomp, cs_parms->DNNS_EchoYcomp);
    qdsp_write(QDSP_DNNS_WbThreshold, cs_parms->DNNS_WbThreshold);
    qdsp_write(QDSP_DNNS_EchoGammaHi, cs_parms->DNNS_EchoGammaHi);
    qdsp_write(QDSP_DNNS_EchoGammaLo, cs_parms->DNNS_EchoGammaLo);
    qdsp_write(QDSP_DNNS_NoiseGammaS, cs_parms->DNNS_NoiseGammaS);
    qdsp_write(QDSP_DNNS_NoiseGammaN, cs_parms->DNNS_NoiseGammaN);
    qdsp_write(QDSP_DNNS_NoiseGainMinS, cs_parms->DNNS_NoiseGainMinS);
    qdsp_write(QDSP_DNNS_NoiseGainMinN, cs_parms->DNNS_NoiseGainMinN);
    qdsp_write(QDSP_DNNS_NoiseBiasComp, cs_parms->DNNS_NoiseBiasComp);
    qdsp_write(QDSP_DNNS_AcThreshold, cs_parms->DNNS_AcThreshold);
    qdsp_write(QDSP_WB_echo_ratio_2mic, cs_parms->WB_echo_ratio_2mic);
    qdsp_write(QDSP_WB_Gamma_E, cs_parms->WB_Gamma_E);
    qdsp_write(QDSP_WB_Gamma_NN, cs_parms->WB_Gamma_NN);
    qdsp_write(QDSP_WB_Gamma_SN, cs_parms->WB_Gamma_SN);
    qdsp_write(QDSP_vcodec_delay0, cs_parms->vcodec_delay0);
    qdsp_write(QDSP_vcodec_delay1, cs_parms->vcodec_delay1);
    qdsp_write(QDSP_vcodec_len0, cs_parms->vcodec_len0);
    qdsp_write(QDSP_vcodec_len1, cs_parms->vcodec_len1);
    qdsp_write(QDSP_vcodec_thr0, cs_parms->vcodec_thr0);
    qdsp_write(QDSP_vcodec_thr1, cs_parms->vcodec_thr1);
    qdsp_write(QDSP_FixCalFactorLeft, cs_parms->FixCalFactorLeft);
    qdsp_write(QDSP_FixCalFactorRight, cs_parms->FixCalFactorRight);
    qdsp_block_write32(QDSP_vcodec_coeff0, 0,
                       cs_parms->vcodec_coeff0, 15, FALSE);
    qdsp_block_write32(QDSP_vcodec_coeff1, 0,
                       cs_parms->vcodec_coeff1, 15, FALSE);
    qdsp_write(QDSP_csOutputGain, cs_parms->CS_OutputGain);
    qdsp_write(QDSP_enhanceMeuFilter1, cs_parms->Enhance_MeuFilter1);
    qdsp_write(QDSP_enhanceMeuFilter2, cs_parms->Enhance_MeuFilter2);
    qdsp_write(QDSP_fixOverEstimation, cs_parms->Fix_OverEstimation);
    qdsp_write(QDSP_dmNLPPlimit, cs_parms->dmNLPPlimit);
    qdsp_write(QDSP_dmNLPPgain, cs_parms->dmNLPPgain);
#if defined(QDSP_windNoiseCfgNoiseThresh)
    qdsp_write(QDSP_windNoiseCfgNoiseThresh, cs_parms->windNoiseCfgNoiseThresh);
    qdsp_write(QDSP_windNoiseSensitivity, cs_parms->windNoiseSensitivity);
    qdsp_write(QDSP_windNoiseHangOver , cs_parms->windNoiseHangOver );
    qdsp_write(QDSP_windPowerSmAlpha , cs_parms->windPowerSmAlpha );
    qdsp_write(QDSP_lpEnergySmAlpha,  cs_parms->lpEnergySmAlpha);
    qdsp_write(QDSP_windNoiseEnergyOffset,cs_parms->windNoiseEnergyOffset);
    qdsp_write(QDSP_windNoiseRatioSmAlpha,cs_parms->windNoiseRatioSmAlpha);
    qdsp_block_write(QDSP_numCoefIirTdf2Lpf, 0, cs_parms->numCoefIirTdf2Lpf, 6, FALSE);
    qdsp_block_write(QDSP_denCoefIirTdf2Lpf, 0, cs_parms->denCoefIirTdf2Lpf, 4, FALSE);
    qdsp_block_write(QDSP_numCoefIirTdf2Hpf, 0, cs_parms->numCoefIirTdf2Hpf, 6, FALSE);
    qdsp_block_write(QDSP_denCoefIirTdf2Hpf, 0, cs_parms->denCoefIirTdf2Hpf, 4, FALSE);
#endif
  }
  else
  {
    qdsp_write(QDSP_CSMode, QDSP_CS_MODE_OFF);
  }

  /* Flag that FLUENCE parameters have been updated */
#if defined(QDSP_fluenceParametersUpdated)
#error code not present
#else
  qdsp_write(QDSP_ecParametersUpdated, 0xffff);
#endif

  return QDSP_CMD_SUCCESS;
}

#endif  /* FEATURE_AVS_CRYSTAL_SPEECH */


/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_HPF_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function enables or disables the QDSP2 HPF Override.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_hpf_ctrl (
  uint16 hpf_switch
)
{
  /* Read Data structure containing HPF Switch data
     to fill in QDSP2 memory
  */
  qdsp_write(QDSP_frontHpfOverride, hpf_switch);

  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_NS_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function enables or disables the QDSP2 noise suppressor.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_ns_ctrl (
  uint16 ns_switch
)
{
  /* Read Data structure containing Noise Suppressor Switch data
     to fill in QDSP2 memory
  */
#if defined( QDSP_nsSwitch )
  qdsp_write(QDSP_nsSwitch, ns_switch);
#endif /* QDSP_nsSwitch */
  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SIDETONE_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function writes the sidetone to the DMA variable.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_sidetone_ctrl (
  boolean sidetone_switch, uint16 st_gain
)
{
  switch(qdsp_cmd_image_select) {
#ifdef FEATURE_GRAPH_AUDIO
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */

#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */

#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */

#ifdef QDSP_IMAGE_MP4D_DEFINED
    case QDSP_IMAGE_MP4D:
#endif /* QDSP_IMAGE_MP4D_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AMR_DEFINED
    case QDSP_IMAGE_MP4D_AMR:
#endif /* QDSP_IMAGE_MP4D_AMR_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED
    case QDSP_IMAGE_MP4D_AMR_EVRC_V13K:
#endif /* QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED */

#ifdef QDSP_IMAGE_QTV_DEFINED
    case QDSP_IMAGE_QTV:
#endif /* QDSP_IMAGE_QTV_DEFINED */

#ifdef QDSP_IMAGE_QTV_VOC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_DEFINED */

#ifdef QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED */

#ifdef QDSP_IMAGE_H263D_DEFINED
    case QDSP_IMAGE_H263D:
#endif /* QDSP_IMAGE_H263D_DEFINED */

#ifdef QDSP_IMAGE_H263D_AMR_DEFINED
    case QDSP_IMAGE_H263D_AMR:
#endif /* QDSP_IMAGE_H263D_AMR_DEFINED */

#ifdef QDSP_IMAGE_H264D_AMR_DEFINED
    case QDSP_IMAGE_H264D_AMR:
#endif /* QDSP_IMAGE_H264D_AMR_DEFINED */

#ifdef QDSP_IMAGE_H264D_EVRC_DEFINED
#error code not present
#endif /* QDSP_IMAGE_H264D_EVRC_DEFINED */

#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */

#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */

#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */

#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */

#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */

#ifdef QDSP_IMAGE_AUDDUB_13K_DEFINED
    case QDSP_IMAGE_AUDDUB_13K:
#endif /* QDSP_IMAGE_AUDDUB_13K_DEFINED */

#ifdef QDSP_IMAGE_AUDDUB_EVRC_DEFINED
    case QDSP_IMAGE_AUDDUB_EVRC:
#endif /* QDSP_IMAGE_AUDDUB_EVRC_DEFINED */

#ifdef QDSP_IMAGE_AUDDUB_AMR_DEFINED
    case QDSP_IMAGE_AUDDUB_AMR:
#endif /* QDSP_IMAGE_AUDDUB_AMR_DEFINED */

#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */

#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
#endif /* QDSP_IMAGE_AACENC_DEFINED */

#endif /* FEATURE_GRAPH_AUDIO */

#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
    case QDSP_IMAGE_MP4D_MP3:
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */

#ifdef QDSP_IMAGE_TUNES_DEFINED
    case QDSP_IMAGE_TUNES:
#endif /* QDSP_IMAGE_TUNES_DEFINED */

#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
   case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */

#ifdef QDSP_IMAGE_AAC_DEFINED
    case QDSP_IMAGE_AAC:
#endif /* QDSP_IMAGE_AAC_DEFINED */

#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
    case QDSP_IMAGE_ENH_AAC_PLUS:
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
    case QDSP_IMAGE_MP4D_AAC:
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */

#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
    case QDSP_IMAGE_H263D_AAC:
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */

#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
    case QDSP_IMAGE_H264D_AAC:
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */

#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */

#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
    case QDSP_IMAGE_MP4D_AAC_NO_VPP:
#endif /* QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED */

#ifdef QDSP_IMAGE_QSYNTH_DEFINED
    case QDSP_IMAGE_QSYNTH:
#endif /* QDSP_IMAGE_QSYNTH_DEFINED */
      break;
    default:
      if(sidetone_switch == TRUE)
      {
        qdsp_write(QDSP_codecSTGain, st_gain);
        qdsp_cmd_sidetone_enable = TRUE;
      }
      else
      {
        qdsp_write(QDSP_codecSTGain, QDSP_SIDETONE_DIS_V);
        qdsp_cmd_sidetone_enable = FALSE;
      }
      break;
  }

  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */

/*===========================================================================

FUNCTION QDSP_CMD_VOX_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function enables or disables the VOX (half-duplex voice).

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_vox_ctrl (
  uint16 vox_switch
)
{
  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED) || \
    defined(QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED)
#ifdef QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_H263:
#endif
#ifdef QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_MPEG4:
#endif
      qdsp_write(QDSP_voxSwitch, vox_switch);
      break;
#endif

    default:
      break;
  }
  return QDSP_CMD_SUCCESS;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_TX_COMFORT_NOISE_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function enables or disables the noise suppressor.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_tx_comfort_noise_ctrl ( uint16 comfort_noise_mode )
{
  switch (qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif /* QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED */
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif /* QDSP_IMAGE_VOC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif /* QDSP_IMAGE_VOC_EVRC_MP3_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */
#ifdef QDSP_IMAGE_4GV_DEFINED
    case QDSP_IMAGE_4GV:
#endif
#ifdef QDSP_IMAGE_4GV_WB_DEFINED
    case QDSP_IMAGE_4GV_WB:
#endif
#ifdef QDSP_IMAGE_4GV_VOIP_DEFINED
    case QDSP_IMAGE_4GV_VOIP:
#endif
#ifdef QDSP_IMAGE_G711_DEFINED
    case QDSP_IMAGE_G711:
#endif
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif
#ifdef QDSP_IMAGE_VRBC_DEFINED
    case QDSP_IMAGE_VRBC:
#endif
#ifdef QDSP_IMAGE_PUFE_DEFINED
    case QDSP_IMAGE_PUFE:
#endif
#ifdef QDSP_IMAGE_AMR_YCBCR2_DEFINED
    case QDSP_IMAGE_AMR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_EFR_YCBCR2_DEFINED
    case QDSP_IMAGE_EFR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_FR_YCBCR2_DEFINED
    case QDSP_IMAGE_FR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_HR_YCBCR2_DEFINED
    case QDSP_IMAGE_HR_YCBCR2:
#endif
#ifdef QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_H263:
#endif
#ifdef QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED
    case QDSP_IMAGE_QVP_YUV_AMR_MPEG4:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_AMR_DEFINED
    case QDSP_IMAGE_QVP_H263P3_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_G723_DEFINED
    case QDSP_IMAGE_QVP_H263P3_G723:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_G723_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_G723:
#endif /* QDSP_IMAGE_QVP_MPEG4_G723_DEFINED */
#ifdef QDSP_IMAGE_QVP_BAYER_AMR_DEFINED
    case QDSP_IMAGE_QVP_BAYER_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_AMR:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED
    case QDSP_IMAGE_QVP_MPEG4_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED
    case QDSP_IMAGE_QVP_H263P3_EVRC:
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED
    case QDSP_IMAGE_QCAMCORDER_COMBO:
#endif /*QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED*/
if (comfort_noise_mode == QDSP_COMFORT_NOISE_ENA_V) {
        /* If entering comfort noise mode */
#ifdef FEATURE_NO_TX_COMFORT_NOISE
        if (qdsp_cmd_mute_tx == TRUE ) {
          /* If during comfort noise mode we are muting TX
          ** instead of enabling DSP comfort noise parameter
          */
          qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
          qdsp_write(QDSP_txVolume, QDSP_TX_MUTE_GAIN);
        } else
#endif /* FEATURE_NO_TX_COMFORT_NOISE */
        {
          qdsp_write(QDSP_txComfortNoiseEnable, comfort_noise_mode);
        }
      } else if (comfort_noise_mode == QDSP_COMFORT_NOISE_DIS_V) {
        /* If exiting comfort noise mode */
#ifdef FEATURE_NO_TX_COMFORT_NOISE
        if (qdsp_cmd_mute_tx == TRUE) {
          /* If during comfort noise mode we are muting TX
          ** instead of enabling DSP comfort noise parameter
          */
          qdsp_write(QDSP_txComfortNoiseEnable, QDSP_COMFORT_NOISE_DIS_V);
          qdsp_write(QDSP_txVolume, qdsp_cmd_tx_volume);
        } else
#endif /* FEATURE_NO_TX_COMFORT_NOISE */
        {
          qdsp_write(QDSP_txComfortNoiseEnable, comfort_noise_mode);
        }
      } else {
        MSG_ERROR("Invalid comfort noise setting", 0, 0, 0);
      }
      break;

    default:
      break;
  }
}

/* <EJECT> */
#if defined(FEATURE_PHONE_VR) || defined(FEATURE_VOICE_RECORD)
/*===========================================================================

FUNCTION QDSP_CMD_RESTORE_COMFORT_NOISE (DMA Type Writable Information)

DESCRIPTION
  This function enables or disables the QDSP comfort noise TX generator.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_restore_comfort_noise ( void )
{
  qdsp_cmd_tx_comfort_noise_ctrl(qdsp_cmd_tx_comfort_noise);
}

#endif /* defined(FEATURE_PHONE_VR) || defined(FEATURE_VOICE_RECORD) */

/* <EJECT> */
#ifdef FEATURE_ACP
#error code not present
#endif  /* FEATURE_ACP */

/* <EJECT> */
#ifdef FEATURE_TTY
#ifdef FEATURE_TTY_ACTIVITY_STATUS
/*===========================================================================

FUNCTION qdsp_cmd_register_tty_status_client

DESCRIPTION
  Use this function to register a callback which will receive TTY activity
  status updates.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_register_tty_status_client (
  qdsp_tty_status_fn_type tty_func /* Callback to indicate TTY activity */
)
{
  qdsp_tty_update_status_func = tty_func;
}
#endif /* FEATURE_TTY_ACTIVITY_STATUS */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GET_TTY_INTF

DESCRIPTION
  This function gives the available TTY interface

DEPENDENCIES
  This command is valid when the DSP is in Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_intf_tty_type indicating the TTY interface type

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_intf_tty_type qdsp_cmd_get_tty_intf (void)
{
  qdsp_cmd_intf_tty_type tty_interface = QDSP_CMD_INTF_TTY_NONE;

  switch (qdsp_cmd_module_select) {
#ifdef FEATURE_TTY_CDMA
#ifdef QDSP_MODULE_13K_DEFINED
    case QDSP_MODULE_13K:
#endif /* QDSP_MODULE_13K_DEFINED */
#ifdef QDSP_MODULE_EVRC_DEFINED
    case QDSP_MODULE_EVRC:
#endif /* QDSP_MODULE_EVRC_DEFINED */
#ifdef QDSP_MODULE_4GV_DEFINED
    case QDSP_MODULE_4GV:
#endif /* QDSP_MODULE_4GV_DEFINED */
#ifdef QDSP_MODULE_4GV_WB_DEFINED
	case QDSP_MODULE_4GV_WB:
#endif /* QDSP_MODULE_4GV_WB_DEFINED */
      tty_interface = QDSP_CMD_INTF_TTY_1X;
      break;
#endif /* FEATURE_TTY_CDMA */
#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */
    default:
      tty_interface = QDSP_CMD_INTF_TTY_NONE;
      MSG_HIGH("No TTY interface is selected",0,0,0);
      break;
  }
  return tty_interface;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_TTY_CTRL (DMA Type Writable Information)

DESCRIPTION
  This function enables or disables TTY checking.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_tty_ctrl (
  uint16              tty_switch,
  qdsp_tty_mode_type  tty_mode
)
{
  qdsp_cmd_intf_tty_type tty_interface = QDSP_CMD_INTF_TTY_NONE;

  tty_interface = qdsp_cmd_get_tty_intf();

  if (tty_interface == QDSP_CMD_INTF_TTY_1X) {
      /* Write TTY Switch data (either 0 or 1) in QDSP2 memory */
      qdsp_write(QDSP_ttyNoGainFlag, tty_switch);
  }
#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */
  else {
    MSG_MED("TTY not supported in module = %d",qdsp_cmd_module_select,0,0);
  }

#ifdef FEATURE_TTY_ACTIVITY_STATUS
  qdsp_tty_mode = tty_switch;

  /* Reset TTY activity status flags */
  qdsp_tty_prev_enc_state = 0;
  qdsp_tty_prev_dec_state = 0;
#endif /* FEATURE_TTY_ACTIVITY_STATUS */

  return QDSP_CMD_SUCCESS;
}
#endif /* FEATURE_TTY */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_GET_PCMPAD (DMA Type Readable Information)

DESCRIPTION
  This function reads the QDSP2 PCM pad value.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
uint16 qdsp_cmd_get_pcmpad ( void )
{
  uint16 result;             /* Store the return value       */

  /* Read QDSP2 memory containing received PCM padding information
     to return to the caller
  */
  result = qdsp_read(QDSP_rcvdPadWord);
  return( result );


}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_PCMPAD (DMA Type Writable Information)

DESCRIPTION
  This function sets the QDSP2 PCM pad value.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_pcmpad (
  uint16 padval
)
{
  /* Read Data containing transmit PCM padding information
     to fill in QDSP2 memory
  */

  qdsp_write(QDSP_xmitPadWord, padval);

  return QDSP_CMD_SUCCESS;

}

/* <EJECT> */
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_PRE_EC_TX_PCM_FILTER (boolean pre_EC_pcm_filter)

DESCRIPTION
  This function will set the pre EC Tx PCM filter flag for DSP.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_pre_ec_tx_pcm_filter(uint16 *pre_ec_tx_pcm_filter)
{

#if defined(QDSP_txPcmFilterBeforeEC)
  uint16 txPcmFilter;


  if( pre_ec_tx_pcm_filter ==NULL ||
    (*pre_ec_tx_pcm_filter!=QDSP_CMD_TX_PCM_FILTER_BEFORE_EC
    && *pre_ec_tx_pcm_filter!=QDSP_CMD_TX_PCM_FILTER_AFTER_EC) )
  { /* parameter error, abort!*/
    return(QDSP_CMD_FAILED);
  }

  txPcmFilter = *pre_ec_tx_pcm_filter;
  /*To tell the DSP whether to enable the Tx PCM filter before EC or after EC*/
  if ((uint32*)QDSP_txPcmFilterBeforeEC == QDSP_NOP_ADDRESS){
      MSG_LOW("txPcmFilterBeforeEC not supported, Image:%d",
               qdsp_cmd_image_select,0,0);
      return  QDSP_CMD_SUCCESS;
  }
  qdsp_write(QDSP_txPcmFilterBeforeEC, txPcmFilter);

#endif /*QDSP_txPcmFilterBeforeEC*/

  return  QDSP_CMD_SUCCESS;
}
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_RX_PCM_FILTER (DMA Type Writable Information)

DESCRIPTION
  This function will load a new set of the QDSP2 RX PCM filter coefficients.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_rx_pcm_filter (
  const qdsp_cmd_pcm_filter_type *coefficients
)
{
  qdsp_cmd_status_type result;             /* Store the return value       */

  sint15 pcmFiltLoad;

#if !defined(QDSP_rxPcmFiltLoad)
    /* Return without failing */
    return  QDSP_CMD_SUCCESS;
#else
    if ((uint32*)QDSP_rxPcmFiltLoad == QDSP_NOP_ADDRESS) {
      MSG_LOW("rx_pcm_filter:FIR Filter not supported, Image:%d",
               qdsp_cmd_image_select,0,0);
      return  QDSP_CMD_SUCCESS;
    }
#endif /* QDSP_txPcmFiltLoad */

  /* Clear QDSP_rxPcmFiltLoad in preparation for setting RX PCM filter
  ** coefficients to new values.
  */
  qdsp_write(QDSP_rxPcmFiltLoad, 0x0);

  /* Since the ARM does not know when the QDSP2 is going to read these
  ** coefficients, make sure to wait for the maximum amount of time it takes
  ** for the QDSP2 to finish reading before updating the coefficients.  This
  ** wait is necessary to ensure that the QDSP2 will get the new coefficients.
  */
  #if defined (FEATURE_CMI_MM) || !defined(FEATURE_CMI)
  clk_busy_wait( 50 );
  #else    		
#error code not present
  #endif
          

  /* Read Data structure containing RX PCM filters coefficients
  ** to fill in QDSP2 memory.
  */

  /* Filter Tap, h[0] and h[12], Q14                         */
  /* Filter Tap, h[1] and h[11], Q14                         */
  /* Filter Tap, h[2] and h[10], Q14                         */
  /* Filter Tap, h[3] and h[9], Q14                          */
  /* Filter Tap, h[4] and h[8], Q14                          */
  /* Filter Tap, h[5] and h[7], Q14                          */
  /* Filter Tap, h[6], Q14. The filter is disabled if this   */
  /* tap is set to zero.                                     */


  qdsp_write_offset(QDSP_rxPcmFiltCoeff, 0, coefficients->tap0);
  qdsp_write_offset(QDSP_rxPcmFiltCoeff, 1, coefficients->tap1);
  qdsp_write_offset(QDSP_rxPcmFiltCoeff, 2, coefficients->tap2);
  qdsp_write_offset(QDSP_rxPcmFiltCoeff, 3, coefficients->tap3);
  qdsp_write_offset(QDSP_rxPcmFiltCoeff, 4, coefficients->tap4);
  qdsp_write_offset(QDSP_rxPcmFiltCoeff, 5, coefficients->tap5);
  qdsp_write_offset(QDSP_rxPcmFiltCoeff, 6, coefficients->tap6);


  /* Write -1 will instruct DSP to load the new Rx PCM filter
     from the buffer of rxPcmFiltCoefficients.
     After DSP has loaded the new filter coefficients,
     this location is cleared with zero.
  */


  pcmFiltLoad = (sint15) qdsp_read(QDSP_rxPcmFiltLoad);

  if (pcmFiltLoad == 0)
  {
    /*
    ** Write -1 to QDSP_rxPcmFiltLoad
    */

    qdsp_write(QDSP_rxPcmFiltLoad, 0xFFFF);

    result = QDSP_CMD_SUCCESS;
  }
  else
  {
    result = QDSP_CMD_FAILED;

    MSG_ERROR("QDSP2 Rx PCM Filter Load Command Error!", 0, 0, 0);

  }
  return( result );
}

#ifdef FEATURE_AVS_CRYSTAL_SPEECH
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_TX_PCM_SECONDMIC_FILTER (DMA Type Writable Information)

DESCRIPTION
  This function will load a new set of the QDSP2 TX PCM filter coefficients.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_tx_pcm_secondmic_filter (
  const qdsp_cmd_pcm_filter_type *second_mic_coefficients
)
{
#if defined(QDSP_txPcmFilterBeforeEC)


#if defined(QDSP_txPcmFiltCoeffSec)
#error code not present
#endif /*QDSP_txPcmFiltCoeffSec*/

#endif /*QDSP_txPcmFilterBeforeEC*/

  return  QDSP_CMD_SUCCESS;
}
#endif /*FEATURE_AVS_CRYSTAL_SPEECH*/

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_TX_PCM_FILTER (DMA Type Writable Information)

DESCRIPTION
  This function will load a new set of the QDSP2 TX PCM filter coefficients.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_tx_pcm_filter (
  const qdsp_cmd_pcm_filter_type *coefficients
)
{
  qdsp_cmd_status_type result;             /* Store the return value       */

  sint15 pcmFiltLoad;

#if !defined(QDSP_txPcmFiltLoad)
    /* Return without failing */
    return  QDSP_CMD_SUCCESS;
#else
    if ((uint32*)QDSP_txPcmFiltLoad == QDSP_NOP_ADDRESS) {
      MSG_LOW("tx_pcm_filter:FIR Filter not supported, Image:%d",
               qdsp_cmd_image_select,0,0);
      return  QDSP_CMD_SUCCESS;
    }
#endif /* QDSP_txPcmFiltLoad */

  /* Clear QDSP_txPcmFiltLoad in preparation for setting RX PCM filter
  ** coefficients to new values.
  */
  qdsp_write(QDSP_txPcmFiltLoad, 0x0);

  /* Since the ARM does not know when the QDSP2 is going to read these
  ** coefficients, make sure to wait for the maximum amount of time it takes
  ** for the QDSP2 to finish reading before updating the coefficients.  This
  ** wait is necessary to ensure that the QDSP2 will get the new coefficients.
  */
  #if defined (FEATURE_CMI_MM) || !defined(FEATURE_CMI)
  clk_busy_wait(50);
  #else    		
#error code not present
  #endif

  /* Read Data structure containing TX PCM filters coefficients
  ** to fill in QDSP2 memory.
  */

  /* Filter Tap, h[0] and h[12], Q14                         */
  /* Filter Tap, h[1] and h[11], Q14                         */
  /* Filter Tap, h[2] and h[10], Q14                         */
  /* Filter Tap, h[3] and h[9], Q14                          */
  /* Filter Tap, h[4] and h[8], Q14                          */
  /* Filter Tap, h[5] and h[7], Q14                          */
  /* Filter Tap, h[6], Q14. The filter is disabled if this   */
  /* tap is set to zero.                                     */


  qdsp_write_offset(QDSP_txPcmFiltCoeff, 0, coefficients->tap0);
  qdsp_write_offset(QDSP_txPcmFiltCoeff, 1, coefficients->tap1);
  qdsp_write_offset(QDSP_txPcmFiltCoeff, 2, coefficients->tap2);
  qdsp_write_offset(QDSP_txPcmFiltCoeff, 3, coefficients->tap3);
  qdsp_write_offset(QDSP_txPcmFiltCoeff, 4, coefficients->tap4);
  qdsp_write_offset(QDSP_txPcmFiltCoeff, 5, coefficients->tap5);
  qdsp_write_offset(QDSP_txPcmFiltCoeff, 6, coefficients->tap6);


  /* Write -1 will instruct DSP to load the new Tx PCM filter
     from the buffer of txPcmFiltCoefficients.
     After DSP has loaded the new filter coefficients,
     this location is cleared with zero.
  */

  pcmFiltLoad = (sint15) qdsp_read(QDSP_txPcmFiltLoad);

  if (pcmFiltLoad == 0)
  {
    /*
    ** write -1 to QDSP_txPcmFiltLoad
    */

    qdsp_write(QDSP_txPcmFiltLoad, 0xFFFF);

    result = QDSP_CMD_SUCCESS;
  }
  else
  {
    result = QDSP_CMD_FAILED;

    MSG_ERROR("QDSP2 Tx PCM Filter Load Command Error!", 0, 0, 0);

  }
  return( result );
}

#ifdef FEATURE_IIR_FILTER
/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_RX_PCM_IIR_FILTER (DMA Type Writable Information)

DESCRIPTION
  This function will load a new set of the QDSP PCM filter coefficients.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_rx_pcm_iir_filter (
  const qdsp_cmd_pcm_iir_filter_type *coefficients
)
{
  /* Check input parameters
  */
  if((coefficients == NULL) ||
     ((coefficients->flag != QDSP_CMD_IIR_FILTER_ENABLE) &&
      (coefficients->flag != QDSP_CMD_IIR_FILTER_DISABLE))) {
    /* Parameter error, abort.
    */
    return(QDSP_CMD_FAILED);
  }

  /* Switch off the IIR filter, if enabled.
  */
  qdsp_write(QDSP_rxIirPcmFilterSwitch, 0x0);


  /* The FIR filter and IIR filter cannot coexist.  Clear the FIR filter in
  ** preparation for enabling the IIR filter.
  */
  if(coefficients->flag == QDSP_CMD_IIR_FILTER_ENABLE) {

#if defined(QDSP_rxPcmFiltLoad)
    if ((uint32*)QDSP_rxPcmFiltLoad != QDSP_NOP_ADDRESS) {
      qdsp_write(QDSP_rxPcmFiltLoad, 0x0);
#if defined(QDSP_rxPcmFiltCoeff)
      if ((uint32*)QDSP_rxPcmFiltCoeff != QDSP_NOP_ADDRESS) {
        qdsp_write_offset(QDSP_rxPcmFiltCoeff, 6, 0x0000);
      }
#endif /* QDSP_rxPcmFiltCoeff */
      qdsp_write(QDSP_rxPcmFiltLoad, 0xffff);
    }
#endif /* QDSP_txPcmFiltLoad */

    /* Since the ARM does not know when the QDSP is going to read these
    ** coefficients, make sure to wait for the maximum amount of time it takes
    ** for the QDSP to finish reading before updating the coefficients.  This
    ** wait is necessary to ensure that the QDSP will get the new coefficients.
    */
    #if defined (FEATURE_CMI_MM) || !defined(FEATURE_CMI)
	clk_busy_wait(50);
    #else    		
#error code not present
	#endif
          

    /* Read Data structure containing PCM filter coefficients
    ** to fill in QDSP memory.
    */
#if defined(QDSP_rxPcmIirACoeff1)
    if (((uint32*)QDSP_rxPcmIirACoeff1 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 1))
    {
    qdsp_write_offset(QDSP_rxPcmIirACoeff1, 0, coefficients->stage1.a1 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirACoeff1, 1, coefficients->stage1.a1 >> 16);
    qdsp_write_offset(QDSP_rxPcmIirACoeff1, 2, coefficients->stage1.a2 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirACoeff1, 3, coefficients->stage1.a2 >> 16);
    }
#endif /*QDSP_rxPcmIirACoeff1*/

#if defined(QDSP_rxPcmIirACoeff2)
    if (((uint32*)QDSP_rxPcmIirACoeff2 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 2))
    {
    qdsp_write_offset(QDSP_rxPcmIirACoeff2, 0, coefficients->stage2.a1 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirACoeff2, 1, coefficients->stage2.a1 >> 16);
    qdsp_write_offset(QDSP_rxPcmIirACoeff2, 2, coefficients->stage2.a2 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirACoeff2, 3, coefficients->stage2.a2 >> 16);
    }
#endif /*QDSP_rxPcmIirACoeff2*/

#if defined(QDSP_rxPcmIirACoeff3)
    if (((uint32*)QDSP_rxPcmIirACoeff3 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 3))
    {
    qdsp_write_offset(QDSP_rxPcmIirACoeff3, 0, coefficients->stage3.a1 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirACoeff3, 1, coefficients->stage3.a1 >> 16);
    qdsp_write_offset(QDSP_rxPcmIirACoeff3, 2, coefficients->stage3.a2 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirACoeff3, 3, coefficients->stage3.a2 >> 16);
    }
#endif /*QDSP_rxPcmIirACoeff3*/

#if defined(QDSP_rxPcmIirACoeff4)
    if (((uint32*)QDSP_rxPcmIirACoeff4 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 4))
    {
      qdsp_write_offset(QDSP_rxPcmIirACoeff4, 0, coefficients->stage4.a1 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirACoeff4, 1, coefficients->stage4.a1 >> 16);
      qdsp_write_offset(QDSP_rxPcmIirACoeff4, 2, coefficients->stage4.a2 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirACoeff4, 3, coefficients->stage4.a2 >> 16);
    }
#endif /*QDSP_rxPcmIirACoeff4*/

#if defined(QDSP_rxPcmIirACoeff5)
    if (((uint32*)QDSP_rxPcmIirACoeff5 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 5))
    {
      qdsp_write_offset(QDSP_rxPcmIirACoeff5, 0, coefficients->stage5.a1 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirACoeff5, 1, coefficients->stage5.a1 >> 16);
      qdsp_write_offset(QDSP_rxPcmIirACoeff5, 2, coefficients->stage5.a2 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirACoeff5, 3, coefficients->stage5.a2 >> 16);
    }
#endif /*QDSP_rxPcmIirACoeff5*/

#if defined(QDSP_rxPcmIirBCoeff1)
    if (((uint32*)QDSP_rxPcmIirBCoeff1 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 1))
    {
    qdsp_write_offset(QDSP_rxPcmIirBCoeff1, 0, coefficients->stage1.b0 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff1, 1, coefficients->stage1.b0 >> 16);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff1, 2, coefficients->stage1.b1 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff1, 3, coefficients->stage1.b1 >> 16);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff1, 4, coefficients->stage1.b2 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff1, 5, coefficients->stage1.b2 >> 16);
    }
#endif /*QDSP_rxPcmIirBCoeff1*/

#if defined(QDSP_rxPcmIirBCoeff2)
    if (((uint32*)QDSP_rxPcmIirBCoeff2 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 2))
    {
    qdsp_write_offset(QDSP_rxPcmIirBCoeff2, 0, coefficients->stage2.b0 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff2, 1, coefficients->stage2.b0 >> 16);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff2, 2, coefficients->stage2.b1 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff2, 3, coefficients->stage2.b1 >> 16);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff2, 4, coefficients->stage2.b2 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff2, 5, coefficients->stage2.b2 >> 16);
    }
#endif /*QDSP_rxPcmIirBCoeff2*/

#if defined(QDSP_rxPcmIirBCoeff3)
    if (((uint32*)QDSP_rxPcmIirBCoeff3 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 3))
    {
    qdsp_write_offset(QDSP_rxPcmIirBCoeff3, 0, coefficients->stage3.b0 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff3, 1, coefficients->stage3.b0 >> 16);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff3, 2, coefficients->stage3.b1 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff3, 3, coefficients->stage3.b1 >> 16);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff3, 4, coefficients->stage3.b2 & 0xffff);
    qdsp_write_offset(QDSP_rxPcmIirBCoeff3, 5, coefficients->stage3.b2 >> 16);
    }
#endif /*QDSP_rxPcmIirBCoeff3*/

#if defined(QDSP_rxPcmIirBCoeff4)
    if (((uint32*)QDSP_rxPcmIirBCoeff4 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 4))
    {
      qdsp_write_offset(QDSP_rxPcmIirBCoeff4, 0, coefficients->stage4.b0 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff4, 1, coefficients->stage4.b0 >> 16);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff4, 2, coefficients->stage4.b1 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff4, 3, coefficients->stage4.b1 >> 16);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff4, 4, coefficients->stage4.b2 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff4, 5, coefficients->stage4.b2 >> 16);
    }
#endif /*QDSP_rxPcmIirBCoeff4*/

#if defined(QDSP_rxPcmIirBCoeff5)
    if (((uint32*)QDSP_rxPcmIirBCoeff5 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 5))
    {
      qdsp_write_offset(QDSP_rxPcmIirBCoeff5, 0, coefficients->stage5.b0 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff5, 1, coefficients->stage5.b0 >> 16);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff5, 2, coefficients->stage5.b1 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff5, 3, coefficients->stage5.b1 >> 16);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff5, 4, coefficients->stage5.b2 & 0xffff);
      qdsp_write_offset(QDSP_rxPcmIirBCoeff5, 5, coefficients->stage5.b2 >> 16);
    }
#endif /*QDSP_rxPcmIirBCoeff5*/

    /* Write -1 will instruct DSP to load the new PCM filter
    ** from the buffer of coefficients.
    */
    qdsp_write(QDSP_rxIirPcmFilterSwitch, QDSP_CMD_IIR_FILTER_ENABLE);
  }

  return( QDSP_CMD_SUCCESS );
}
/* <EJECT> */

#ifdef FEATURE_AVS_CRYSTAL_SPEECH

/*===========================================================================

FUNCTION QDSP_CMD_SET_TX_PCM_SECONDMIC_IIR_FILTER (DMA Type Writable Information)

DESCRIPTION
  This function will load a new set of the QDSP PCM filter coefficients.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_tx_pcm_secondmic_iir_filter (
  const qdsp_cmd_pcm_iir_filter_type *second_mic_coefficients
)
{
#if defined(QDSP_txPcmFilterBeforeEC)

  /* Check input parameters
  */
  if((second_mic_coefficients == NULL) ||
     ((second_mic_coefficients->flag != QDSP_CMD_IIR_FILTER_ENABLE) &&
      (second_mic_coefficients->flag != QDSP_CMD_IIR_FILTER_DISABLE))) {
    /* Parameter error, abort.
    */
    return(QDSP_CMD_FAILED);
  }

  if(second_mic_coefficients->flag == QDSP_CMD_IIR_FILTER_ENABLE) {
#if defined(QDSP_txPcmSecIirACoeff1)
#error code not present
#endif /*QDSP_txPcmSecIirACoeff1*/

#if defined(QDSP_txPcmSecIirACoeff2)
#error code not present
#endif /*QDSP_txPcmSecIirACoeff2*/

#if defined(QDSP_txPcmSecIirACoeff3)
#error code not present
#endif /*QDSP_txPcmSecIirACoeff3*/

#if defined(QDSP_txPcmSecIirACoeff4)
#error code not present
#endif /*QDSP_txPcmSecIirACoeff4*/

#if defined(QDSP_txPcmSecIirACoeff5)
#error code not present
#endif /*QDSP_txPcmSecIirACoeff5*/

#if defined(QDSP_txPcmSecIirBCoeff1)
#error code not present
#endif /*QDSP_txPcmSecIirBCoeff1*/

#if defined(QDSP_txPcmSecIirBCoeff2)
#error code not present
#endif /*QDSP_txPcmSecIirBCoeff2*/

#if defined(QDSP_txPcmSecIirBCoeff3)
#error code not present
#endif /*QDSP_txPcmSecIirBCoeff3*/

#if defined(QDSP_txPcmSecIirBCoeff4)
#error code not present
#endif /*QDSP_txPcmSecIirBCoeff4*/

#if defined(QDSP_txPcmSecIirBCoeff5)
#error code not present
#endif /*QDSP_txPcmSecIirBCoeff5*/

  }
#endif /* QDSP_txPcmFilterBeforeEC */

return(QDSP_CMD_SUCCESS);
}
#endif /*FEATURE_AVS_CRYSTAL_SPEECH*/

/*===========================================================================

FUNCTION QDSP_CMD_SET_TX_PCM_IIR_FILTER (DMA Type Writable Information)

DESCRIPTION
  This function will load a new set of the QDSP PCM filter coefficients.

DEPENDENCIES
  This command is valid when the DSP is in IDLE, Vocoder or DFM state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_tx_pcm_iir_filter (
  const qdsp_cmd_pcm_iir_filter_type *coefficients
)
{
  /* Check input parameters
  */
  if((coefficients == NULL) ||
     ((coefficients->flag != QDSP_CMD_IIR_FILTER_ENABLE) &&
      (coefficients->flag != QDSP_CMD_IIR_FILTER_DISABLE))) {
    /* Parameter error, abort.
    */
    return(QDSP_CMD_FAILED);
  }

  /* Switch off the IIR filter, if enabled.
  */
  qdsp_write(QDSP_txIirPcmFilterSwitch, 0x0);


  /* The FIR filter and IIR filter cannot coexist.  Clear the FIR filter in
  ** preparation for enabling the IIR filter.
  */
  if(coefficients->flag == QDSP_CMD_IIR_FILTER_ENABLE) {

#if defined(QDSP_txPcmFiltLoad)
    if ((uint32*)QDSP_txPcmFiltLoad != QDSP_NOP_ADDRESS) {
      qdsp_write(QDSP_txPcmFiltLoad, 0x0);
#if defined(QDSP_txPcmFiltCoeff)
      if ((uint32*)QDSP_rxPcmFiltCoeff != QDSP_NOP_ADDRESS) {
        qdsp_write_offset(QDSP_txPcmFiltCoeff, 6, 0x0000);
      }
#endif /* QDSP_rxPcmFiltCoeff */
      qdsp_write(QDSP_txPcmFiltLoad, 0xffff);
    }
#endif /* QDSP_txPcmFiltLoad */

    /* Since the ARM does not know when the QDSP is going to read these
    ** coefficients, make sure to wait for the maximum amount of time it takes
    ** for the QDSP to finish reading before updating the coefficients.  This
    ** wait is necessary to ensure that the QDSP will get the new coefficients.
    */
    #if defined (FEATURE_CMI_MM) || !defined(FEATURE_CMI)
    clk_busy_wait(50);
 	#else    		
#error code not present
	#endif

    /* Read Data structure containing PCM filter coefficients
    ** to fill in QDSP memory.
    */
#if defined(QDSP_txPcmIirACoeff1)
    if (((uint32*)QDSP_txPcmIirACoeff1 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 1))
    {
    qdsp_write_offset(QDSP_txPcmIirACoeff1, 0, coefficients->stage1.a1 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirACoeff1, 1, coefficients->stage1.a1 >> 16);
    qdsp_write_offset(QDSP_txPcmIirACoeff1, 2, coefficients->stage1.a2 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirACoeff1, 3, coefficients->stage1.a2 >> 16);
    }
#endif /*QDSP_txPcmIirACoeff1*/

#if defined(QDSP_txPcmIirACoeff2)
    if (((uint32*)QDSP_txPcmIirACoeff2 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 2))
    {
    qdsp_write_offset(QDSP_txPcmIirACoeff2, 0, coefficients->stage2.a1 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirACoeff2, 1, coefficients->stage2.a1 >> 16);
    qdsp_write_offset(QDSP_txPcmIirACoeff2, 2, coefficients->stage2.a2 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirACoeff2, 3, coefficients->stage2.a2 >> 16);
    }
#endif /*QDSP_txPcmIirACoeff2*/

#if defined(QDSP_txPcmIirACoeff3)
    if (((uint32*)QDSP_txPcmIirACoeff3 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 3))
    {
    qdsp_write_offset(QDSP_txPcmIirACoeff3, 0, coefficients->stage3.a1 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirACoeff3, 1, coefficients->stage3.a1 >> 16);
    qdsp_write_offset(QDSP_txPcmIirACoeff3, 2, coefficients->stage3.a2 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirACoeff3, 3, coefficients->stage3.a2 >> 16);
    }
#endif /*QDSP_txPcmIirACoeff3*/

#if defined(QDSP_txPcmIirACoeff4)
    if (((uint32*)QDSP_txPcmIirACoeff4 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 4))
    {
      qdsp_write_offset(QDSP_txPcmIirACoeff4, 0, coefficients->stage4.a1 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirACoeff4, 1, coefficients->stage4.a1 >> 16);
      qdsp_write_offset(QDSP_txPcmIirACoeff4, 2, coefficients->stage4.a2 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirACoeff4, 3, coefficients->stage4.a2 >> 16);
    }
#endif /*QDSP_txPcmIirACoeff4*/

#if defined(QDSP_txPcmIirACoeff5)
    if (((uint32*)QDSP_txPcmIirACoeff5 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 5))
    {
      qdsp_write_offset(QDSP_txPcmIirACoeff5, 0, coefficients->stage5.a1 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirACoeff5, 1, coefficients->stage5.a1 >> 16);
      qdsp_write_offset(QDSP_txPcmIirACoeff5, 2, coefficients->stage5.a2 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirACoeff5, 3, coefficients->stage5.a2 >> 16);
    }
#endif /*QDSP_txPcmIirACoeff5*/

#if defined(QDSP_txPcmIirBCoeff1)
    if (((uint32*)QDSP_txPcmIirBCoeff1 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 1))
    {
    qdsp_write_offset(QDSP_txPcmIirBCoeff1, 0, coefficients->stage1.b0 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirBCoeff1, 1, coefficients->stage1.b0 >> 16);
    qdsp_write_offset(QDSP_txPcmIirBCoeff1, 2, coefficients->stage1.b1 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirBCoeff1, 3, coefficients->stage1.b1 >> 16);
    qdsp_write_offset(QDSP_txPcmIirBCoeff1, 4, coefficients->stage1.b2 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirBCoeff1, 5, coefficients->stage1.b2 >> 16);
    }
#endif /*QDSP_txPcmIirBCoeff1*/

#if defined(QDSP_txPcmIirBCoeff2)
    if (((uint32*)QDSP_txPcmIirBCoeff2 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 2))
    {
    qdsp_write_offset(QDSP_txPcmIirBCoeff2, 0, coefficients->stage2.b0 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirBCoeff2, 1, coefficients->stage2.b0 >> 16);
    qdsp_write_offset(QDSP_txPcmIirBCoeff2, 2, coefficients->stage2.b1 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirBCoeff2, 3, coefficients->stage2.b1 >> 16);
    qdsp_write_offset(QDSP_txPcmIirBCoeff2, 4, coefficients->stage2.b2 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirBCoeff2, 5, coefficients->stage2.b2 >> 16);
    }
#endif /*QDSP_txPcmIirBCoeff2*/

#if defined(QDSP_txPcmIirBCoeff3)
    if (((uint32*)QDSP_txPcmIirBCoeff3 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 3))
    {
    qdsp_write_offset(QDSP_txPcmIirBCoeff3, 0, coefficients->stage3.b0 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirBCoeff3, 1, coefficients->stage3.b0 >> 16);
    qdsp_write_offset(QDSP_txPcmIirBCoeff3, 2, coefficients->stage3.b1 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirBCoeff3, 3, coefficients->stage3.b1 >> 16);
    qdsp_write_offset(QDSP_txPcmIirBCoeff3, 4, coefficients->stage3.b2 & 0xffff);
    qdsp_write_offset(QDSP_txPcmIirBCoeff3, 5, coefficients->stage3.b2 >> 16);
    }
#endif /*QDSP_txPcmIirBCoeff3*/

#if defined(QDSP_txPcmIirBCoeff4)
    if (((uint32*)QDSP_txPcmIirBCoeff4 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 4))
    {
      qdsp_write_offset(QDSP_txPcmIirBCoeff4, 0, coefficients->stage4.b0 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirBCoeff4, 1, coefficients->stage4.b0 >> 16);
      qdsp_write_offset(QDSP_txPcmIirBCoeff4, 2, coefficients->stage4.b1 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirBCoeff4, 3, coefficients->stage4.b1 >> 16);
      qdsp_write_offset(QDSP_txPcmIirBCoeff4, 4, coefficients->stage4.b2 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirBCoeff4, 5, coefficients->stage4.b2 >> 16);
    }
#endif /*QDSP_txPcmIirBCoeff4*/

#if defined(QDSP_txPcmIirBCoeff5)
    if (((uint32*)QDSP_txPcmIirBCoeff5 != QDSP_NOP_ADDRESS)&&
                                          (coefficients->stage_cnt >= 5))
    {
      qdsp_write_offset(QDSP_txPcmIirBCoeff5, 0, coefficients->stage5.b0 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirBCoeff5, 1, coefficients->stage5.b0 >> 16);
      qdsp_write_offset(QDSP_txPcmIirBCoeff5, 2, coefficients->stage5.b1 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirBCoeff5, 3, coefficients->stage5.b1 >> 16);
      qdsp_write_offset(QDSP_txPcmIirBCoeff5, 4, coefficients->stage5.b2 & 0xffff);
      qdsp_write_offset(QDSP_txPcmIirBCoeff5, 5, coefficients->stage5.b2 >> 16);
    }
#endif /*QDSP_txPcmIirBCoeff5*/


    /* Write -1 will instruct DSP to load the new PCM filter
    ** from the buffer of coefficients.
    */
    qdsp_write(QDSP_txIirPcmFilterSwitch, QDSP_CMD_IIR_FILTER_ENABLE);
  }

  return( QDSP_CMD_SUCCESS );
}
#endif /* FEATURE_IIR_FILTER */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_REGISTER

DESCRIPTION
  Registers with QDSP Services.
  Adds the current interrupt service routine.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_register (
  /* Vocoder client type */
  qdsp_cmd_qdsps_client_type voc_client,
  /* QDSP Services Application ID */
  qdsp_app_type qdsps_app_id,
  /* Pointer to the application's QDSP-to-ARM interrupt handler */
  qdsp_event_cb_type cb_ptr,
  /* Mask of events that the application needs to receive */
  uint16 event_mask
)
{
#ifdef MSMAUD_VOC_1X_COMMON
#ifdef QDSP_IMAGE_VOC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC]          = qdsp_cmd_voc_qdsp2_isr;
#endif
#endif /* MSMAUD_VOC_1X_COMMON */

#if defined(MSMAUD_VOC_AMR) || defined(MSMAUD_VOC_FR) || \
    defined(MSMAUD_VOC_EFR) || defined(MSMAUD_VOC_HR) || \
    defined(MSMAUD_VOC_1X_COMMON) || defined(MSMAUD_VOC_IS127_VOIP) || \
    defined(MSMAUD_VOC_4GV) || defined(MSMAUD_VOC_4GV_VOIP) || \
    defined(MSMAUD_VOC_G711)
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_COMBO]    =
                                                qdsp_cmd_voc_combo_image_isr;

#ifdef FEATURE_AMR_FIXED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AMR]    =
                                                qdsp_cmd_voc_combo_image_isr;
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_COMBO_VOIP]    =
                                                qdsp_cmd_voc_combo_image_isr;
#endif /* QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED */
#ifdef FEATURE_AVS_INCALL_MIXER_ADEC_PB
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_COMBO_ICA]    =
                                                qdsp_cmd_voc_combo_image_isr;
#endif /* QDSP_IMAGE_VOC_COMBO_ICA_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB */
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */

#ifdef QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QCAMCORDER_COMBO]    =
                                                  qdsp_cmd_voc_combo_image_isr;
#endif/*QDSP_IMAGE_QCAMCORDER_COMBO_DEFINED*/


#ifdef FEATURE_AVS_INCALL_MIXER_CMX
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_COMBO_SYNTH]    =
                                           qdsp_cmd_voc_combo_synth_isr;
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#endif /* FEATURE_AVS_INCALL_MIXER_CMX */
#endif  /* MSMAUD_VOC_AMR || MSMAUD_VOC_FR ||
           MSMAUD_VOC_EFR || MSMAUD_VOC_HR  ||
           MSMAUD_VOC_1X_COMMON || MSMAUD_VOC_IS127_VOIP ||
           MSMAUD_VOC_4GV || MSMAUD_VOC_4GV_VOIP ||
           MSMAUD_VOC_G711 */

#ifdef MSMAUD_VOC_1X_COMMON
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_MP3]      = qdsp_cmd_voc_qdsp2_isr;
#endif

#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_EVRC_MP3] = qdsp_cmd_voc_qdsp2_isr;
#endif

#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_EVRC]     = qdsp_cmd_voc_qdsp2_isr;
#endif

#ifdef QDSP_IMAGE_VOC_E90_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_E90]      = qdsp_cmd_voc_qdsp2_isr;
#endif

#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_EVRC_E90] = qdsp_cmd_voc_qdsp2_isr;
#endif
#endif  /* MSMAUD_VOC_1X_COMMON */

#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VOC_QTV] = qdsp_cmd_voc_qtv_image_isr;
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */

#ifdef MSMAUD_VOC_1X_COMMON
#ifdef FEATURE_QVPHONE
#ifdef QDSP_IMAGE_QVP_MPEG4_EVRC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QVP_MPEG4_EVRC]
                                                    = qdsp_cmd_voc_qdsp2_isr;
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_EVRC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QVP_H263P3_EVRC]
                                                    = qdsp_cmd_voc_qdsp2_isr;
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_4GVWB_DEFINED
#error code not present
#endif
#ifdef  QDSP_IMAGE_QVP_H263P3_4GVWB_DEFINED
#error code not present
#endif

#endif /* FEATURE_QVPHONE */

#ifdef MSMAUD_VOC_4GV_WB
#ifdef QDSP_IMAGE_4GV_WB_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_4GV_WB]          = qdsp_cmd_voc_qdsp2_isr;
#endif
#endif

#ifdef MSMAUD_VOC_4GV
#ifdef QDSP_IMAGE_4GV_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_4GV]          = qdsp_cmd_voc_qdsp2_isr;
#endif
#ifdef QDSP_IMAGE_4GV_VOIP_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_4GV_VOIP]     = qdsp_cmd_voc_qdsp2_isr;
#endif
#endif  /* MSMAUD_VOC_4GV */
#endif  /* MSMAUD_VOC_1X_COMMON */

#ifdef FEATURE_QSYNTH_COMMON
#ifdef QDSP_IMAGE_SYNTH_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_SYNTH]        = qdsp_cmd_synth_qdsp2_isr;
#endif

#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif

#ifdef QDSP_IMAGE_Q3D_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_Q3D]          = qdsp_cmd_synth_qdsp2_isr;
#endif

#ifdef QDSP_IMAGE_QGL_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QGL] = qdsp_cmd_synth_qdsp2_isr;
#endif

  /* Initialize Clock Services call-back data structures */
   	#ifdef FEATURE_CMI
#error code not present
	#else
    		clk_def(&qdsp_cmd_qsynth_cmd_clk_cb);
	#endif
#endif /* FEATURE_QSYNTH_COMMON */

#if defined(FEATURE_QSYNTH_COMMON) || defined(FEATURE_QTUNES_COMMON )
  /* Initialize Clock Services call-back data structures */
  
  	#ifdef FEATURE_CMI
#error code not present
	#else
    		clk_def( &qdsp_cmd_audfmt_dtmf_clk_cb );
	#endif
#endif /* FEATURE_QSYNTH_COMMON || FEATURE_QTUNES_COMMON */

#ifdef FEATURE_AUDIO_QENSEMBLE
#error code not present
#endif /* FEATURE_AUDIO_QENSEMBLE*/

#ifdef FEATURE_QTUNES_COMMON
#ifdef QDSP_IMAGE_TUNES_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_TUNES] = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_TUNES_DEFINED */

#ifdef FEATURE_AUDIO_CAMERA_CONCURRENCY
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_CAM_AUDIO_CONC] =  qdsp_cmd_adpcm_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
#endif /* FEATURE_AUDIO_CAMERA_CONCURRENCY */

#ifdef QDSP_IMAGE_AAC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AAC]   = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_AAC_DEFINED */

#ifdef QDSP_IMAGE_ENH_AAC_PLUS_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_ENH_AAC_PLUS]
                                             = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_ENH_AAC_PLUS_DEFINED */

#ifdef QDSP_IMAGE_QTV_AAC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QTV_AAC]
                                             = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_QTV_AAC_DEFINED */

#ifdef QDSP_IMAGE_QTV_AAC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_DEFINED */

#ifdef QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED */

#ifdef FEATURE_GRAPH_AUDIO
#ifdef QDSP_IMAGE_H263D_MP3_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_H263D_MP3]
                                             = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_H263D_MP3_DEFINED */

#ifdef QDSP_IMAGE_H263D_AAC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_H263D_AAC]
                                             = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_H263D_AAC_DEFINED */

#ifdef QDSP_IMAGE_H264D_AAC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_H264D_AAC]
                                             = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_H264D_AAC_DEFINED */

#ifdef QDSP_IMAGE_MP4D_MP3_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4D_MP3]
                                             = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_MP4D_MP3_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AAC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4D_AAC]
                                             = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_MP4D_AAC_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4D_AAC_PLUS]
                                             = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4D_AAC_NO_VPP]
                                             = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED */
#endif /* FEATURE_GRAPH_AUDIO */
#endif /* FEATURE_QTUNES_COMMON */

#ifdef QDSP_IMAGE_RA_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_RA]    = qdsp_cmd_tunes_qdsp2_isr;
#endif /* QDSP_IMAGE_RA_DEFINED */

#ifdef QDSP_IMAGE_WM_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_WM]    = qdsp_cmd_tunes_qdsp2_isr;
#endif

#ifdef QDSP_IMAGE_WM_PRO_DEFINED
#error code not present
#endif

#ifdef MSMAUD_VOC_1X_COMMON
#if defined(FEATURE_TTY) && !defined(MSMAUD_INTEGRATED_TTY)
  qdsp_cmd_image_isr_table[QDSP_IMAGE_TTY]   = qdsp_cmd_voc_qdsp2_isr;
#endif /* defined(FEATURE_TTY) && !defined(MSMAUD_INTEGRATED_TTY) */
#endif /* MSMAUD_VOC_1X_COMMON */

#ifdef FEATURE_PHONE_VR
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VRBC]  = qdsp_cmd_vr_qdsp2_isr;
#ifdef FEATURE_VR_PUFE
#error code not present
#endif /* FEATURE_VR_PUFE */
#endif /* FEATURE_PHONE_VR */

#ifdef MSMAUD_VOC_AMR_WB_COMMON
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AMR_WB] = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#endif  /* MSMAUD_VOC_AMR_WB_COMMON */

#ifdef MSMAUD_VOC_AMR
#ifdef QDSP_IMAGE_AMR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AMR]   = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AMR_MP3] = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#ifdef QDSP_IMAGE_AMR_YCBCR2_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AMR_YCBCR2]
                                             = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#ifdef FEATURE_QVPHONE
#ifdef QDSP_IMAGE_QVP_YUV_AMR_H263_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QVP_YUV_AMR_H263]
                                             = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#ifdef QDSP_IMAGE_QVP_YUV_AMR_MPEG4_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QVP_YUV_AMR_MPEG4]
                                             = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_AMR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QVP_H263P3_AMR]
                                             = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#ifdef QDSP_IMAGE_QVP_H263P3_G723_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QVP_H263P3_G723]
                                             = qdsp_cmd_wlan_voc_isr;
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_G723_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QVP_MPEG4_G723]
                                             = qdsp_cmd_wlan_voc_isr;
#endif
#ifdef QDSP_IMAGE_QVP_BAYER_AMR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QVP_BAYER_AMR]
                                             = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#ifdef QDSP_IMAGE_QVP_MPEG4_AMR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QVP_MPEG4_AMR]
                                             = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#endif /* FEATURE_QVPHONE */
#endif /* MSMAUD_VOC_AMR */

#ifdef MSMAUD_VOC_EFR
#error code not present
#endif /* MSMAUD_VOC_EFR */

#ifdef MSMAUD_VOC_FR
#error code not present
#endif  /* MSMAUD_VOC_FR */

#ifdef MSMAUD_VOC_HR
#ifdef QDSP_IMAGE_HR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_HR]    = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_HR_MP3]= qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#ifdef QDSP_IMAGE_HR_YCBCR2_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_HR_YCBCR2]
                                             = qdsp_cmd_gsm_voc_qdsp_isr;
#endif
#endif  /* MSMAUD_VOC_HR */

#ifdef FEATURE_GRAPH_AUDIO
#ifdef QDSP_IMAGE_H263D_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_H263D] = qdsp_cmd_graph_1x_dec_isr;
#endif /* QDSP_IMAGE_H263D_DEFINED */

#ifdef QDSP_IMAGE_H263D_AMR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_H263D_AMR]
                                             = qdsp_cmd_graph_amr_dec_isr;
#endif /* QDSP_IMAGE_H263D_AMR_DEFINED */

#ifdef QDSP_IMAGE_H264D_AMR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_H264D_AMR]
                                             = qdsp_cmd_graph_amr_dec_isr;
#endif /* QDSP_IMAGE_H264D_AMR_DEFINED */

#ifdef QDSP_IMAGE_MP4D_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4D]  = qdsp_cmd_graph_1x_dec_isr;
#endif /* QDSP_IMAGE_MP4D_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AMR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4D_AMR]
                                             = qdsp_cmd_graph_amr_dec_isr;
#endif /* QDSP_IMAGE_MP4D_AMR_DEFINED */

#ifdef QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4D_AMR_EVRC_V13K]
                                             = qdsp_cmd_graph_audio_dec_isr;
#endif /* QDSP_IMAGE_MP4D_AMR_EVRC_V13K_DEFINED */

#ifdef QDSP_IMAGE_QTV_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QTV]
                                             = qdsp_cmd_graph_audio_dec_isr;
#endif /* QDSP_IMAGE_QTV_DEFINED */

#ifdef QDSP_IMAGE_QTV_VOC_H264_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_DEFINED */

#ifdef QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED
#error code not present
#endif /* QDSP_IMAGE_QTV_VOC_H264_TURBO_DEFINED */

#ifdef QDSP_IMAGE_H264D_EVRC_DEFINED
#error code not present
#endif /* QDSP_IMAGE_H264D_EVRC_DEFINED */

#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VFE_BAYER]
                                             = qdsp_cmd_graph_audio_dec_isr;
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */

#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_VFE_YCBCR]
                                             = qdsp_cmd_graph_audio_dec_isr;
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */

#ifdef QDSP_IMAGE_QCAMERA_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QCAMERA]
                                             = qdsp_cmd_graph_audio_dec_isr;
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */

#ifdef QDSP_IMAGE_MP4E_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4E]
                                             = qdsp_cmd_graph_audio_enc_isr;
#endif /* QDSP_IMAGE_MP4E_DEFINED */

#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4E_BAYER]
                                             = qdsp_cmd_graph_audio_enc_isr;
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */

#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4E_13K]
                                             = qdsp_cmd_graph_audio_enc_isr;
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */

#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4E_EVRC]
                                             = qdsp_cmd_graph_audio_enc_isr;
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */

#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_MP4E_AMR]
                                             = qdsp_cmd_graph_audio_enc_isr;
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */

#ifdef QDSP_IMAGE_AUDDUB_13K_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AUDDUB_13K]
                                             = qdsp_cmd_graph_1x_enc_isr;
#endif /* QDSP_IMAGE_AUDDUB_13K_DEFINED */

#ifdef QDSP_IMAGE_AUDDUB_EVRC_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AUDDUB_EVRC]
                                             = qdsp_cmd_graph_1x_enc_isr;
#endif /* QDSP_IMAGE_AUDDUB_EVRC_DEFINED */

#ifdef QDSP_IMAGE_AUDDUB_AMR_DEFINED
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AUDDUB_AMR]
                                             = qdsp_cmd_graph_amr_enc_isr;
#endif /* QDSP_IMAGE_AUDDUB_AMR_DEFINED */

#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
  /* MultiMedie encoder isr implement */
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QCAMCORDER_AACENC]
                                             = qdsp_cmd_mm_rec_qdsp2_isr;
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */

#ifdef QDSP_IMAGE_AACENC_DEFINED
  /* MultiMedie encoder isr implement */
  qdsp_cmd_image_isr_table[QDSP_IMAGE_AACENC]
                                             = qdsp_cmd_mm_rec_qdsp2_isr;
#endif /* QDSP_IMAGE_AACENC_DEFINED */

#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
  /* MultiMedie encoder isr implement */
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QCAMCORDER]
                                             = qdsp_cmd_graph_audio_enc_isr;
#endif
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */

#endif /* FEATURE_GRAPH_AUDIO */

#if defined(QDSP_IMAGE_G711_DEFINED) && defined(MSMAUD_VOC_G711)
  qdsp_cmd_image_isr_table[QDSP_IMAGE_G711]  = qdsp_cmd_wlan_voc_isr;
#endif /* QDSP_IMAGE_G711_DEFINED && MSMAUD_VOC_G711 */


#ifdef FEATURE_AVS_I2SSBC
#ifdef QDSP_IMAGE_I2SSBC_DEFINED
  /* I2S SBC encoder isr */
  // Yangdecai for BT
	#if defined(FEATURE_ARM_POST_PROCESSING) || \
    defined (FEATURE_AVS_WB_PCM_RX_INTERFACE)
  		qdsp_cmd_image_isr_table[QDSP_IMAGE_I2SSBC] = qdsp_cmd_arm_pp_isr;
	#endif
#endif /* QDSP_IMAGE_I2SSBC_DEFINED */
#endif /* FEATURE_AVS_I2SSBC */


#if defined(FEATURE_QTUNES_COMMON)         && \
    defined(FEATURE_AMR_WBPLUS_AUDIO_DEC)  && \
    defined(QDSP_IMAGE_QTV_CONC_DEFINED)
  qdsp_cmd_image_isr_table[QDSP_IMAGE_QTV_CONC] = qdsp_cmd_tunes_qdsp2_isr;
#endif /* FEATURE_QTUNES_COMMON       && FEATURE_AMR_WBPLUS_AUDIO_DEC &&
          QDSP_IMAGE_QTV_CONC_DEFINED */

  if (voc_client < QDSP_CMD_QDSPS_CLIENT_MAX && qdsps_app_id < QDSP_APP_MAX) {
    qdsp_cmd_qdsps_clients[voc_client] = qdsps_app_id;
    qdsp_event_cb   = cb_ptr;
    qdsp_event_mask = event_mask;

    /* Register with QDSP Services
    */
    qdsp_register_app (
      qdsps_app_id,
      qdsp_cmd_isr_table,
      qdsp_event_cb,
      qdsp_event_mask
    );
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SET_IMAGE

DESCRIPTION
  Sets the ISR routine that QDSP Services will call based on the image,
  and the current active module in response to event MODULE from
  QDSP services.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_set_image (
  qdsp_image_type image_select,
  qdsp_module_type module_select
)
{
  /* Avoid out of bound array access */
  if(image_select >= QDSP_IMAGE_MAX)
  {
    MSG_ERROR("Invalid image: %d", image_select, 0, 0);
    return;
  }

  /* Save the image selection */
  qdsp_cmd_image_select = image_select;
  qdsp_cmd_set_isr(qdsp_cmd_image_isr_table[image_select]);

  if (qdsp_cmd_min_frame_rate > QDSP_RATE_FULL_V) {
    qdsp_cmd_min_frame_rate = QDSP_RATE_BLANK_V;
  }
  if (qdsp_cmd_max_frame_rate > QDSP_RATE_FULL_V) {
    qdsp_cmd_max_frame_rate = QDSP_RATE_FULL_V;
  }
  if (qdsp_cmd_enc_frame_rate > QDSP_RATE_FULL_V) {
    qdsp_cmd_enc_frame_rate = QDSP_RATE_EIGHTH_V;
  }
  if (qdsp_cmd_dec_frame_rate > QDSP_RATE_FULL_V) {
    qdsp_cmd_dec_frame_rate = QDSP_RATE_EIGHTH_V;
  }
  /* Save the module selection. qdspcmd will now know which module is loaded.
     This avoids accessing DMA variables which get swapped out depending on
     the module loaded.
  */
  qdsp_cmd_module_select = module_select;
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_CLEAR_DSP_ISR

DESCRIPTION
  Clears the ISR registered with QDSP Services.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_clear_dsp_isr (void)
{
  qdsp_cmd_set_isr(NULL);
  /* Clear the module selection */
  qdsp_cmd_module_select = QDSP_MODULE_MAX;
}

/* <EJECT> */
#ifdef FEATURE_PHONE_VR
/*===========================================================================

FUNCTION QDSP_CMD_VR_BASIC (command 0x1002)

DESCRIPTION
  This function will send a command to the DSP to perform VR Basic mode
  operation.

DEPENDENCIES
  This command is only valid when the DSP is in VR IDLE state.

RETURN VALUE
  QDSP_CMD_SUCCESS - The command was successful
  QDSP_CMD_FAILED  - The command failed

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_vr_basic (
  uint16 vr_basic_control
)
{
   qdsp_cmd_status_type result;             /* Store the return value       */

   uint16 vr_basic_command[3];              /* Local buffer for the command */

   vr_basic_command[0] = VR_BASIC_CMD_SIZE; /* Length of the command */
   vr_basic_command[1] = VR_BASIC_CMD_HDR;  /* Command header */
   vr_basic_command[2] = vr_basic_control;  /* VR Basic Control */

  /* Now send the VR BASIC command to the QDSP2 */
  if( (result = qdsp2_command( vr_basic_command ))
       != QDSP_CMD_SUCCESS )
  {
     MSG_ERROR("QDSP2 VR BASIC Command Error!", 0, 0, 0);
  }

  return( result );
}
#endif /* FEATURE_PHONE_VR */

/* <EJECT> */
#ifdef FEATURE_VOICE_PLAYBACK
/*===========================================================================

FUNCTION qdsp_cmd_start_vp

DESCRIPTION
  This function will tell the QDSP driver to play a voice prompt.

DEPENDENCIES
  FEATURE_VOICE_PLAYBACK

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_vp_rx_playing
  qdsp_cmd_vp_tx_playing
  qdsp_cmd_get_vp_rx_frame
  qdsp_cmd_get_vp_tx_frame

===========================================================================*/
void qdsp_cmd_start_vp (
  qdsp_cmd_vp_path_enum_type    path,     /* Path to play VP to           */
  qdsp_cmd_get_vp_frame_fn_type   cb_func,  /* fn pointer to get frame data   */
  qdsp_cmd_vp_mux_type            in_call,  /* If this is to be muxed incall  */
  qdsp_cmd_second_dec_config_type sec_dec_config /* Sec dec config if incall  */
)
{
  if(path == QDSP_CMD_VP_RX) {
    qdsp_cmd_vp_rx_playing   = TRUE;
    qdsp_cmd_get_vp_rx_frame = cb_func;
  } else {
    qdsp_cmd_vp_tx_playing   = TRUE;
    qdsp_cmd_get_vp_tx_frame = cb_func;
  }

  if (in_call) {
    qdsp_cmd_vp_incall_mux     = in_call;
    qdsp_cmd_second_dec_config = sec_dec_config;
  }else {
    qdsp_cmd_vp_incall_mux     = QDSP_CMD_VP_MUX_NONE;
    qdsp_cmd_second_dec_config = QDSP_CMD_SECOND_DEC_CONFIG_NONE;
  }

  qdsp_cmd_vp_direction = path;
  qdsp_cmd_vp_paused    = FALSE;
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_end_vp

DESCRIPTION
  This function will tell the QDSP driver to play a voice prompt.

DEPENDENCIES
  FEATURE_VOICE_PLAYBACK

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_vp_rx_playing
  qdsp_cmd_vp_tx_playing
  qdsp_cmd_get_vp_rx_frame
  qdsp_cmd_get_vp_tx_frame

===========================================================================*/
void qdsp_cmd_end_vp (
  qdsp_cmd_vp_path_enum_type path
)
{
  if(path == QDSP_CMD_VP_RX) {
    qdsp_cmd_vp_rx_playing   = FALSE;
    qdsp_cmd_get_vp_rx_frame = NULL;
  } else {
    qdsp_cmd_vp_tx_playing   = FALSE;
    qdsp_cmd_get_vp_tx_frame = NULL;
  }

  qdsp_cmd_vp_incall_mux           = QDSP_CMD_VP_MUX_NONE;
  qdsp_cmd_vp_incall_mux_pause     = QDSP_CMD_VP_MUX_NONE;
  qdsp_cmd_second_dec_config = QDSP_CMD_SECOND_DEC_CONFIG_NONE;
  qdsp_cmd_vp_paused = FALSE;
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_pause_pb

DESCRIPTION
  This function will tell the QDSP driver to pause voice playback.

DEPENDENCIES
  FEATURE_VOICE_PLAYBACK

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void qdsp_cmd_pause_pb ( void )
{
  INTLOCK();
  if(qdsp_cmd_vp_direction == QDSP_CMD_VP_RX) {
    qdsp_cmd_vp_rx_playing   = FALSE;
  } else {
    qdsp_cmd_vp_tx_playing   = FALSE;
  }

#ifdef FEATURE_AUDIO_FORMAT
  qdsp_cmd_av_sync_voc_cb();
#endif /* FEATURE_AUDIO_FORMAT */
  qdsp_cmd_vp_paused = TRUE;
  qdsp_cmd_vp_incall_mux_pause     = qdsp_cmd_vp_incall_mux;
  qdsp_cmd_vp_incall_mux           = QDSP_CMD_VP_MUX_NONE;
  INTFREE();
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_resume_pb

DESCRIPTION
  This function will tell the QDSP driver to resume voice playback.

DEPENDENCIES
  FEATURE_VOICE_PLAYBACK

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_vp_rx_playing

===========================================================================*/
void qdsp_cmd_resume_pb ( void )
{
  INTLOCK();
  if(qdsp_cmd_vp_direction == QDSP_CMD_VP_RX) {
    qdsp_cmd_vp_rx_playing   = TRUE;
  } else {
    qdsp_cmd_vp_tx_playing   = TRUE;
  }

  qdsp_cmd_vp_paused = FALSE;
  /* Reinstate the incall mux to pre pause state */
  qdsp_cmd_vp_incall_mux           = qdsp_cmd_vp_incall_mux_pause;
  qdsp_cmd_vp_incall_mux_pause     = QDSP_CMD_VP_MUX_NONE;
  INTFREE();
}

#endif /* FEATURE_VOICE_PLAYBACK */

/* <EJECT> */
#ifdef FEATURE_PHONE_VR
/*===========================================================================

FUNCTION qdsp_cmd_vr_set_rate

DESCRIPTION
  This function sets the max rate and min rate for the voice recording
  and the utterance capture.

DEPENDENCIES
  FEATURE_PHONE_VR || FEATURE_VOICE_RECORD

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_vr_max_frame_rate
  qdsp_cmd_vr_min_frame_rate

===========================================================================*/
void qdsp_cmd_vr_set_rate (
  uint16   max_rate,
  uint16   min_rate
)
{
  qdsp_cmd_vr_max_frame_rate = max_rate;
  qdsp_cmd_vr_min_frame_rate = min_rate;

  qdsp_write(QDSP_encMinRate, qdsp_cmd_vr_min_frame_rate);
  qdsp_write(QDSP_encMaxRate, qdsp_cmd_vr_max_frame_rate);
}

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_CMD_SND_STATUS

DESCRIPTION
  This function is called by the Vocoder driver everytime Sound starts or
  stops playing a tone.  This function allows the Vocoder driver to handle
  talk over prompt feature in capture mode.

DEPENDENCIES
  FEATURE_PHONE_VR is defined.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_cmd_snd_status (
  boolean snd_play_stat
)
{

  /* inform qdsp driver sound status */

  if (snd_play_stat == VOC_SND_STATUS_ACTIVE)
  {
     qdsp_cmd_snd_active_status = TRUE;
  }
  else
  {
     qdsp_cmd_snd_active_status = FALSE;
  }

} /* end qdsp_cmd_snd_status */
#endif /* FEATURE_PHONE_VR */

/* <EJECT> */
#ifdef FEATURE_VOICE_RECORD
/*===========================================================================

FUNCTION qdsp_cmd_start_rec

DESCRIPTION
  This function will tell the QDSP driver to start recording.

DEPENDENCIES
  FEATURE_VOICE_RECORD

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_min_frame_rate
  qdsp_cmd_max_frame_rate
  qdsp_cmd_rec_min_frame_rate
  qdsp_cmd_rec_max_frame_rate
  qdsp_cmd_rec_frame_fn
  qdsp_cmd_rec_dir

===========================================================================*/
void qdsp_cmd_start_rec (
  qdsp_cmd_rec_dir_enum_type    dir,      /* Path to record voice */
  qdsp_cmd_rec_fn_type          cb_func,  /* fn pointer to callback */
  uint16                        min_rate,
  uint16                        max_rate
)
{
  qdsp_cmd_min_frame_rate     = min_rate;
  qdsp_cmd_max_frame_rate     = max_rate;
  qdsp_cmd_rec_min_frame_rate = qdsp_cmd_min_frame_rate;
  qdsp_cmd_rec_max_frame_rate = qdsp_cmd_max_frame_rate;

  qdsp_write(QDSP_encMinRate, qdsp_cmd_min_frame_rate);
  qdsp_write(QDSP_encMaxRate, qdsp_cmd_max_frame_rate);

  /* Save the function pointer used to record a frame.
  */
  qdsp_cmd_rec_frame_fn = cb_func;

  /* Set the recording direction and disable microphone muting changes.
  */
  qdsp_cmd_rec_dir = dir;

  /* Unmute tx for reverse link recording only.
  */
  if ((dir == QDSP_CMD_REC_REVERSE) || (dir == QDSP_CMD_REC_BOTH)
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
     ) {
    qdsp_cmd_tx_comfort_noise_ctrl(QDSP_COMFORT_NOISE_DIS_V);
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_end_rec

DESCRIPTION
  This function will tell the QDSP driver to stop recording.

DEPENDENCIES
  FEATURE_VOICE_RECORD

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_rec_frame_fn
  qdsp_cmd_rec_dir

===========================================================================*/
void qdsp_cmd_end_rec ( void )
{
  /* Indicate that recording is disabled and enable microphone muting changes
  */
  qdsp_cmd_rec_dir       = QDSP_CMD_REC_NONE;
  qdsp_cmd_rec_dir_pause = QDSP_CMD_REC_NONE;

  qdsp_cmd_rec_frame_fn = NULL;
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_pause_rec

DESCRIPTION
  This function will tell the QDSP driver to pause recording.

DEPENDENCIES
  FEATURE_VOICE_RECORD

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_rec_dir_pause
  qdsp_cmd_rec_dir

===========================================================================*/
void qdsp_cmd_pause_rec ( void )
{
  if((qdsp_cmd_rec_dir != QDSP_CMD_REC_NONE) &&
     (qdsp_cmd_rec_dir_pause == QDSP_CMD_REC_NONE)) {
    /* Save the direction so recording can be resumed.
    */
    qdsp_cmd_rec_dir_pause = qdsp_cmd_rec_dir;

    /* Put back previously saved tx comfort noise enable flag.
    */
    qdsp_cmd_restore_comfort_noise();

    /* Indicate that recording is disabled and enable microphone muting changes
    */
    qdsp_cmd_rec_dir = QDSP_CMD_REC_NONE;
  }
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_resume_rec

DESCRIPTION
  This function will tell the QDSP driver to resume recording.

DEPENDENCIES
  FEATURE_VOICE_RECORD

RETURN VALUE
  None

SIDE EFFECTS
  qdsp_cmd_min_frame_rate
  qdsp_cmd_max_frame_rate
  qdsp_cmd_rec_dir
  qdsp_cmd_rec_dir_pause

===========================================================================*/
void qdsp_cmd_resume_rec ( void )
{
  if((qdsp_cmd_rec_dir == QDSP_CMD_REC_NONE) &&
     (qdsp_cmd_rec_dir_pause != QDSP_CMD_REC_NONE)) {
    /* Restore the min and max frame rates used for recording.
    */
    qdsp_cmd_min_frame_rate = qdsp_cmd_rec_min_frame_rate;
    qdsp_cmd_max_frame_rate = qdsp_cmd_rec_max_frame_rate;
    qdsp_write(QDSP_encMinRate, qdsp_cmd_min_frame_rate);
    qdsp_write(QDSP_encMaxRate, qdsp_cmd_max_frame_rate);

#ifdef FEATURE_AMR_REC_HOMING_SEQUENCE
    /* Tell amr enc and dec ISRs that we have just resumed recording
    ** and they should insert a homing sequence in the recorded stream
    */
    if (qdsp_voc_mode == QDSP_VOC_MODE_AMR_V) {
      switch (qdsp_cmd_rec_dir_pause) {
        case QDSP_CMD_REC_BOTH:
          qdsp_cmd_reverse_recording_resumed = TRUE;
          qdsp_cmd_forward_recording_resumed = TRUE;
          break;
        case QDSP_CMD_REC_REVERSE:
          qdsp_cmd_reverse_recording_resumed = TRUE;
          break;
        case QDSP_CMD_REC_FORWARD:
          qdsp_cmd_forward_recording_resumed = TRUE;
          break;
      }
    }
#endif /* FEATURE_AMR_REC_HOMING_SEQUENCE */

    /* Unmute tx for reverse link recording only.
    */
    if ((qdsp_cmd_rec_dir_pause == QDSP_CMD_REC_REVERSE) ||
        (qdsp_cmd_rec_dir_pause == QDSP_CMD_REC_BOTH)
#ifdef FEATURE_ACP
#error code not present
#endif /* FEATURE_ACP */
       ) {
      qdsp_cmd_tx_comfort_noise_ctrl(QDSP_COMFORT_NOISE_DIS_V);
    } else {
      qdsp_cmd_restore_comfort_noise();
    }

    /* Restore the recording direction and disable microphone muting changes.
    */
    qdsp_cmd_rec_dir        = qdsp_cmd_rec_dir_pause;

    /* Indicate that recording is not paused.
    */
    qdsp_cmd_rec_dir_pause  = QDSP_CMD_REC_NONE;
  }
}
#endif /* FEATURE_VOICE_RECORD */

/* <EJECT> */
#if defined( FEATURE_ACP ) && defined( FEATURE_VOICE_RECORD )
#error code not present
#endif /* FEATURE_ACP && FEATURE_VOICE_RECORD */

/* <EJECT> */
#ifdef FEATURE_PHONE_VR
/*===========================================================================

                FUNCTIONS FOR MODE B/C VR SUPPORT

===========================================================================*/

/*===========================================================================

FUNCTION qdsp_cmd_match_result

DESCRIPTION
  If a VR match result message is available from the QDSP2, this function
  converts DSP addresses to ARM addresses and returns the appropriate VR match
  result message data.

  In the original design, the VR match result message was sent via an interrupt,
  however, it was discovered that there was a small window which the DSP might
  send an interrupt and the ARM might miss it (only applied to VR match result
  messages.)  In the current design, the ARM polls the DSP for VR match result
  messages in the background task.

DEPENDENCIES
  This function depends on all VR mode B/C vocoder initialization taking
  place first.

RETURN VALUE
  Ptr to match data

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_match_result_type *qdsp_cmd_match_result ( void )
{
  uint32 temp_addr = 0L;
  uint16 memory_bank;
  uint16 dsp_score_addr;  /* Addr given by DSP to read VR scores    */
  uint16 dsp_dl_pat_addr; /* Addr given by DSP to download patterns */
  static qdsp_cmd_match_result_type qdsp_cmd_match_result;

  /* Clear match result.
  */
  (void) memset (&qdsp_cmd_match_result, 0, sizeof (qdsp_cmd_match_result));

  if (qdsp_read (QDSP_dspMessageReg) != VR_MATCH_RESULT_MSG)
  {
    return (&qdsp_cmd_match_result);
  }

  /* Save match result message from DSP to RAM.
  */
  qdsp_cmd_match_result.num_vr_scores = qdsp_read_offset (QDSP_dspMessageBuf,0);
  dsp_score_addr                      = qdsp_read_offset (QDSP_dspMessageBuf,1);
  dsp_dl_pat_addr                     = qdsp_read_offset (QDSP_dspMessageBuf,2);
  qdsp_cmd_match_result.pat_buf_size  = qdsp_read_offset (QDSP_dspMessageBuf,3);

  /* Calculate DMA address to read pattern from DSP for training.
  */
  qdsp_cmd_match_result.dma_tr_pat_addr = (uint16 *)
  qdsp_address ( QDSP_testTemplateBuf, 0);

  /* Calculate DMA address to read VR scores from DSP.  VR scores are always
  ** stored in DSP RAM A address space.
  */
  temp_addr = (uint32) qdsp_bank_address (QDSP_BANK_RAMA, dsp_score_addr);
  qdsp_cmd_match_result.dma_score_addr = (uint16 *) temp_addr;

  /* Calculate DMA address to download pattern to DSP.  Determine if address
  ** is for DSP RAM A or RAM B address space.
  */
  memory_bank = dsp_dl_pat_addr & QDSP_VR_DL_MEM_BANK_M;
  dsp_dl_pat_addr &= QDSP_VR_DL_ADDR_M;
  if (memory_bank == QDSP_VR_DL_RAMB_V)
  {
    temp_addr = (uint32) qdsp_bank_address (QDSP_BANK_RAMB, dsp_dl_pat_addr);
  }
  else
  {
    temp_addr = (uint32) qdsp_bank_address (QDSP_BANK_RAMA, dsp_dl_pat_addr);
  }

  /* Save the DMA address to write number of patterns to download and the DMA
  ** address to download pattern data.
  */
  qdsp_cmd_match_result.dma_dl_num_addr  = (uint16 *) (temp_addr);
  qdsp_cmd_match_result.dma_dl_data_addr =
  qdsp_cmd_match_result.dma_dl_num_addr + 1;

  /* Make sure all calculated addresses are within DMA address range.  Length
  ** of block is specified in bytes.
  */
  if (qdsp_cmd_match_result.num_vr_scores > MAX_NUM_VR_SCORE)
  {
    qdsp_cmd_match_result.valid_addr = FALSE;
  }
  else if (qdsp_valid_address (qdsp_cmd_match_result.dma_score_addr,
                                (MAX_NUM_VR_SCORE * 2)) == FALSE)
  {
    qdsp_cmd_match_result.valid_addr = FALSE;
  }
  else if (qdsp_valid_address (qdsp_cmd_match_result.dma_tr_pat_addr,
                                (MAX_SD_PAT_WORDS * 2)) == FALSE)
  {
    qdsp_cmd_match_result.valid_addr = FALSE;
  }
  else if (qdsp_valid_address (qdsp_cmd_match_result.dma_dl_num_addr,
                               (qdsp_cmd_match_result.pat_buf_size * 2)) ==
           FALSE)
  {
    qdsp_cmd_match_result.valid_addr = FALSE;
  }
  else if (qdsp_valid_address (qdsp_cmd_match_result.dma_dl_data_addr,
                               (qdsp_cmd_match_result.pat_buf_size * 2)) ==
           FALSE)
  {
    qdsp_cmd_match_result.valid_addr = FALSE;
  }
  else
  {
    qdsp_cmd_match_result.valid_addr = TRUE;
  }

  MSG_MED ("Mres,%d scores,1st:%d,dladdr:%lx",
           qdsp_cmd_match_result.num_vr_scores,
           *(qdsp_cmd_match_result.dma_score_addr),
           qdsp_cmd_match_result.dma_dl_num_addr
          );

  /* Report match result.
  */
  qdsp_cmd_match_result.match_res_avail = TRUE;

  /* Host clears the semaphore flag when read.
  */
  qdsp_write (QDSP_dspMessageReg, 0);

  return (&qdsp_cmd_match_result);

} /* end qdsp_cmd_match_result */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_vr_codec_config

DESCRIPTION
  This function will send a command to the DSP to configure the codec,
  PCM audio path selection and PCM format selection.

  If the VR software version number specified in the command is invalid, the
  DSP will report a VR Initialization error and reject all VR related
  commands.

DEPENDENCIES
  The current DSP image must support VR Mode B/C.
  This command is only valid when the DSP is in INIT state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  Transition DSP to VR IDLE state if VR software version number is valid.

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_vr_codec_config (
  const qdsp_cmd_codec_config_type *data,        /* Command data to send   */
  uint16                           vr_sw_version /* Software version       */
)

{
  uint16 vr_cmd_buf[VR_CODEC_CONFIG_CMD_SIZE];
  qdsp_cmd_status_type result = QDSP_CMD_SUCCESS;

#ifdef MSMAUD_UP_DMA_PATH_CONTROL_VR
  /* Setup the DMA channels */
  qdsp_write( QDSP_upDmaPathControl, 0 );
#endif /* MSMAUD_UP_DMA_PATH_CONTROL_VR */
  /* Compose VR CODEC Configuration command.
  */
  vr_cmd_buf [0] = VR_CODEC_CONFIG_CMD_SIZE;
  vr_cmd_buf [1] = VR_CODEC_CONFIG_CMD_HDR;
  vr_cmd_buf [2] = data->pcm_format_ctrl;
  vr_cmd_buf [3] = data->pcm_ctrl;
  vr_cmd_buf [4] = data->codec_func_ctrl;
  vr_cmd_buf [5] = data->codec_interface;
#ifdef MSMAUD_UP_DMA_PATH_CONTROL_VR
  vr_cmd_buf[6] = 0;
  /* DMA Path Control */
  vr_cmd_buf[7] = data->eight_khz_int_mode;
  /* 8 KHz interrupt mode           */
#else
  /* VR Mode B/C has its own codec config command, which is
  ** basically the same as the codec configuration command plus
  ** an additional field containing the VR software version number.
  */
  vr_cmd_buf[6] = 0;               /* DMA Path Control must be 0 */
  vr_cmd_buf[7] = vr_sw_version;
#endif /* MSMAUD_UP_DMA_PATH_CONTROL_VR */

  /* Send VR CODEC Configuration command to QDSP2.
  */
  if ((result = qdsp2_command (vr_cmd_buf)) != QDSP_CMD_SUCCESS)
  {
    MSG_ERROR ("VR CODEC Configuration Error!", 0, 0, 0);
  }
  return (result);

} /* end qdsp_cmd_vr_codec_config */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_vr_prompt

DESCRIPTION
  This function will send a command to the DSP to transition the DSP to
  VR PROMPT state.

DEPENDENCIES
  The current DSP image must support VR Mode B/C.
  This command is only valid when the DSP is in VR IDLE, VR PROMPT,
  VR CAPTURE or VR MATCH state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  Transition DSP to VR PROMPT state.

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_vr_prompt ( void )
{
  uint16 vr_cmd_buf [VR_PROMPT_CMD_SIZE] = {VR_PROMPT_CMD_SIZE,
                                            VR_PROMPT_CMD_HDR};
  qdsp_cmd_status_type result = QDSP_CMD_SUCCESS;

  /* Send the VR Prompt command to the QDSP2 */
  result = qdsp2_command (vr_cmd_buf);

  /* Clear VR Match in progress flag.
  */
  qdsp_cmd_match_in_progress = FALSE;
  if (result != QDSP_CMD_SUCCESS)
  {
    MSG_ERROR ("VR Prompt Command Error!", 0, 0, 0);
  }
  return (result);

} /* end qdsp_cmd_vr_prompt */

/*===========================================================================

FUNCTION  qdsp_cmd_capture_restore

DESCRIPTION
  This function restores capture parameters to what they were before the
  capture command.

DEPENDENCIES
  The current DSP image must support VR Mode B/C.
  The DSP is in VR PROMPT or VR CAPTURE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type  qdsp_cmd_capture_restore ( void )
{
  uint32                        isave;

  /* Clear call back function.
  */
  INTLOCK_SAV (isave);
  qdsp_cmd_vr_endpt_cb = (qdsp_cmd_endpt_cb_type) NULL;
  INTFREE_SAV (isave);

  /* Restore previously saved min and max frame rates.
  */
  qdsp_write(QDSP_encMinRate, qdsp_cmd_min_frame_rate);
  qdsp_write(QDSP_encMaxRate, qdsp_cmd_max_frame_rate);

  /* Restore previously saved tx comfort noise enable flag.
  */
  qdsp_cmd_restore_comfort_noise();

  return (QDSP_CMD_SUCCESS);

} /* end  qdsp_cmd_capture_restore */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_capture_start

DESCRIPTION
  This function starts an utterance capture operation by sending a VR capture
  command to the DSP.

DEPENDENCIES
  This function depends on all VR mode B/C vocoder initialization taking place
  first.

  This command is only valid when the DSP is in VR PROMPT or VR CAPTURE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_capture_start
(
  uint16                 max_rate,           /* Max capture rate           */
  uint16                 min_rate,           /* Min capture rate           */
  boolean                talkover_capture,   /* Talk over prompt flag      */
  uint16                 vr_capture_control, /* Command data to send       */
  qdsp_cmd_endpt_cb_type cb_func             /* Function ptr to call back  */
)
{
  uint16 vr_cmd_buf [VR_CAPTURE_START_CMD_SIZE];
  qdsp_cmd_status_type result = QDSP_CMD_SUCCESS;
  sint15               state;
  int                  i;
  volatile boolean     qdsp_change_flag = FALSE;

  state = qdsp_cmd_get_state();

  if ((state != QDSP_STATE_VR_PROMPT) && (state != QDSP_STATE_VR_CAPTURE))
  {
    MSG_HIGH ("qdsp_state=%d Capture cmd start in wrong state", state, 0, 0);
    return (QDSP_CMD_FAILED);
  }

  /* Save function pointer to send captured voice frames to
  ** function responsible for detecting end point.
  */
  if (cb_func == (qdsp_cmd_endpt_cb_type) NULL)
  {
    MSG_ERROR ("VR Capture Start Cmd Error! Bad cb", 0, 0, 0);
    return (QDSP_CMD_FAILED);
  }
  else
  {
    qdsp_cmd_vr_endpt_cb = cb_func;
  }

  /* Set vr capture max and min frame rates.
  */
  qdsp_cmd_vr_set_rate(max_rate, min_rate);

  /* Set talkover capture mode.
  */
  qdsp_cmd_talkover_capture = talkover_capture;

  /* Send VR Capture command to DSP.
  */
  vr_cmd_buf [0] = VR_CAPTURE_START_CMD_SIZE;
  vr_cmd_buf [1] = VR_CAPTURE_START_CMD_HDR;
  vr_cmd_buf [2] = vr_capture_control;   /* VR Capture Control data        */

  if ((result = qdsp2_command (vr_cmd_buf)) != QDSP_CMD_SUCCESS)
  {
    MSG_ERROR ("VR Capture Start Cmd Error %x", vr_cmd_buf [2], 0, 0);

    /* Restore capture parameters to what they were before the capture command.
    */
    (void)  qdsp_cmd_capture_restore ();
  }

  /* Enable capture in ISR.
  */
  qdsp_cmd_vr_utterance_capture = TRUE;

  /* Unmute tx.
  */
  qdsp_cmd_tx_comfort_noise_ctrl(QDSP_COMFORT_NOISE_DIS_V);

  /* Wait for QDSP to arrive in VR CAPTURE state, max 1 sec */
  for( i = 0; i < 10000; i++ )
  {
    if ( qdsp_cmd_get_state() == QDSP_STATE_VR_CAPTURE )
    {
      qdsp_change_flag = TRUE;
      break;
    }

    #if defined (FEATURE_CMI_MM) || !defined(FEATURE_CMI)
	clk_busy_wait(100);
    #else    		
#error code not present
	#endif
  }
  /* Check if DSP is in VR CAPTURE state, report result.  Reset flag
  ** to allow capture and play back operations.
  */
  if (qdsp_change_flag == FALSE)
  {
    MSG_ERROR ("DSP is NOT in VR CAPTURE state!!!", 0,0,0 );
    return (VOC_CMD_FAILED_S);
  }

  return (result);

} /* end qdsp_cmd_capture_start */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_capture_cont

DESCRIPTION
  This function sends a capture continue command to the DSP.

DEPENDENCIES
  This function depends on all VR mode B/C vocoder initialization taking place
  first.

  This command is only valid when the DSP is in VR PROMPT or VR CAPTURE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_capture_cont (
  uint16   num_frames_to_discard
   /* Discard this number of frames since they do not contain speech       */
)

{
  uint16 vr_cmd_buf [VR_CAPTURE_CONT_CMD_SIZE];
  qdsp_cmd_status_type result = QDSP_CMD_SUCCESS;

  /* Send VR Capture Cont command to DSP.
  */
  vr_cmd_buf [0] = VR_CAPTURE_CONT_CMD_SIZE;
  vr_cmd_buf [1] = VR_CAPTURE_CONT_CMD_HDR;
  vr_cmd_buf [2] = num_frames_to_discard;

  if ((result = qdsp2_command (vr_cmd_buf)) != QDSP_CMD_SUCCESS)
  {
    MSG_ERROR ("VR Capture Cont Cmd Error! %x", vr_cmd_buf [2], 0, 0);

    /* Restore capture parameters to what they were before the capture command.
    */
    (void)  qdsp_cmd_capture_restore ();
  }
  return (result);

} /* end qdsp_cmd_capture_cont */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_capture_stop

DESCRIPTION
  This function stops an utterance capture operation.

DEPENDENCIES
  The current DSP image must support VR Mode B/C.
  The DSP is in VR PROMPT or VR CAPTURE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_capture_stop (
  const qdsp_cmd_capture_end_cmd_type *data      /* Command data to send   */
)

{
  uint16 vr_cmd_buf [VR_CAPTURE_END_CMD_SIZE];
  qdsp_cmd_status_type result = QDSP_CMD_SUCCESS;

  /* Restore capture parameters to what they were before the capture command.
  */
  (void)  qdsp_cmd_capture_restore ();

  /* No longer capture in ISR.
  */
  qdsp_cmd_vr_utterance_capture = FALSE;

  /* Send VR Capture End command to DSP.
  */
  vr_cmd_buf [0] = VR_CAPTURE_END_CMD_SIZE;
  vr_cmd_buf [1] = VR_CAPTURE_END_CMD_HDR;
  vr_cmd_buf [2] = data->total_num_hyps;

  /* Copy endpoint pairs to command buffer.
  */
  memcpy (&(vr_cmd_buf [3]),
          data->ep_pair_buf,
          (data->total_num_hyps * sizeof (qdsp_ep_pair_type))
         );

  if ((result = qdsp2_command (vr_cmd_buf)) != QDSP_CMD_SUCCESS)
  {
    MSG_ERROR ("VR Capture End Cmd Error %x", vr_cmd_buf [2], 0, 0);
  }
  return (result);

} /* end qdsp_cmd_capture_stop */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_match_start

DESCRIPTION
  This function starts a VR match operation by sending a VR match
  command to the DSP.

  Special Note:

  While a match operation is in progress, the DSP is not configured to
  play voice prompts or capture.

DEPENDENCIES
  This function depends on all VR mode B/C vocoder initialization taking place
  first.

  This command is only valid when the DSP is in VR CAPTURE or VR
  MATCH state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_match_start
(
  const qdsp_cmd_match_cmd_type *data        /* Command data to send       */
)

{
  uint16 vr_cmd_buf [VR_MATCH_CMD_SIZE];
  qdsp_cmd_status_type result = QDSP_CMD_SUCCESS;

  /* VR Match is in progress, inhibit sending certain commands to DSP since
  ** DSP is running VR Match software.
  */
  qdsp_cmd_match_in_progress = TRUE;

  /* Send VR Match command to DSP.
  */
  vr_cmd_buf [0] = VR_MATCH_CMD_SIZE;      /* Length of the command        */
  vr_cmd_buf [1] = VR_MATCH_CMD_HDR;       /* Command header               */
  vr_cmd_buf [2] = data->vr_match_control; /* VR Capture Control data      */
  vr_cmd_buf [3] = data->num_hyps;         /* Number of endpt hypotheses   */

  /* Copy endpoint indexes to command buffer.
  */
  memcpy (&(vr_cmd_buf [4]),
          data->ep_index_buf,
          (data->num_hyps * sizeof (uint16))
         );

  if ((result = qdsp2_command (vr_cmd_buf)) != QDSP_CMD_SUCCESS)
  {
    MSG_ERROR ("VR Match Command Error!", 0, 0, 0);
    qdsp_cmd_match_in_progress = FALSE;
  }
  return (result);

} /* end qdsp_cmd_match_start */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_pattern_load

DESCRIPTION
  This function is called to send patterns to the DSP (via DMA) for a
  matching operation.

DEPENDENCIES
  The DMA address and length of pattern buffer are specified by the DSP.
  The current DSP image must support VR Mode B/C.
  The DSP was configured with the appropriate VR parameters.
  The DSP is in VR MATCH state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_pattern_load
(
  uint16                      num_vr_patterns,
                              /* Number of pattern(s) loaded               */
  uint16                      *pattern_ptr
                              /* Addr of pattern(s) (DSP DMA address)      */
)

{
  /* Validate number of vr patterns to download.
  */
  if ((num_vr_patterns == 0) ||
      (num_vr_patterns > MAX_NUM_VR_PAT))
  {
    MSG_ERROR ("Bad pattern count, %d", num_vr_patterns, 0, 0);
    return (QDSP_CMD_FAILED);
  }

  MSG_MED ("Pat dl,%d pats,dladdr:%lx,hdr:%x",
           num_vr_patterns,
           pattern_ptr,
           *(pattern_ptr + 1)
          );

  /* Writing the number of vr patterns to the appropriate DSP DMA download
  ** address will generates a DSP interrupt.
  */
  *(pattern_ptr) = num_vr_patterns;

  return (QDSP_CMD_SUCCESS);

} /* end qdsp_cmd_pattern_load */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_set_narrowb

DESCRIPTION
  This function configures the DSP for narrowband capture before a capture
  command is sent.

DEPENDENCIES
  The current DSP image must support VR Mode B/C.
  The DSP was configured with the appropriate VR parameters.
  This command is only valid when the DSP is in VR PROMPT or VR CAPTURE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_set_narrowb  (void)

{
  qdsp_block_write (QDSP_vrBarkAveCoeffTable, 0,
              (uint16 *) qdsp_vrBarkAveCoeffTable, 16, FALSE);

  qdsp_write_offset (QDSP_vrBandEndptAveCoeffTable, 3, 0x0);

  qdsp_write (QDSP_vrBandEndptNumber, 3);
  qdsp_write (QDSP_ecHpfCoeffA1, 0xC666);

  qdsp_block_write (QDSP_vrBarkTable, 0,
              (uint16 *) qdsp_vrBarkTable, 16, FALSE);

  qdsp_write_offset (QDSP_vrBandEndptTable, 3, 0);

  return (QDSP_CMD_SUCCESS);

} /* end qdsp_cmd_set_narrowb */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_set_bark_weight

DESCRIPTION
  This function configures the VR Bark Amp weight table in DSP memory.

DEPENDENCIES
  The current DSP image must support VR Mode B/C.
  The DSP was configured with the appropriate VR parameters.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/

qdsp_cmd_status_type qdsp_cmd_set_bark_weight
(
  const unsigned short *barkweight
)

{
  qdsp_block_write (QDSP_vrBarkWeightTable, 0,
                   (uint16 *) barkweight, 16, FALSE);

  return (QDSP_CMD_SUCCESS);

} /* end qdsp_cmd_set_bark_weight */

#ifdef FEATURE_VR_PUFE
#error code not present
#endif /* FEATURE_VR_PUFE */

#endif /* FEATURE_PHONE_VR */

#ifdef FEATURE_VOC_DTMF_DETECT
/*===========================================================================

FUNCTION QDSP_CMD_DTMF_DETECT

DESCRIPTION
  This function will enable/disable DTMF detection.

DEPENDENCIES
  This command is only valid when the DSP is in Vocoder or DFM state.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static uint16 qdsp_cmd_dtmf_detect_tuning[] = {
  20, 9, 3, 7, 13, 15, 12, 9, 12, 13, 17, 0x7333, 0x2666, 5, 4
};

void qdsp_cmd_dtmf_detect (
  qdsp_cmd_dtmf_detect_cmd_type  cmd,
  qdsp_cmd_dtmf_detect_cb_type   cb_func
) {
  uint16 dsp_command;

  qdsp_cmd_dtmf_detect_cb = cb_func;

  switch(cmd) {
    case QDSP_CMD_DTMF_DETECT_TX:
      dsp_command = 0x5;
      break;
    case QDSP_CMD_DTMF_DETECT_RX:
      dsp_command = 0xa;
      break;
    case QDSP_CMD_DTMF_DETECT_BOTH:
      dsp_command = 0xf;
      break;
    case QDSP_CMD_DTMF_DETECT_DISABLED:
    default:
      qdsp_cmd_dtmf_detect_cb = NULL;
      dsp_command             = 0;
      break;
  }

  /* SET ALL DTMF DETECTION PARAMETERS HERE */
  qdsp_block_write(QDSP_txDtmfConfigBuf, 0, qdsp_cmd_dtmf_detect_tuning,
                   15, FALSE);

  qdsp_block_write(QDSP_rxDtmfConfigBuf, 0, qdsp_cmd_dtmf_detect_tuning,
                   15, FALSE);

  qdsp_write(QDSP_dtmfDetectSwitch, dsp_command);

}
#endif /* FEATURE_VOC_DTMF_DETECT */

#ifdef FEATURE_VOC_ADPCM
/*===========================================================================

FUNCTION qdsp_cmd_adpcm_gain

DESCRIPTION
  This function will set/clear QDSP_adpcmRxGain variable

DEPENDENCIES
  This command is only valid when the DSP is in IDLE state to set,
  and at the ADPCM_VOCODER state to clear.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
extern void qdsp_cmd_adpcm_gain (
  boolean val
)
{
  if (val) {
    qdsp_write(QDSP_adpcmcodecRxGain, 0x4000);
  } else {
    qdsp_write(QDSP_adpcmcodecRxGain, 0);
  }
}

/*===========================================================================

FUNCTION qdsp_cmd_get_adpcm_mode

DESCRIPTION
  This function whether current qdsp adpcm status equals to ENABLED.

DEPENDENCIES
  This command is only valid when the DSP is in ADPCM VOCODER state.

RETURN VALUE
  FALSE is adpcm is disabled other TRUE

SIDE EFFECTS
  None

===========================================================================*/
boolean qdsp_cmd_get_adpcm_mode(void)
{
   return ((qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_ENABLED) ||
           (qdsp_cmd_adpcm_status == QDSP_CMD_ADPCM_MODE_PAUSED));
}
#endif /* FEATURE_VOC_ADPCM */

#if defined (FEATURE_AVS_INCALL_ADEC_PB) || \
    defined (FEATURE_AVS_INCALL_MIXER_ADEC_PB) || \
    defined (FEATURE_AVS_INCALL_MIXER_CMX)
/*===========================================================================

FUNCTION qdsp_cmd_get_adec_state

DESCRIPTION
  This function reads the adec state when the firmware is in VOCODER+ADEC state

DEPENDENCIES
  A firmware image that supports VOCODER+ADEC must be loaded.

RETURN VALUE
  QDSP_adecState

SIDE EFFECTS
  None

===========================================================================*/
sint15 qdsp_cmd_get_adec_state (void)
{
  sint15 result;

  switch(qdsp_cmd_image_select) {
#ifdef QDSP_IMAGE_VOC_MP3_DEFINED
    case QDSP_IMAGE_VOC_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_EVRC_MP3_DEFINED
    case QDSP_IMAGE_VOC_EVRC_MP3:
#endif
#ifdef QDSP_IMAGE_AMR_MP3_DEFINED
    case QDSP_IMAGE_AMR_MP3:
#endif
#ifdef QDSP_IMAGE_HR_MP3_DEFINED
    case QDSP_IMAGE_HR_MP3:
#endif
#ifdef QDSP_IMAGE_EFR_MP3_DEFINED
    case QDSP_IMAGE_EFR_MP3:
#endif
#ifdef QDSP_IMAGE_FR_MP3_DEFINED
    case QDSP_IMAGE_FR_MP3:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif
      result = (sint15) qdsp_read(QDSP_adecState);
      break;

    default:
      result = 0;
      break;
  }

  return (result);
}

#if defined(FEATURE_AVS_INCALL_MIXER_ADEC_PB) || \
    defined(FEATURE_AVS_INCALL_MIXER_CMX)
/*===========================================================================

FUNCTION qdsp_cmd_get_mixer_state

DESCRIPTION
  This function get the corresponding mixer image entities' state.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
boolean qdsp_cmd_get_mixer_state (
  sint15  *mixer_state
)
{
  boolean ret_val = FALSE;

  switch (qdsp_cmd_image_select) {
#if defined(QDSP_IMAGE_VOC_COMBO_ICA_DEFINED) || \
    defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef QDSP_IMAGE_VOC_COMBO_ICA_DEFINED
    case QDSP_IMAGE_VOC_COMBO_ICA:
#endif /* QDSP_IMAGE_VOC_COMBO_ADEC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
      *mixer_state   = (sint15)qdsp_read(QDSP_mixerState);
      ret_val = TRUE;
      break;
#endif /* QDSP_IMAGE_VOC_COMBO_ADEC_DEFINED  ||
          QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
    default:
      ret_val = FALSE;
      break;
  }

  return (ret_val);
}

/*===========================================================================

FUNCTION qdsp_cmd_mixer_adec_config

DESCRIPTION

DEPENDENCIES
  This command is only valid when the DSP is in MIXER_ACTIVE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_mixer_adec_config
(
  qdsp_cmd_codec_config_type *data
)
{
  qdsp_cmd_status_type result = QDSP_CMD_FAILED;  /* Return value */
  sint15               mixer_state  = 0;
  /* Local buffer for the command */
  uint16 codec_config_command[CODEC_CONFIG_CMD_SIZE_MIXER + 1];

  if ((qdsp_cmd_get_mixer_state(&mixer_state) == TRUE) &&
      (mixer_state == QDSP_STATE_MIXER_ACTIVE)) {
    codec_config_command[0] = CODEC_CONFIG_CMD_SIZE_MIXER;
    codec_config_command[1] = CODEC_CONFIG_CMD_HDR;
    codec_config_command[2] = data->pcm_format_ctrl;
    codec_config_command[3] = data->pcm_ctrl;
    codec_config_command[4] = data->codec_func_ctrl;
    codec_config_command[5] = data->codec_interface;
    codec_config_command[6] = 0;
    codec_config_command[7] = data->eight_khz_int_mode;
    codec_config_command[8] = (uint16) (0x1 << QDSP_CMD_MIXER_ADEC0_INDEX);
    /* Now send the CODEC Configuration command to the QDSP */
    if( (result = qdsp_mixer_command( codec_config_command ))
        != QDSP_CMD_SUCCESS )
    {
      MSG_HIGH("QDSP2 Mixer ADEC Configuration Error!", 0, 0, 0);
    } else {
      MSG_HIGH("Mixer ADEC configuration is issued!",0,0,0);
    }
  } else {
    MSG_ERROR("Issue mixer adec config cmd at wrong mixer state", 0, 0, 0);
  }

  return (result);
}

/*===========================================================================

FUNCTION qdsp_cmd_mixer_voc_config (command 0x0301)

DESCRIPTION

DEPENDENCIES
  This command is only valid when the DSP is in MIXER_ACTIVE state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_mixer_voc_config
(
  qdsp_cmd_codec_config_type *data
)
{
  qdsp_cmd_status_type result = QDSP_CMD_FAILED;  /* Return value */
  sint15               mixer_state  = 0;
  /* Local buffer for the command */
  uint16 codec_config_command[CODEC_CONFIG_CMD_SIZE_MIXER + 1];

  if ((qdsp_cmd_get_mixer_state(&mixer_state) == TRUE) &&
      (mixer_state == QDSP_STATE_MIXER_ACTIVE)) {
    codec_config_command[0] = CODEC_CONFIG_CMD_SIZE_MIXER;
    codec_config_command[1] = CODEC_CONFIG_CMD_HDR;
    codec_config_command[2] = data->pcm_format_ctrl;
    codec_config_command[3] = data->pcm_ctrl;
    codec_config_command[4] = data->codec_func_ctrl;
    codec_config_command[5] = data->codec_interface;
    codec_config_command[6] = 0;
    codec_config_command[7] = data->eight_khz_int_mode;
    codec_config_command[8] = (uint16) (0x1 << QDSP_CMD_MIXER_VOC_INDEX);

   /* Now send the CODEC Configuration command to the QDSP */
    if( (result = qdsp_mixer_command( codec_config_command ))
        != QDSP_CMD_SUCCESS )
    {
      MSG_HIGH("QDSP2 Mixer VOC Configuration Error!", 0, 0, 0);
    } else {
      MSG_HIGH("Mixer VOC configuration is issued!",0,0,0);
    }
  } else {
    MSG_ERROR("Issue mixer voc config cmd at wrong mixer state", 0, 0, 0);
  }

  return (result);
}

/*===========================================================================

FUNCTION qdsp_cmd_mixer_codec_config (command 0x0301)

DESCRIPTION

DEPENDENCIES
  This command is only valid when the DSP is in MIXER_IDLE, MIXER_Vocoder
  state.

RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_mixer_codec_config (
  qdsp_mixer_mode_type       mode,
  qdsp_cmd_codec_config_type *data
)
{
  qdsp_cmd_status_type result = QDSP_CMD_FAILED;  /* Return value */

  /* Local buffer for the command */
  uint16 codec_config_command[CODEC_CONFIG_CMD_SIZE_MIXER + 1];

  if(data == NULL) {
    MSG_FATAL("Mixer Codec config called in invalid state!",0,0,0);
    return(result);
  }


  codec_config_command[0] = CODEC_CONFIG_CMD_SIZE_MIXER;
  codec_config_command[1] = CODEC_CONFIG_CMD_HDR;
  codec_config_command[2] = data->pcm_format_ctrl;
  codec_config_command[3] = data->pcm_ctrl;
  codec_config_command[4] = data->codec_func_ctrl;
  codec_config_command[5] = data->codec_interface;
  codec_config_command[6] = 0;
  codec_config_command[7] = data->eight_khz_int_mode;
  codec_config_command[8] = (uint16) (mode |
                                      (0x1 << QDSP_CMD_MIXER_CODEC_INDEX));

  /* Now send the CODEC Configuration command to the QDSP */
  if( (result = qdsp_mixer_command( codec_config_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_HIGH("QDSP2 Mixer CODEC Configuration Error!", 0, 0, 0);
  }

  MSG_HIGH("Mixer Codec configuration is issued!",0,0,0);

#ifdef MSMAUD_INIT_AUX_CODEC
  if (qdsp_cmd_arm_ctrl_aux_pcm_clk == TRUE)
  {
    MSMAUD_INIT_CODEC();
    qdsp_cmd_arm_ctrl_aux_pcm_clk = FALSE;
  }
#endif

  return (result);
}
#endif /* FEATURE_AVS_INCALL_MIXER_ADEC_PB ||
          FEATURE_AVS_INCALL_MIXER_CMX */
#endif /* FEATURE_AVS_INCALL_ADEC_PB || FEATURE_AVS_INCALL_MIXER_ADEC_PB
          || FEATURE_AVS_INCALL_MIXER_CMX */

#ifdef FEATURE_TTY_UMTS
#error code not present
#endif /* FEATURE_TTY_UMTS */

#ifdef FEATURE_AUDIO_PCR_SUPPORT
/*===========================================================================

FUNCTION qdsp_cmd_af_adjust_sample

DESCRIPTION
  Adjsut the Sample
DEPENDENCIES
  None

RETURN VALUE
  QDSP_CMD_SUCCESS - command  successfully sent.
  QDSP_CMD_FAILED  - Command failed, need retry.

SIDE EFFECTS
  None

==========================================================================*/
qdsp_cmd_status_type qdsp_cmd_af_adjust_sample
(
boolean       add_sample
)
{
  qdsp_cmd_status_type status = QDSP_CMD_FAILED;

  /* Local buffer for the command */
  uint16 sample_adjust_command[QDSP_CMD_PCR_SAMPLE_ADJUST_CMD_SIZE];

  sample_adjust_command[0] = QDSP_CMD_PCR_SAMPLE_ADJUST_CMD_SIZE;
  /* Length of the command   */

  sample_adjust_command[1] = QDSP_CMD_PCR_SAMPLE_ADJUST_CMD_HDR;
  /* Command header          */

  /* Add/Drop Sample */
  switch (add_sample)
  {
    case TRUE:
      sample_adjust_command[2] =  QDSP_CMD_PCR_ADD_SAMPLE;
      break;
    case FALSE:
      sample_adjust_command[2] =  QDSP_CMD_PCR_DROP_SAMPLE;
      break;
    default:
      MSG_ERROR("Unexpected adjust_sample value %d", add_sample,0,0);
      return QDSP_CMD_FAILED;
  }

  /* Now send the Sample Adjust Control command to the QDSP2 */
  if( (status = qdsp2_command( sample_adjust_command ))
       != QDSP_CMD_SUCCESS )
  {
    MSG_ERROR("QDSP2 Sample Adjust Control Command Error!", 0, 0, 0);
  }
  return( status );
}
#endif /* FEATURE_AUDIO_PCR_SUPPORT */

#if defined(FEATURE_ADEC) || defined(FEATURE_WAVE_PB)

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_send_voc_wav_data

DESCRIPTION
  Send voc wav data to the DSP

DEPENDENCIES
  None.

RETURN VALUE
  QDSP_CMD_SUCCESS.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_send_voc_wav_data(
  qdsp_cmd_adec_cmd_type *adec_cmd
)
{
#if defined(QDSP_IMAGE_G711_DEFINED) && defined(MSMAUD_VOC_G711) &&\
    defined(FEATURE_WAVE_PB)
  INTLOCK();
  if(qdsp_cmd_adpcm_adec_info.buf_length == 0) {
    qdsp_cmd_adpcm_adec_info.buf_ptr    = adec_cmd->buf2;
    qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
    adec_cmd->length1                   = 0;
    qdsp_cmd_voc_wav_send_frame();
  }
  INTFREE();
#endif /* (QDSP_IMAGE_G711_DEFINED) && (MSMAUD_VOC_G711) &&
          (FEATURE_WAVE_PB) */
   return (QDSP_CMD_SUCCESS);
}




/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_send_graph_adpcm_data

DESCRIPTION
  Send graph adpcm data to the DSP

DEPENDENCIES
  None.

RETURN VALUE
  QDSP_CMD_SUCCESS.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_send_graph_adpcm_data(
  qdsp_cmd_adec_cmd_type *adec_cmd
)
{

#ifdef FEATURE_GRAPH_ADPCM
  switch (qdsp_cmd_image_select){
#ifdef QDSP_IMAGE_VFE_BAYER_DEFINED
    case QDSP_IMAGE_VFE_BAYER:
#endif /* QDSP_IMAGE_VFE_BAYER_DEFINED */
#ifdef QDSP_IMAGE_VFE_YCBCR_DEFINED
    case QDSP_IMAGE_VFE_YCBCR:
#endif /* QDSP_IMAGE_VFE_YCBCR_DEFINED */
#ifdef QDSP_IMAGE_QCAMERA_DEFINED
    case QDSP_IMAGE_QCAMERA:
#endif /* QDSP_IMAGE_QCAMERA_DEFINED */
#ifdef QDSP_IMAGE_MP4E_DEFINED
    case QDSP_IMAGE_MP4E:
#endif /* QDSP_IMAGE_MP4E_DEFINED */
#ifdef QDSP_IMAGE_MP4E_BAYER_DEFINED
    case QDSP_IMAGE_MP4E_BAYER:
#endif /* QDSP_IMAGE_MP4E_BAYER_DEFINED */
#ifdef QDSP_IMAGE_MP4E_13K_DEFINED
    case QDSP_IMAGE_MP4E_13K:
#endif /* QDSP_IMAGE_MP4E_13K_DEFINED */
#ifdef QDSP_IMAGE_MP4E_EVRC_DEFINED
    case QDSP_IMAGE_MP4E_EVRC:
#endif /* QDSP_IMAGE_MP4E_EVRC_DEFINED */
#ifdef QDSP_IMAGE_MP4E_AMR_DEFINED
    case QDSP_IMAGE_MP4E_AMR:
#endif /* QDSP_IMAGE_MP4E_AMR_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_DEFINED
    case QDSP_IMAGE_QCAMCORDER:
#endif /* QDSP_IMAGE_QCAMCORDER_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED
    case QDSP_IMAGE_QCAMCORDER_AACENC:
#endif /* QDSP_IMAGE_QCAMCORDER_AACENC_DEFINED */
#ifdef QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED
#error code not present
#endif /*QDSP_IMAGE_QCAMCORDER_TURBO_DEFINED */

#ifdef QDSP_IMAGE_AACENC_DEFINED
    case QDSP_IMAGE_AACENC:
#endif /* QDSP_IMAGE_AACENC_DEFINED */

      INTLOCK();
#ifdef FEATURE_GASYNTH_INTERFACE
      if (qdsp_cmd_adpcm_adec_info.free_ptr != NULL) {

        if (qdsp_cmd_adpcm_adec_info.free_ptr == adec_cmd->buf1) {
          adec_cmd->length1 = 0; /* Reclaim buffer 1 */
          *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(0));
        } else if (qdsp_cmd_adpcm_adec_info.free_ptr == adec_cmd->buf2) {
          adec_cmd->length2 = 0; /* Reclaim buffer 2 */
          *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(1));
        } else {
          MSG_ERROR("Invalid adpcm buffer", 0, 0, 0);
        }
        qdsp_cmd_adpcm_adec_info.free_ptr = NULL;
      }

      if (qdsp_cmd_adpcm_adec_info.buf_ptr == NULL) {
        if ((qdsp_cmd_adpcm_adec_info.buf_state ==
             QDSP_CMD_ADEC_STATE_BUFFER1) && (adec_cmd->length1 != 0)) {
          qdsp_cmd_adpcm_adec_info.buf_ptr = adec_cmd->buf1;
          qdsp_cmd_adpcm_adec_info.buf_index = 0;
          qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
          qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
          *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(0);
          qdsp_cmd_graph_adpcm_send_frame();
        } else if ((qdsp_cmd_adpcm_adec_info.buf_state ==
             QDSP_CMD_ADEC_STATE_BUFFER2) && (adec_cmd->length2 != 0)) {
          qdsp_cmd_adpcm_adec_info.buf_ptr = adec_cmd->buf2;
          qdsp_cmd_adpcm_adec_info.buf_index = 0;
          qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length2;
          qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
          *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(1);
          qdsp_cmd_graph_adpcm_send_frame();
        }
      }

      if (qdsp_cmd_adpcm_adec_info.next_ptr == NULL) {
        if ((qdsp_cmd_adpcm_adec_info.buf_state ==
             QDSP_CMD_ADEC_STATE_BUFFER1) && (adec_cmd->length1 != 0)) {
          qdsp_cmd_adpcm_adec_info.next_ptr = adec_cmd->buf1;
          qdsp_cmd_adpcm_adec_info.next_length = adec_cmd->length1;
          qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
          *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(0);
        } else if ((qdsp_cmd_adpcm_adec_info.buf_state ==
             QDSP_CMD_ADEC_STATE_BUFFER2) && (adec_cmd->length2 != 0)) {
          qdsp_cmd_adpcm_adec_info.next_ptr = adec_cmd->buf2;
          qdsp_cmd_adpcm_adec_info.next_length = adec_cmd->length2;
          qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
          *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(1);
        }
      }
#else
      if(qdsp_cmd_adpcm_adec_info.buf_length == 0) {
        qdsp_cmd_adpcm_adec_info.buf_ptr    = adec_cmd->buf2;
        qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
        adec_cmd->length1                   = 0;
        qdsp_cmd_graph_adpcm_send_frame();
      }
#endif /* FEATURE_GASYNTH_INTERFACE */
      INTFREE();
      break;
    default :
      break;
  }
#endif /* FEATURE_GRAPH_ADPCM */
      return (QDSP_CMD_SUCCESS);
} /* end of qdsp_cmd_send_graph_adpcm_data() */

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_send_voc_adpcm_data

DESCRIPTION
  Send voc adpcm data to the DSP

DEPENDENCIES
  None.

RETURN VALUE
  QDSP_CMD_SUCCESS.

SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_send_voc_adpcm_data(
  qdsp_cmd_adec_cmd_type *adec_cmd )
{
#ifdef FEATURE_VOC_ADPCM
   switch (qdsp_cmd_image_select){
#ifdef QDSP_IMAGE_VOC_DEFINED
    case QDSP_IMAGE_VOC:
#endif /* QDSP_IMAGE_VOC_DEFINED */
#ifdef QDSP_IMAGE_VOC_COMBO_DEFINED
    case QDSP_IMAGE_VOC_COMBO:
#endif /* QDSP_IMAGE_VOC_COMBO_DEFINED */
#ifdef FEATURE_AMR_FIXED
    case QDSP_IMAGE_AMR:
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED
    case QDSP_IMAGE_VOC_COMBO_VOIP:
#endif /* QDSP_IMAGE_VOC_COMBO_VOIP_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_DEFINED
    case QDSP_IMAGE_VOC_EVRC:
#endif /* QDSP_IMAGE_VOC_EVRC_DEFINED */
#ifdef QDSP_IMAGE_VOC_E90_DEFINED
    case QDSP_IMAGE_VOC_E90:
#endif /* QDSP_IMAGE_VOC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_EVRC_E90_DEFINED
    case QDSP_IMAGE_VOC_EVRC_E90:
#endif /* QDSP_IMAGE_VOC_EVRC_E90_DEFINED */
#ifdef QDSP_IMAGE_VOC_QTV_DEFINED
    case QDSP_IMAGE_VOC_QTV:
#endif /* QDSP_IMAGE_VOC_QTV_DEFINED */
#ifdef QDSP_IMAGE_FR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_FR_DEFINED */
#ifdef QDSP_IMAGE_EFR_DEFINED
#error code not present
#endif /* QDSP_IMAGE_EFR_DEFINED */
#ifdef QDSP_IMAGE_AMR_DEFINED
    case QDSP_IMAGE_AMR:
#endif /* QDSP_IMAGE_AMR_DEFINED */
#ifdef QDSP_IMAGE_AMR_WB_DEFINED
    case QDSP_IMAGE_AMR_WB:
#endif /* QDSP_IMAGE_AMR_WB_DEFINED */
#ifdef QDSP_IMAGE_HR_DEFINED
    case QDSP_IMAGE_HR:
#endif /* QDSP_IMAGE_HR_DEFINED */
      {
        INTLOCK();
#ifdef MSMAUD_VOC_G711
        if(qdsp_voc_mode == QDSP_VOC_MODE_G711_V)
        {
          if(qdsp_cmd_adpcm_adec_info.buf_length == 0) {
            qdsp_cmd_adpcm_adec_info.buf_ptr    = adec_cmd->buf2;
            qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
            adec_cmd->length1                   = 0;
            qdsp_cmd_voc_wav_send_frame();
          }
        }
        else
#endif
        {
#ifdef FEATURE_GASYNTH_INTERFACE
          if (qdsp_cmd_adpcm_adec_info.free_ptr != NULL) {

            if (qdsp_cmd_adpcm_adec_info.free_ptr == adec_cmd->buf1) {
              adec_cmd->length1 = 0; /* Reclaim buffer 1 */
              *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(0));
            } else if (qdsp_cmd_adpcm_adec_info.free_ptr == adec_cmd->buf2) {
              adec_cmd->length2 = 0; /* Reclaim buffer 2 */
              *adec_cmd->buf_usage_mask &= ~(GET_ADEC_BUF_MASK(1));
            } else {
              MSG_ERROR("Invalid adpcm buffer", 0, 0, 0);
            }
            qdsp_cmd_adpcm_adec_info.free_ptr = NULL;
          }

          if (qdsp_cmd_adpcm_adec_info.buf_ptr == NULL) {
            if ((qdsp_cmd_adpcm_adec_info.buf_state ==
              QDSP_CMD_ADEC_STATE_BUFFER1) && (adec_cmd->length1 != 0)) {
              qdsp_cmd_adpcm_adec_info.buf_ptr = adec_cmd->buf1;
              qdsp_cmd_adpcm_adec_info.buf_index = 0;
              qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
              qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
              *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(0);
              qdsp_cmd_voc_adpcm_send_frame();
            } else if ((qdsp_cmd_adpcm_adec_info.buf_state ==
              QDSP_CMD_ADEC_STATE_BUFFER2) && (adec_cmd->length2 != 0)) {
              qdsp_cmd_adpcm_adec_info.buf_ptr = adec_cmd->buf2;
              qdsp_cmd_adpcm_adec_info.buf_index = 0;
              qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length2;
              qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
              *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(1);
              qdsp_cmd_voc_adpcm_send_frame();
            }
          }

          if (qdsp_cmd_adpcm_adec_info.next_ptr == NULL) {
            if ((qdsp_cmd_adpcm_adec_info.buf_state ==
              QDSP_CMD_ADEC_STATE_BUFFER1) && (adec_cmd->length1 != 0)) {
              qdsp_cmd_adpcm_adec_info.next_ptr = adec_cmd->buf1;
              qdsp_cmd_adpcm_adec_info.next_length = adec_cmd->length1;
              qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
              *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(0);
            } else if ((qdsp_cmd_adpcm_adec_info.buf_state ==
              QDSP_CMD_ADEC_STATE_BUFFER2) && (adec_cmd->length2 != 0)) {
              qdsp_cmd_adpcm_adec_info.next_ptr = adec_cmd->buf2;
              qdsp_cmd_adpcm_adec_info.next_length = adec_cmd->length2;
              qdsp_cmd_adpcm_adec_info.buf_state ^= 0x1;
              *adec_cmd->buf_usage_mask |= GET_ADEC_BUF_MASK(1);
            }
          }
#else
          if(qdsp_cmd_adpcm_adec_info.buf_length == 0) {
            qdsp_cmd_adpcm_adec_info.buf_ptr    = adec_cmd->buf2;
            qdsp_cmd_adpcm_adec_info.buf_length = adec_cmd->length1;
            adec_cmd->length1                   = 0;
            qdsp_cmd_voc_adpcm_send_frame();
          }
#endif /* FEATURE_GASYNTH_INTERFACE */
        }
        INTFREE();
      }
      break;
    default:
      break;
    }
#endif /* FEATURE_VOC_ADPCM */

      return (QDSP_CMD_SUCCESS);
}

/* <EJECT> */
/*===========================================================================

FUNCTION qdsp_cmd_send_synth_adpcm_data

DESCRIPTION
  Send synth adpcm data to the DSP

DEPENDENCIES
  None.

RETURN VALUE
  QDSP_CMD_SUCCESS.


SIDE EFFECTS
  None.

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_send_synth_adpcm_data(
  qdsp_cmd_adec_cmd_type *adec_cmd )
{

  switch (qdsp_cmd_image_select){
#if defined(FEATURE_WEBAUDIO) || defined(FEATURE_MIDI_OUT_QCP) || \
    defined(FEATURE_QSYNTH_ADPCM)
#ifdef FEATURE_GASYNTH_INTERFACE
#if defined(QDSP_IMAGE_SYNTH_DEFINED) || \
     defined(QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED)
#ifdef QDSP_IMAGE_SYNTH_DEFINED
    case QDSP_IMAGE_SYNTH:
#endif /* QDSP_IMAGE_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
#ifdef QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED
    case QDSP_IMAGE_VOC_COMBO_SYNTH:
#endif /* QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#ifdef QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED
   case QDSP_IMAGE_CAM_AUDIO_CONC:
#endif /* QDSP_IMAGE_CAM_AUDIO_CONC_DEFINED */
      if(qdsp_cmd_adec_int_cb_ptr != NULL) {
        qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBufStartMSW1Ch0,
                                   (uint32) QDSP_adecDataBufStartMSW2Ch0,
                                   (uint32) QDSP_adecDataBufSize1Ch0,
                                   (uint32) QDSP_adecDataBufSize2Ch0,
                                   (uint32) QDSP_adecDataBufReadyFlag1Ch0,
                                   (uint32) QDSP_adecDataBufReadyFlag2Ch0,
                                   0,&adec_cmd[0]);

#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
			{
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
        qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBufStartMSW1Ch1,
                                   (uint32) QDSP_adecDataBufStartMSW2Ch1,
                                   (uint32) QDSP_adecDataBufSize1Ch1,
                                   (uint32) QDSP_adecDataBufSize2Ch1,
                                   (uint32) QDSP_adecDataBufReadyFlag1Ch1,
                                   (uint32) QDSP_adecDataBufReadyFlag2Ch1,
                                   1,&adec_cmd[1]);
        qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBufStartMSW1Ch2,
                                   (uint32) QDSP_adecDataBufStartMSW2Ch2,
                                   (uint32) QDSP_adecDataBufSize1Ch2,
                                   (uint32) QDSP_adecDataBufSize2Ch2,
                                   (uint32) QDSP_adecDataBufReadyFlag1Ch2,
                                   (uint32) QDSP_adecDataBufReadyFlag2Ch2,
                                   2,&adec_cmd[2]);
        qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBufStartMSW1Ch3,
                                   (uint32) QDSP_adecDataBufStartMSW2Ch3,
                                   (uint32) QDSP_adecDataBufSize1Ch3,
                                   (uint32) QDSP_adecDataBufSize2Ch3,
                                   (uint32) QDSP_adecDataBufReadyFlag1Ch3,
                                   (uint32) QDSP_adecDataBufReadyFlag2Ch3,
                                   3,&adec_cmd[3]);
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
      	}
        if (qdsp_read(QDSP_adecDataHostStickyInt) != 0) {
          qdsp_write(QDSP_adecDataHostStickyInt, 0);
        }
      }
      break;
#endif /* QDSP_IMAGE_SYNTH_DEFINED || QDSP_IMAGE_VOC_COMBO_SYNTH_DEFINED */
#else
#ifdef QDSP_IMAGE_SYNTH_DEFINED
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
    case QDSP_IMAGE_SYNTH:
      if(qdsp_cmd_adec_int_cb_ptr != NULL) {
#ifdef FEATURE_QSYNTH_ADPCM
        if(qdsp_cmd_get_qsynth_adec_mode() == QDSP_CMD_QSYNTH_ADEC_QCP)
#endif /* FEATURE_QSYNTH_ADPCM */
        {
          qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBuf,
                                     (uint32) QDSP_adecDataWritePtr,
                                     (uint32) QDSP_adecDataFreeLen,
                                     qdsp_cmd_adec_data_ptr0, &adec_cmd[0]);
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
{
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS

          qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBuf1,
                                     (uint32) QDSP_adecDataWritePtr1,
                                     (uint32) QDSP_adecDataFreeLen1,
                                     qdsp_cmd_adec_data_ptr1, &adec_cmd[1]);

          qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBuf2,
                                     (uint32) QDSP_adecDataWritePtr2,
                                     (uint32) QDSP_adecDataFreeLen2,
                                     qdsp_cmd_adec_data_ptr2, &adec_cmd[2]);

          qdsp_cmd_qsynth_adec_write((uint32) QDSP_adecDataBuf3,
                                     (uint32) QDSP_adecDataWritePtr3,
                                     (uint32) QDSP_adecDataFreeLen3,
                                     qdsp_cmd_adec_data_ptr3, &adec_cmd[3]);

#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
          	}
          qdsp_write(QDSP_adecDataHostStickyInt, 0);
          break;
        }
      }
#endif /* QDSP_IMAGE_SYNTH_DEFINED */

#ifdef QDSP_IMAGE_Q3D_DEFINED
    case QDSP_IMAGE_Q3D:
#endif
#ifdef QDSP_IMAGE_QGL_DEFINED
    case QDSP_IMAGE_QGL:
#endif
#ifdef FEATURE_QSYNTH_ADPCM
      if(qdsp_cmd_adec_int_cb_ptr != NULL) {
        qdsp_cmd_qsynth_adpcm_write((uint32) QDSP_adecAdpcmDataBufStart0,
                                    (uint32) QDSP_adecAdpcmDataBufSize0,
                                    (uint32) QDSP_adecAdpcmDataReadPtrOffset0,
                                    (uint32) QDSP_adecReset, 0, &adec_cmd[0]);
#ifdef QDSP_IMAGE_QSYNTH_RS_DEFINED
#error code not present
#endif
{
#ifdef FEATURE_MULTIPLE_ADEC_CHANNELS
        qdsp_cmd_qsynth_adpcm_write((uint32) QDSP_adecAdpcmDataBufStart1,
                                    (uint32) QDSP_adecAdpcmDataBufSize1,
                                    (uint32) QDSP_adecAdpcmDataReadPtrOffset1,
                                    (uint32) QDSP_adecReset1, 1, &adec_cmd[1]);

        qdsp_cmd_qsynth_adpcm_write((uint32) QDSP_adecAdpcmDataBufStart2,
                                    (uint32) QDSP_adecAdpcmDataBufSize2,
                                    (uint32) QDSP_adecAdpcmDataReadPtrOffset2,
                                    (uint32) QDSP_adecReset2, 2, &adec_cmd[2]);

        qdsp_cmd_qsynth_adpcm_write((uint32) QDSP_adecAdpcmDataBufStart3,
                                    (uint32) QDSP_adecAdpcmDataBufSize3,
                                    (uint32) QDSP_adecAdpcmDataReadPtrOffset3,
                                    (uint32) QDSP_adecReset3, 3, &adec_cmd[3]);
#endif /* FEATURE_MULTIPLE_ADEC_CHANNELS */
}
        /* Host clears the semaphore flag when done */
        qdsp_write(QDSP_adecDataHostStickyInt, 0);
      }
#endif /* FEATURE_QSYNTH_ADPCM */
      break;
#endif /* FEATURE_GASYNTH_INTERFACE */
#endif /* FEATURE_WEBAUDIO || FEATURE_MIDI_OUT_QCP || FEATURE_QSYNTH_ADPCM */
    default:
      break;
 }

          return (QDSP_CMD_SUCCESS);
}

#endif /* defined(FEATURE_ADEC) || defined(FEATURE_WAVE_PB) */
#ifdef FEATURE_AUDIO_ISDBT_DUAL_MONO
/*===========================================================================

FUNCTION qdsp_cmd_dual_mono_mode

DESCRIPTION
  Write Dual Mono mode.

DEPENDENCIES
  None.

RETURN VALUE
  QDSP_CMD_SUCCESS - command  successfully sent.
  QDSP_CMD_FAILED  - Command failed, need retry.


SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_dual_mono_mode (
 uint16 dual_mono_mode
)
{
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;

#if defined(QDSP_IMAGE_AAC_DEFINED)             || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED)    || \
    defined(QDSP_IMAGE_H264D_AAC_DEFINED)       || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)    || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED)   || \
    defined(QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)

  ret_val = QDSP_CMD_SUCCESS;
  if (dual_mono_mode > 3) {
    MSG_ERROR("dual_mono_mode cannot be greater than 3", 0, 0, 0);
    return(QDSP_CMD_FAILED);
  }

  if ( (uint16*)QDSP_channelSelect != (uint16*)QDSP_NOP_ADDRESS ) {
    /* QDSP interface start -1, -1 is equivalent with 3 */
    MSG_HIGH("dual_mono_mode %d", dual_mono_mode, 0, 0);
    if (dual_mono_mode == 3)
      qdsp_write(QDSP_channelSelect, (uint16)0xffff);
    else
      qdsp_write(QDSP_channelSelect, dual_mono_mode);
  }
#endif /* QDSP_IMAGE_AAC_DEFINED             ||
          QDSP_IMAGE_ENH_AAC_PLUS_DEFINED    ||
          QDSP_IMAGE_H264D_AAC_DEFINED       ||
          QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED   ||
          QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED ||
          QDSP_IMAGE_QTV_AAC_DEFINED */

  return(ret_val);
}

/*===========================================================================

FUNCTION qdsp_cmd_sbr_mode

DESCRIPTION
  Write SBR mode.

DEPENDENCIES
  None.

RETURN VALUE
  QDSP_CMD_SUCCESS - command  successfully sent.
  QDSP_CMD_FAILED  - Command failed, need retry.


SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_sbr_mode (
 uint16 sbr_mode
)
{
  qdsp_cmd_status_type ret_val = QDSP_CMD_FAILED;

#if defined(QDSP_IMAGE_AAC_DEFINED)             || \
    defined(QDSP_IMAGE_ENH_AAC_PLUS_DEFINED)    || \
    defined(QDSP_IMAGE_H264D_AAC_DEFINED)       || \
    defined(QDSP_IMAGE_QTV_AAC_H264_DEFINED)    || \
    defined(QDSP_IMAGE_QTV_AAC_H264_TURBO_DEFINED) || \
    defined(QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED)   || \
    defined(QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED) || \
    defined(QDSP_IMAGE_QTV_AAC_DEFINED)

  ret_val = QDSP_CMD_SUCCESS;
  if ( (uint16*)QDSP_sbrOnFlag != (uint16*)QDSP_NOP_ADDRESS ) {
    MSG_HIGH("sbr_mode %d", sbr_mode, 0, 0);
    qdsp_write(QDSP_sbrOnFlag,   sbr_mode);

  }
  if ( (uint16*)QDSP_sbrPsOnFlag != (uint16*)QDSP_NOP_ADDRESS ) {
    qdsp_write(QDSP_sbrPsOnFlag, sbr_mode);
  }
#endif /* QDSP_IMAGE_AAC_DEFINED             ||
          QDSP_IMAGE_ENH_AAC_PLUS_DEFINED    ||
          QDSP_IMAGE_H264D_AAC_DEFINED       ||
          QDSP_IMAGE_MP4D_AAC_PLUS_DEFINED   ||
          QDSP_IMAGE_MP4D_AAC_NO_VPP_DEFINED ||
          QDSP_IMAGE_QTV_AAC_DEFINED */


  return(ret_val);
}
#endif /* end of FEATURE_AUDIO_ISDBT_DUAL_MONO */

/*===========================================================================

FUNCTION qdsp_cmd_set_idle_metering

DESCRIPTION
Set qdsp variable idleMeterEnable.

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

void qdsp_cmd_set_idle_metering(uint16 flag)
{
#ifdef QDSP_idleMeterEnable
  if (flag == TRUE){
    qdsp_write(QDSP_idleMeterEnable, 0x0001);
  }
  else if(flag == FALSE){
    qdsp_write(QDSP_idleMeterEnable,0xffff);
  }
#endif /* #ifdef QDSP_idleMeterEnable */
}


/*===========================================================================

FUNCTION qqdsp_cmd_vp3_config

DESCRIPTION
  Write SBR mode.

DEPENDENCIES
  None.

RETURN VALUE
  QDSP_CMD_SUCCESS - command  successfully sent.
  QDSP_CMD_FAILED  - Command failed, need retry.


SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_vp3_config(qdsp_cmd_vp3_config_type *data)
{
  qdsp_cmd_status_type result = QDSP_CMD_SUCCESS;  /* Return value */

#if defined(QDSP_vp3ParamsReg)
#error code not present
#endif /*QDSP_vp3ParamsReg*/
  return( result );

}


/*===========================================================================

FUNCTION qdsp_cmd_set_slowtalk_config (DMA Type Writable Information)

DESCRIPTION


DEPENDENCIES


RETURN VALUE
  A value of qdsp_cmd_status_type indicating whether the command
  was done.

SIDE EFFECTS
  None

===========================================================================*/
qdsp_cmd_status_type qdsp_cmd_set_slowtalk_config (
  boolean                                    slowtalk_enable,
  qdsp_cmd_slowtalk_static_params_flag       slowtalk_static_params_flag,
  const qdsp_cmd_slowtalk_parms_type         *pSlowTalkParams
)
{
#ifdef QDSP_ezHearEnableFlag
#error code not present
#else
  return (QDSP_CMD_SUCCESS);
#endif /* QDSP_ezHearEnableFlag */
}


#ifdef CUST_EDITION
/*===========================================================================

FUNCTION iquicktest_mic_receiver_loopback_isr

DESCRIPTION
  This function processes the vocoders encoder and decoder interrupt.
  This function is same to qdsp_cmd_up_packet_loopback_isr().
  This function is only used to iquicktest.

DEPENDENCIES
  This function depends on all vocoder initialization taking place first.
    
RETURN VALUE
  None. 

SIDE EFFECTS
  None

===========================================================================*/

void iquicktest_mic_receiver_loopback_isr ( void )
{
  uint16  enc_semaphore_flag;         
  /* flag indicating if packet can be read    */
  uint16  dec_semaphore_flag;         
  /* flag indicating if packet can be read    */
  static uint16  frame_rate;    
  /* frame rate of Tx packet                 */
  static uint16  tx_packet[17];          
  /* tx packet data buffer                   */ 
  
  /* Read the encPacketReg and set the semaphore flag         */
  enc_semaphore_flag = qdsp_read(QDSP_encPacketReg);
  /* Read the decPacketReg and set the semaphore flag         */
  dec_semaphore_flag = qdsp_read(QDSP_decPacketReg);
 
  /* Check whether this is an encoder interrupt */
  if ( enc_semaphore_flag != 0 )
  {
    /* semaphore was not 0 so read out frame rate                      */
                 
    /* Read the frame rate from the DSP                */
    frame_rate = qdsp_read(QDSP_encPacketRate);

    qdsp_block_read(QDSP_encPacketBuf, 0, tx_packet, 17, FALSE);
   
    /* Host clears the semaphore flag when read                        */
    qdsp_write(QDSP_encPacketReg, 0); /* Clear the semaphore */

    /* Diagnostic transmit frame rate counters */
    switch (frame_rate) {
       case QDSP_RATE_EIGHTH_V:
          qdsp_tx_8++;
          break;
       case QDSP_RATE_QUARTER_V:
          qdsp_tx_4++;
          break;
       case QDSP_RATE_HALF_V:
          qdsp_tx_2++;
          break;
       case QDSP_RATE_FULL_V:
          qdsp_tx_1++;
          break;
       default:
          break;
    }
 
    qdsp_write(QDSP_encMinRate, QDSP_RATE_EIGHTH_V);
 
    qdsp_write(QDSP_encMaxRate, QDSP_RATE_FULL_V);

  } /* end if ( enc_semaphore_flag != 0 ) */
 
 
  /* Check whether this is a decoder interrupt */
  if ( dec_semaphore_flag != 0 )
  {
    /* semaphore was not 0 so write out frame rate  */
    qdsp_write(QDSP_decPacketRate, frame_rate);
          
    qdsp_block_write(QDSP_decPacketBuf, 0, tx_packet, 17, FALSE);
          
    /* Host clears the count to indicate a valid packet is 
       available for DSP */
    qdsp_write(QDSP_decPacketReg, 0);

    /* Diagnostic receive frame rate counters */
    switch (frame_rate) {
       case QDSP_RATE_EIGHTH_V:
          qdsp_rx_8++;
          break;
       case QDSP_RATE_QUARTER_V:
          qdsp_rx_4++;
          break;
       case QDSP_RATE_HALF_V:
          qdsp_rx_2++;
          break;
       case QDSP_RATE_FULL_V:
          qdsp_rx_1++;
          break;
       default:
          break;
    }
  } /* end if ( dec_semaphore_flag != 0 ) */
} /* iquicktest_mic_receiver_loopback_isr() */
#endif

