/*======================================================================
USE CASE SCENARIOS DOCUMENTATION
=========================================================================
=IMedia - Playback with a buffer source=

This section discusses how user loads the media contents in a memory buffer and plays the media using IMedia interface. 
The discussion covers the following broad steps:
# Setting up a buffer as media source, including loading the media content into the buffer and setting the IMedia object with the buffer source
# Playing the media from the buffer and handle asynchronous media events
# Handling the common error conditions encountered during #1 and #2
#

This section assumes that the IMedia object is already created. For details about ways to create an IMedia object, refer to '''Setting up a buffer as media source'''.

==Setting up a buffer as media source==

===Step 1: Load the media content into memory buffer===

IMedia requires that the entire media content (data) needs to be loaded into the memory buffer to perform the playback from the buffer.
Allocate memory from the heap big enough to hold complete media content. Load the media content into the memory buffer. 

{{{

  // Load the entire media content from file to a memory buffer.
  {
   IFileMgr *     pfm;
   IFile *        pIFile;
   AEEFileInfo    fi;
 
   // Create IFileMgr object.
   if (SUCCESS != ISHELL_CreateInstance(pme->a.m_pIShell, 
                                        AEECLSID_FILEMGR, (void **)&pfm))
   {
      // Handle error condition
      return;
   }
 
   // Get the file size.
   IFILEMGR_GetInfo(pfm, pme->pszFile, &fi);
 
   // Allocate the memory from heap. 
   // Save the buffer pointer and size.
   pme->pMediaBuffer = MALLOC(fi.dwSize);
   if (NULL == pme->pMediaBuffer)
   {
      // Insufficient memory. Handle error condition
      return;
   }

   pmd->dwMediaBufferSize = fi.dwSize;
 
   // Open the file and read all the contents into the buffer.
   pIFile = IFILEMGR_OpenFile(pfm, pme->pszFile, _OFM_READ);
   if (NULL == pIFile)
   {
      // Handle error condition
      return;
   }
   IFILE_Read(pIFile, pme->pMediaBuffer, pmd->dwMediaBufferSize);
 
   // Release IFileMgr and IFile objects.
   IFILEMGR_Release(pfm);
   IFILE_Release(pIFile);
  }

}}}

===Step 2: Set media source as buffer in IMedia object===

IMedia enables specifying the memory buffer as media source. IMEDIA_SetMediaData() sets the media source via AEEMediaData structure. AEEMediaData::clsData member is set to MMD_BUFFER to specify a buffer as a media source.

{{{

   AEEMediaData	md;
   md.clsData = MMD_BUFFER;       // pData will be buffer
   md.pData = pme->pMediaBuffer;  // Buffer containing media
   md.dwSize = pme->dwMediaBufferSize; // Size, in bytes, of buffer
   nErr = IMEDIA_SetMediaData(pme->pIMedia, &md); // Set the media source
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}

After the IMedia object is created, it will be in the IDLE state. IMEDIA_SetMediaData() is called in the IDLE state. After the successful execution of this API, the IMedia object transitions from the IDLE to READY state.

The following diagram illustrates this process.
[[Image:AEEMedia/IMEDIA_SetMediaData1.gif]]


====What is MMD_BUFFER?====

MMD_BUFFER implies that the buffer is
* Allocated and owned by an application
* Kept valid by the application during the lifetime of the IMedia object, that is until this IMedia object is completely released
* Loaded with entire (NOT a fragment of) media content
* Freed after the IMedia object is deleted
*
====Note====
Never specify stack memory as the media buffer. See the code snippet below.

{{{

   // Load a small 2K media (MIDI) file into the buffer and play the media
   static void CApp_PlayMediaFromBuffer(CApp *pme)
   {
      byte           cbBuffer[2048];
      uint32         dwSize;
      AEEMediaData   md;
      int            nErr;
 
      //
      // Using the mechansim described in code snippet of section 2.1.1.1,
      // read the file contents into cbBuffer and 
      // size of the file in dwSize.
      // 
      md.clsData = MMD_BUFFER;
      md.pData = cbBuffer;    // *** WRONG!! Stack memory is set. ***
      md.dwSize = dwSize; 
 
      // This causes IMedia object referring to stack memory!
      nErr = IMEDIA_SetMediaData(pme->pIMedia, &md);
      if (SUCCESS != nErr)
      {
         // Handle error condition
         return;
      }

      // Invoking play causes unpredictable behavior! 
      // Possible device crash!!
      nErr = IMEDIA_Play(pme->m_pIMedia);     
      if (SUCCESS != nErr)
      {
         // Handle error condition
         return;
      }
   }

}}}

====Note====
Once the buffer is set, using IMEDIA_SetMediaData(), it cannot be replaced by another buffer since the IMedia state machine does not allow setting of media source in any other state except IDLE state. Doing IMEDIA_SetMediaData()again will return EBADSTATE. Refer to '''IMedia State Machine''' section.


==Playing the Media==
After the media source is set and the IMedia object is in the READY state, the next steps are as follows.

===Step 3: Registering a callback function to receive IMedia events===

IMedia delivers several asynchronous events via the callback function during operations like play. Register a callback function to process required IMedia events.

{{{

   // Register CApp_MediaNotify() function as callback.
   nErr = IMEDIA_RegisterNotify(pme->pIMedia, CApp_MediaNotify, pme);  
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}

===Step 4: Setting the volume level===

This step is not mandatory, but it is a good practice to set the expected initial volume level before starting a playback.

{{{

   // Set the volume level to the value set in pme->uVolume
   nErr = IMEDIA_SetVolume(pme->pIMedia, pme->uVolume);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}


===Step 5: Playing the media===

Start the playback.

{{{

   nErr = IMEDIA_Play(pme->pIMedia);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}


====Play Events====

The play operation triggers a series of asynchronous events, from the IMedia object, which are dispatched to the application via the registered callback function.

===Step 6: Handling required play events from the IMedia object===
The IMedia object delivers event information to the application via the AEEMediaNotify structure, which is part of the registered callback function signature. The AEEMediaNotify structure contains the following event information.
* nStatus: contains the status code (MM_STATUS_XXX).
* nCmd: contains the command code (MM_CMD_XXX). For play, this code is MM_CMD_PLAY.
* pData: contains the context-based data for the event.
* dwSize: contains the size, in bytes, of pData.
*
The following diagram illustrates this process.
[[image:AEEMedia/IMEDIA_Play.gif]]

The following information explains the diagram.

# MM_STATUS_START indicates that the media playback operation is about to begin. The IMedia object transitions from the READY to PLAY state.

# [MM_STATUS_MEDIA_SPEC] gives the media specifications. AEEMediaNotify::pData points to the media specifications, which depends on the type of media. For example, for MP3, AEEMediaNotify::pData points to AEEMediaMP3Spec structure that contains the MP3 media specifications.

# [MM_STATUS_TICK_UPDATE] gives periodic tick updates. It is typically 1 second. This is not a real-time clock feedback; it is a coarse time update that is usually used to display the playback progress by an application.

# MM_STATUS_DONE indicates that the media playback has run to its completion. MM_STATUS_DONE/MM_STATUS_ABORT indicates that the media playback was stopped. The IMedia object transitions from the PLAY to READY state.
#

During play operation, the playback can be controlled via various operations like seek, pan, tempo, and so forth. See '''IMedia - Play''' section for details.

====Note==== 
It is not mandatory for an application to handle all the IMedia events delivered to the application. The application can handle only the necessary events required for its functionality.

==Handling Error Conditions==

The following are common error conditions that an application may encounter:
# IMEDIA_SetMediaData() failed. One likely cause is setting a NULL buffer or a zero buffer size. In this case, the IMedia object will stay in IDLE state and you can set the media source again.

# IMEDIA_Play() call failed. A likely cause is that the media is not in READY state or some system resources are not available. Check the media state and availability of system resources like memory.

# MM_STATUS_START did not arrive, instead MM_STATUS_ABORT happened. This means the device multimedia layer has aborted the play operation. Likely reasons are invalid or unsupported media format, unavailability of multimedia resources, interruption by a high priority operation like voice call or SMS

# The playback stopped abruptly and MM_STATUS_ABORT happened. See MM_STATUS_START above.
#

===Complete Sequence & State Diagrams===
The complete sequence is illustrated in the following diagram.
[[Image:AEEMedia/IMEDIA_SetMediaData2.gif]]

==Summary==

IMedia enables an application to specify a memory buffer as a media source via IMEDIA_SetMediaData(), wherein you set AEEMediaData::clsData as MMD_BUFFER. The buffer is owned by an application and kept valid during the lifetime of the IMedia object. IMEDIA_Play() plays the media loaded in the buffer.

===========================================================================
=IMedia - Setup=

This section discusses how the user can create an IMedia-based object and set up the initial parameters before beginning the play operation. The discussion covers the following broad steps:
* Creating an IMedia object based on the media type or media content
* Setting up an IMedia object for play including setting the required parameters before beginning the play
* Retrieving the basic information from the IMedia object before starting the play
* Handling error conditions encountered creating an IMedia object and setting up an IMedia object for play.
*


==Creating an IMedia object==

This section discusses ways to create an IMedia object based on media type or media content.

===Step 1: Create IMedia object that handles the media content===

There are four ways to obtain the IMedia object depending on whether you already know the media type or not.
# The media type is already known. In this case, create the IMedia object using the standard BREW ISHELL_CreateInstance() method. The IMedia object will be in the IDLE state.

{{{

   // Create an IMedia object to render MP3 content.
   nErr = ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_MEDIAMP3, (void **)&pme->m_pIMedia);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}

# The media type is not known and type detection is required. In this case, first determine the media MIME type using the ISHELL_DetectType() API. Next, obtain the handler IMedia ClassID for the MIME type using ISHELL_GetHandler() and the handler type AEECLSID_MEDIA, which represents the IMedia base class interface ID. Finally, create the IMedia object as specified in Step 1 above.

{{{

 // Detect the media type and create IMedia object.
 {
   IFileMgr *     pfm;
   IFile *        pIFile;
   void *         pBuf = NULL;
   uint32         dwReqSize = 0;
   AEECLSID       cls;
   const char    *cpszMIME;
 
   // Find the buffer size needed to perform type detection.
   if (ENEEDMORE != ISHELL_DetectType(ps, NULL, &dwReqSize, NULL, NULL) || !dwReqSize)
      return EFAILED;
   // Allocate the buffer from heap. 
   pBuf = MALLOC(dwReqSize);
   if (NULL == pBuf)
   {
      // Handle error condition
      return;
   }
 
   // Open the file and read dwReqSize bytes into the buffer.
   if (SUCCESS != ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_FILEMGR, (void **)&pfm))
   pIFile = IFILEMGR_OpenFile(pfm, pme->pszMediaFile, _OFM_READ);
   if (NULL == pIFile)
   {
      // Handle error condition
      return;
   }
   IFILE_Read(pIFile, pBuf, dwReqSize);
 
   // Detect media type and get the MIME
   nErr = ISHELL_DetectType(ps, pBuf, &dwReqSize, NULL, &cpszMIME);
   if (SUCCESS == nErr)
   {
      // Type not detected. Also check for ENEEDMORE case or handle error.
      return;
   }
 
   // Query BREW Registry with MIME and AEECLSID_MEDIA as base
   // to obtain the ClassID of concrete IMedia class.
   if (!nErr)
   {
      cls = ISHELL_GetHandler(ps, AEECLSID_MEDIA, cpszMIME);
      if (cls)
         *pCls = cls;
   }   
 
   FREE(pBuf);
   IFILEMGR_Release(pfm);
   IFILE_Release(pIFile);
 }

}}}

# The media type is not known, and you do not want to do type detection, use  the utility IMEDIAUTIL_CreateMedia() API. This API creates the right IMedia object and sets the media data to place the IMedia object in the READY state.

{{{
   // Play sample.mp3 file located in the application directory.
   static void CApp_PlayMedia(CApp *pme)
   {
      IMediaUtil    *pIMediaUtil;
      AEEMediaData   md;

      // Create IMediaUtil instance.
	   if (SUCCESS != ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_MEDIAUTIL, (void   **)&pIMediaUtil))
      {
         // IMediaUtil cannot be created. Handle error condition
         return;
      }

      // Set sample.mp3 file as source.
      md.clsData = MMD_FILE_NAME;
      md.pData = "sample.mp3";
      md.dwSize = 0; 

      // Create IMedia object, set media data, put IMedia object 
      // in READY state and retrieve IMedia object pointer.
      if (SUCCESS != IMEDIAUTIL_CreateMedia(pIMediaUtil, &md, &pme->pIMedia))
      {
         // Failed to create media. Handle error condition
         return;
      }

      // Release IMediaUtil.
      IMEDIAUTIL_Release(pIMediaUtil);

      if (SUCCESS != IMEDIA_Play(pme->m_pIMedia))
      {
         // Failed to start the play
         return;
      }
   }

}}}
The following diagram illustrates this process.
[[image:AEEMedia/IMEDIAUTIL_Create.gif]]
# This is the same case as #3, but you need more control over media creation. Use the AEEMediaUtil_CreateMedia() utility function, which by default behaves like IMEDIAUTIL_CreateMedia() API. This function is provided in AEEMediaUtil.c, which is shipped with BREW SDK®. It creates an IMedia object, sets the media data, and places the IMedia object in the READY state. Applications can customize this function and include AEEMediaUtil.c in their application build.
 
====Customization example====
By default, the AEEMediaUtil_CreateMedia()API uses the extension of the file to detect the media type. For instance, if the filename is sample.mp3, it uses the MIME audio/mp3, queries BREW registry for IMedia handler type, and returns the IMedia object that handles MP3. You can modify the AEEMediaUtil_CreateMedia()function to detect the media type based on the contents of the file. With this change, the actual contents of the file are examined to detect the media type and return the right media object.


==Step 2: Setting up an IMedia object for play==

The next step is to set the media data and transition the IMedia object in READY state. After IMedia object is created, it will not have any media source and will be in the IDLE state. No IMedia operations are possible in the IDLE state except to set the media data source. Set it using IMEDIA_SetMediaData()in the IDLE state. Most of the other IMedia APIs in this state will return the EBADSTATE error code. After the successful execution of IMEDIA_SetMediaData(), the IMedia object transitions from the the IDLE to READY state.

====Note:====
If the IMedia object is created using method #1 or #2 in step #1, then it will be in the IDLE state. However if the the IMedia object is created using method #3 or #4 in step #1, the media source is already set and the IMedia object will be in the READY state.

IMedia enables you to specify various media sources: filename, memory buffer or ISource. The IMEDIA_SetMediaData()API sets the media source via the AEEMediaData structure.
 
* AEEMediaData::clsData member is set to one of the following source types:

** MMD_FILE_NAME specifies the filename of the media. The filename is copied by the IMedia object and can be freed by the application, if required.

** MMD_BUFFER specifies the memory buffer, in which the entire media is loaded. The buffer is owned by the application. This means the application keeps it valid till the IMedia object is released and releases the buffer later. See section '''IMedia - Playback with a buffer source'''.

** MMD_ISOURCE specifies an ISource, which fetches media data on demand. This enables streaming media. The ISource object is owned by the application. This means the application keeps it valid until the IMedia object is released and releases the ISource object later.

* AEEMediaData::pData member is set to filename, buffer pointer, or ISource pointer based on the value of AEEMediaData::clsData

* AEEMediaData::dwSize member is valid for MMD_BUFFER only and specifies the size, in bytes, of the buffer.  Set this value to zero for other types.
*

{{{

 // Set sample.mp3 as media data. File is located in an application directory.
 {
    AEEMediaData	md;
    md.clsData = MMD_FILE_NAME;  // pData will be media filename
    md.pData =  "sample.mp3";    // Media filename
    md.dwSize = 0;               
 
    if (SUCCESS != IMEDIA_SetMediaData(pme->pIMedia, &md)) // Set the media source
    {
      // Failed to set the source. Handle error.
      return;
    }
 }

}}}


===Step 3: Register a callback function to receive IMedia events===

IMedia delivers several asynchronous events via the callback function during operations like play. Register a callback function to process the required IMedia events.

{{{

   // Register CApp_MediaNotify() function as callback.
   nErr = IMEDIA_RegisterNotify(pme->pIMedia, CApp_MediaNotify, pme);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}

===Step 4: Set the volume level===
This step is not mandatory but it is a good practice to set the expected initial volume level before starting a playback.

{{{

   // Set the volume level to the value set in pme->uVolume
   nErr = IMEDIA_SetVolume(pme->pIMedia, pme->uVolume);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}

To get the current volume level, use IMEDIA_GetVolume().
{{{
   nErr= IMEDIA_GetVolume(pme->pIMedia, &pme->uVolume);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
}}}

To mute/umnute the volume, use the IMEDIA_SetMuteCtl()API and specify the second parameter (bMute) as TRUE/FALSE to mean mute/unmute.

{{{

   nErr = IMEDIA_SetMuteCtl(pme->pIMedia, pme->bMute);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}
====Note====
If IMEDIA_SetMediaParm() or IMEDIA_GetMediaParm() APIs return SUCCESS, then the operation is successfully completed. If it returns MM_PENDING, then the status and associated data of the operation is sent via the registered callback function.

The following diagram illustrates this process.
[[Image:AEEMedia/IMEDIA_SetVolume.gif]]


==Getting basic information before play==
When the IMedia object is ready to use and before the beginning of playback, an application can get useful information to further prepare for play operation.

===Step 5: Get media capabilities, ClassID and state===
The IMedia capabilities tell if the media contains audio, video, and/or text. This is especially helpful to know if the media contains video or animation. This allows an application to specify the video display rectangle on the screen.

{{{

      // Check if media contains video and if so, set display rectangle.
      {
         uint32   dwCaps;
 
         nErr = IMEDIA_GetMediaParm(pme->m_pIMedia, MM_PARM_CAPS, (int32 *)&dwCaps, 0);
         if (SUCCESS != nErr)
         {
            // Handle error condition
            return;
         }
         if (dwCaps & MM_CAPS_VIDEO)
         {
            nErr = IMEDIA_SetRect(pme->m_pMedia, &pme->m_rectImage, NULL);
            if (SUCCESS != nErr)
            {
               // Handle error condition
               return;
            }
         }
      }
}}}
To get the media ClassID, use the IMEDIA_GetClassID()API.
To get the state of the media anytime, use the IMEDIA_GetState()API.

===Step 6: Get total playback time of the media===
IMEDIA_GetTotalTime() gives the total playback time of the media. This API asynchronously returns the total time in milliseconds. Getting the total time is not always possible (for example, live streaming).

The event containing total playback time is returned via the registered callback function. AEEMediaNotify structure contains the following event information.
* nStatus contains the status code MM_STATUS_DONE
* nCmd contains the command code MM_CMD_GETTOTALTIME
* pData contains the total time in milliseconds
*

The following diagram illustrates this process.
[[Image:AEEMedia/IMEDIA_GetTotalTime.gif]]

==Handling Error Conditions==
Following are common error conditions that an application may encounter:

* Cannot create media, because the ISHELL_CreateInstance() failed. A likely cause is that media type is not supported on the device. Check the device specifications to see if the media type is supported. For example, MP3 is not supported on low-end devices.

* The IMEDIA_SetMediaData() failed. One likely cause is setting a NULL buffer or a zero buffer size. In this case, the IMedia object will stay in the IDLE state. You can set the media source again. Another reason can be that the application called when the media is not in the IDLE state. See Setting Up IMedia Object for Play.

* IMEDIA_SetRect() failed. Media may not contain video component. Check if the media contains video/animation.

* IMEDIA_GetTotalTime() returns EUNSUPPORTED. One possibility is that it is not possible to implement it for the media type or source
*

==Summary==
IMedia object can be created in more than one way based on the media type. Set media data, register callback function and set the volume before playing the media. If you need to, you can get the media capabilities, set the video rectangle if media contains video, and get the total playback time of the media.
=====================================================================
USE CASE SCENARIOS DOCUMENTATION
=======================================================================
=IMedia - Play=
This section discusses how the media playback is started and how an application can control the playback using the IMedia API.
The discussion covers the following broad steps.
# Starting and stopping playback
# Using basic playback controls
# Using advanced playback controls
# Handling error conditions
#

This section assumes that the IMedia object is already created. For details about ways to create an IMedia object, refer to '''IMedia - Setup''' section.

==Starting and Stopping Playback==
In this section, the playback of media from a file source is illustrated. The file sample.mp3 is assumed to be in the application directory.
To play from buffer source, see '''IMedia - Playback with a buffer source'''.
To play from stream or to perform streaming, see '''Media - Streaming'''.

===Step 1: Play the media===
To prepare for playback, see sections '''Step 2: Setting up an IMedia object for play''' and '''Getting basic information before play'''.

Start the playback

{{{

   if (SUCCESS != IMEDIA_Play(pme->pIMedia))
   {
      // Failed to start the play...
      return;
   }

}}}

You can allow the media to complete playback by itself or stop the playback anytime using IMEDIA_Stop().

{{{

   nErr = IMEDIA_Stop(pme->pIMedia);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}

==Play Events==
Play operation triggers a series of asynchronous events, from IMedia object, which are dispatched to the application via the registered callback function.

The following diagram illustrates this process.
[[Image:AEEMedia/IMEDIAUTIL_Create.gif]]

===Step 2: Handle required play events from IMedia object===
IMedia object delivers event information to the application via AEEMediaNotify structure, which is part of the registered callback function signature.
AEEMediaNotify structure contains the following event information.
* nStatus contains the status code (MM_STATUS_XXX)
* nCmd contains the command code MM_CMD_PLAY
* nSubCmd contains the command specific code. For example, for MM_CMD_SETMEDIAPARM or MM_CMD_SETMEDIAPARM, it contains MM_PARM_XXX
* pData contains the context-based data for the event
* dwSize contains the size, in bytes, of pData
*

The following diagram illustrates this process.
[[Image:AEEMedia/IMEDIA_Seek.gif]]

# MM_STATUS_START indicates that the media playback operation is about to begin. IMedia object transitions from READY state to PLAY state
# [MM_STATUS_MEDIA_SPEC] gives the media specifications. AEEMediaNotify::pData points to the media specifications, which depends on the type of media. For example, for MP3, AEEMediaNotify::pData points to AEEMediaMP3Spec structure that contains the MP3 media specifications
# [MM_STATUS_TICK_UPDATE] gives periodic tick updates. It is typically one second. This is not a real-time clock feedback and it is a coarse time update that is usually used to display the playback progress by applications.
# MM_STATUS_DONE indicates that the media playback has run to its completion. MM_STATUS_DONE/MM_STATUS_ABORT that the media playback was stopped. IMedia object transitions from PLAY state to READY state

During play operation, the playback can be controlled via various operations like Seek, Pan, Tempo, etc. See Media Playback section for details.

It is not mandatory for an application to handle all the IMedia events delivered to the application. An application can handle only the necessary events required for its functionality.

==Using basic playback controls==
During play operation, the basic playback control operations can be performed. These are pause, resume, seek, volume and mute controls.
===Step 3a: Pause and Resume===
If the media is playing, you can pause the playback using the IMEDIA_Pause() API.

{{{

  if (SUCCESS != IMEDIA_Pause(pme->pIMedia))
  {
      // Failed to issue pause command.
      return;
  }

}}}

The successful completion of this API triggers {MM_STATUS_PAUSE, MM_CMD_PLAY, pData=ElaspsedTimeMS} events and the IMedia object transitions to the PLAY_PAUSE state.
If the media is paused, you can resume the playback using the IMEDIA_Resume() API.

{{{

   if (SUCCESS != IMEDIA_Resume(pme->pIMedia))
   {
      // Failed to issue resume command.
      return;
   }

}}}

The successful completion of this API triggers the following events:

{{{

{MM_STATUS_RESUME, MM_CMD_PLAY, pData=ElaspsedTimeMS} 

}}}
The IMedia object transitions back to the PLAY state.

The following diagram illustrates this process.
[[Image:AEEMedia/IMEDIA_Pause.gif]]

===Step 3b: Seek===
If the media is playing or paused, you can seek to a desired position within the media using the IMEDIA_Seek(), IMEDIA_Rewind(), IMEDIA_Forward() APIs.  The seek operation can be issued in the PLAY or PLAY_PAUSE state.

There are three seek modes based on the position reference.
* MM_SEEK_START:  Seek from beginning of media
* MM_SEEK_END: Seek from end of media
* MM_SEEK_CURRENT: Seek from current position of media
**MM_SEEK_CURRENT is the most commonly supported mode. The IMEDIA_Rewind()and IMEDIA_Forward()macros use IMEDIA_Seek() with MM_SEEK_CURRENT to rewind and fast-forward the media from the current position. You can isssue the desired seek as follows:

{{{

   nErr = IMEDIA_Seek(pme->pIMedia, MM_SEEK_CURRENT, pme->lTimeMS);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
   nErr = IMEDIA_Rewind(pme->pIMedia, pme->lTimeMS);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
   nErr = IMEDIA_FastForward(pme->pIMedia, pme->lTimeMS);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}

The successful completion of this API triggers {MM_STATUS_SEEK, MM_CMD_PLAY} events. The IMedia object continues to stay in the same state.

The following diagram illustrates this process.
[[Image:AEEMedia/IMEDIAUTIL_Seek.gif]]

===Step 3c: Volume control===
See step #4 of '''Step 2: Setting up an IMedia object for play'''.

==Using advanced playback controls==
During the play operation, in addition to the basic playback control operations, you can also invoke the pan, tempo, and tune operations.

===Step 4a: Pan===
If the media is playing, you can pan the audio across the stereo speakers. following are the pan factors:
* 0 specifies left speaker
* MM_MAX_PAN/2 specifies balance
* MM_MAX_PAN specifies right speaker
*

{{{

   nErr = IMEDIA_Pan(pme->pIMedia, pme->wPan);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}

The successful completion of this API triggers the {MM_STATUS_DONE, MM_CMD_SETMEDIAPARM, nSubCmd=MM_PARM_PAN} event.

===Step 4b: Tempo===
If the media is playing, you can change the tempo of the audio. A tempo factor is expressed  in percent. Normal playback is 100%. Typically, this operation applies to MIDI-based content.

{{{

   nErr = IMEDIA_SetMediaParm(pme->pIMedia, MM_PARM_TEMPO, (int32)pme->wTempo, 0);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

}}}

The successful completion of this API triggers the {MM_STATUS_DONE, MM_CMD_SETMEDIAPARM, nSubCmd=MM_PARM_TEMPO} event.

===Step 4c: Tempo===
If the media is playing, you can modify the tuning of the audio. A tune factor of 0x40 indicates normal tune. Typically, this operation applies to MIDI-based content. 

{{{

   nErr = IMEDIA_SetMediaParm(pme->pIMedia, MM_PARM_TUNE, (int32)pme->wTuneFactor, 0);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
   
}}}

The successful completion of this API triggers the {MM_STATUS_DONE, MM_CMD_SETMEDIAPARM, nSubCmd=MM_PARM_TUNE} event.

==Handling Error Conditions==
The following are the common error conditions that an application may encounter.

# IMEDIA_Play() call failed. A likely cause is that the media is not in the READY state or the system resources are not available. Check the media state and availability of system resources like memory.

# MM_STATUS_START did not arrive, instead MM_STATUS_ABORT happened. This means the device multimedia layer has aborted the play operation. Likely reasons are an invalid or unsupported media format, an unavailability of multimedia resources, or an interruption by a high priority operation like voice call or SMS.

# Playback stopped abruptly and MM_STATUS_ABORT happened. Same as '''MM_STATUS_START did not arrive''' above.

# Pause/Resume/Seek operations failed and returned EITEMBUSY synchronously. Some IMedia implementations allow only one pending operation. For example, if you invoke Pause, you need to wait till MM_STATUS_PAUSE event arrives before starting the next operation.

# Pause/Resume/Seek operations failed and asynchronously return MM_STATUS_PAUSE_FAIL/MM_STATUS_RESUME_FAIL/MM_STATUS_SEEK_FAIL via callback function. The underlying device multimedia layer rejected the call due to a wrong parameter or a lack of resources. Check the parameters and try again after some time.

# Pan/Tempo/Tune has no effect. Check if the media is playing. Check that the media type supports the operation. For example, tempo and tune usually apply to MIDI-based content.

==Summary==
After setting up the IMedia object for playback, you can issue IMEDIA_Play() to start the playback. Various operations can be invoked during playback including: pause, resume, seek, pan, tempo, tune, and adjust the volume or  mute controls.
=================================================================
=IMedia - Simultaneous media playback=
This section discusses how user can simultaneously play multiple media using the IMedia interface. This is called the multi-sequencer feature.
The basic philosophy of creating and using the IMedia object still holds. To play multiple media simultaneously, an application creates an the IMedia object corresponding to each media. Each IMedia object is configured so that system resources are allocated to enable mixing of the audio from the media playback.
This discussion covers the following broad steps.
* Setting up media sources
* Enabling channel share
* Starting the playback
** Using playback controls
* Handling error conditions encountered during these steps.
*
====Note:====
The device capabilities enforce certain restrictions on number and type of simultaneous media. 

For example, Qualcomm MSM-based devices can typically simultaneously play the following media sets:

* 1 MIDI / MMF / PMD(with MIDI) + 4 QCP(fixed) / AMR / ADPCM (all 4 of same type) [QCP needs to be started first before MIDI/PMD]
* [Using 6550 and above] 4 MIDI / MMF / PMD(with MIDI) + 4 QCP(fixed) / AMR / ADPCM (all 4 of same type)
* To start simultaneous playback of new media set, release all the IMedia objects in the current set
*

==Setting up Media Sources==

===Step 1: Set the media source as file or buffer in the IMedia object===
Take three ADPCM files that will be played simultaneously. The files are a1.wav, a2.wav and a3.wav. The corresponding IMedia objects created are called pIMedia1, pIMedia2 and pIMedia3.
{{{
{
      //
	// Setup the IMedia objects with media files
	//
	AEEMediaData	md;

	md.clsData = MMD_FILE_NAME;
	md.dwSize = 0;

	// a1.wav: Create IMedia object and set the media data
	if (SUCCESS != ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_MEDIAADPCM, (void **)&pme->m_pIMedia1))
   {
      // Failed to create media object. Handle error condition.
      return;
   }
	md.pData = "a1.wav";
	if (SUCCESS != IMEDIA_SetMediaData(pme->m_pIMedia1, &md))
   {
      // Failed to set media data. Handle error condition.
      return;
   }
	// Register a callback notification function
	if (SUCCESS != IMEDIA_RegisterNotify(pme->m_pIMedia1, CApp_Media1Notify, pme))
   {
      // Failed to register callback. Handle error condition.
      return;
   }

	// a2.wav: Create IMedia object and set the media data
	ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_MEDIAADPCM, (void **)&pme->m_pIMedia2);
   {
      // Failed to create media object. Handle error condition.
      return;
   }
	md.pData = "a2.wav";
	if (SUCCESS != IMEDIA_SetMediaData(pme->m_pIMedia2, &md))
   {
      // Failed to set media data. Handle error condition.
      return;
   }
	// Register a callback notification function
	if (SUCCESS != IMEDIA_RegisterNotify(pme->m_pIMedia2, CApp_Media2Notify, pme))
   {
      // Failed to register callback. Handle error condition.
      return;
   }

	// a3.wav: Create IMedia object and set the media data
	if (SUCCESS != ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_MEDIAADPCM, (void **)&pme->m_pIMedia3))
   {
      // Failed to create media object. Handle error condition.
      return;
   }
	md.pData = "a3.wav";
	if (SUCCESS != IMEDIA_SetMediaData(pme->m_pIMedia3, &md))
   {
      // Failed to set media data. Handle error condition.
      return;
   }
	// Register a callback notification function
	if (SUCCESS != IMEDIA_RegisterNotify(pme->m_pIMedia3, CApp_Media3Notify, pme))
   {
      // Failed to register callback. Handle error condition.
      return;
   }

}
}}}
After the IMedia objects are created, they will be in the IDLE state. IMEDIA_SetMediaData() is called in the IDLE state. After the successful execution of this API, the IMedia objects transition from the IDLE to READY state. Refer to the '''IMedia state machine''' diagram.

==Enabling channel share feature==
When the user enables the channel share feature in IMedia, the IMedia object performs the necessary functions to allocate system multimedia resources. This allows simultaneous playback of the media.

===Step 2: Enable the channel share feature for each IMedia object===
IMEDIA_EnableChannelShare() allows an application to enable or disable this feature.
For each media, enable this feature as follows:
{{{
	nErr = IMEDIA_EnableChannelShare(pme->pIMedia1, TRUE);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
	nErr = IMEDIA_EnableChannelShare(pme->pIMedia2, TRUE);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
	nErr = IMEDIA_EnableChannelShare(pme->pIMedia3, TRUE);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
}}}

==Playing the Media==
After the media source is set and the channel share feature is enabled for each IMedia object, the playback of the individual media needs to be started.

===Step 3: Play the media simultaneously===
For each media, call IMEDIA_Play().
{{{
	nErr = IMEDIA_Play(pme->pIMedia1);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
	nErr = IMEDIA_Play(pme->pIMedia2);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
	nErr = IMEDIA_Play(pme->pIMedia3);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
}}}
====Note====
If the device is MSM-based, the BREW version is 3.1.5 or lower and the media type is QCP/AMR/ADPCM, after step(a), an application must yield and then carryout steps (b) and (c). The best place to perform steps (b) and (c) is using the CApp_Media1Notify() function when the MM_STATUS_START arrives in response to step (a). This needs to be done only once. After that, as long as at least one of the IMedia objects is alive, you can synchronously call multiple IMEDIA_Play() as shown above. Typically, there should be no performance impact due to this change as MM_STATUS_START arrives in a few (<10) milliseconds.

{{{
{
	 //
	// Call the first play
	//
	nErr = IMEDIA_Play(pme->pIMedia1);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }

	// Yield now
}

static void CApp_Media1Notify(void * po, AEEMediaCmdNotify * pcn)
{
	CApp * pme = (CApp *)po;

	// Start received. Resources are setup.
	// Call the second and third play
	if (MM_STATUS_START == pcn->nStatus)
	{
	   nErr = IMEDIA_Play(pme->pIMedia2);
      if (SUCCESS != nErr)
      {
         // Handle error condition
         return;
      }
	   nErr = IMEDIA_Play(pme->pIMedia3);
      if (SUCCESS != nErr)
      {
         // Handle error condition
         return;
      }
	}
}
}}}

===Step 4: Handle play events===
Each IMedia object will start receiving the play events. The MM_STATUS_START is received to indicate that the playback is about to begin. The MM_STATUS_DONE is received when the playback ends. For a complete list of status, please see AEEMediaCmdNotify.

====Using playback controls====
You can invoke various playback control APIs like volume, pan, and so forth on each IMedia object in order to control that media’s playback.

===Step 5a: Set the volume level===
The individual media volume can be controlled by calling the IMEDIA_SetVolume() API on each IMedia object.
{{{
	// Set the volume level to the value set in pme->uVolume1
	nErr = IMEDIA_SetVolume(pme->pIMedia1, pme->uVolume1);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
}}}

===Step 5b: Set the pan factor===
The individual media pan setting can be controlled by calling the IMEDIA_SetPan() API on each IMedia object.
{{{
	// Set the volume level to the value set in pme->uPan1
	nErr = IMEDIA_SetPan(pme->pIMedia1, pme->uPan1);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
}}}

===Step 6: Stop the playback===
To stop the multi-sequence completely, call stop on each IMedia object:
{{{
	IMEDIA_Stop(pIMedia1);
	IMEDIA_Stop(pIMedia2);
	IMEDIA_Stop(pIMedia3);
}}}

====Note====
At this point, each IMedia object is still alive and the channel share feature is enabled. You can now simply restart the playback, by synchronously calling IMEDIA_Play() as shown in step #3 above.

==Handling Error Conditions==

Following are common error conditions that an application may encounter.
# IMEDIA_SetMediaData() failed. A likely cause is setting a NULL buffer or a zero buffer size. In this case, the IMedia object will stay in the IDLE state. You can set the media source again.

# IMEDIA_Play() call failed. A likely cause is that the media is not in the READY state or the system resources are not available. Check the media state and availability of system resources like memory.

# Second IMEDIA_Play()call failed. If you are invoking multiple plays, after the first play is going on, then the system setting up multimedia resources for the second media fails. See '''Step 3: Play the media simultaneously''' which shows how you may want to yield after the first play.

# MM_STATUS_START did not arrive, instead MM_STATUS_ABORT happened. This means the device multimedia layer has aborted the play operation. Likely reasons include: an invalid or unsupported media format, an unavailability of multimedia resources, or an interruption by a high priority operation like a voice call or SMS.

# Playback stopped abruptly and MM_STATUS_ABORT happened. Same as #4 "MM_STATUS_START did not arrive" above.

=========================================================================
=IMedia - Streaming=
This section discusses how to perform real-time streaming of the
media and how raw media data can be streamed using the IMedia API.
The discussion covers the following broad steps.
# Setting up a streaming media source
# Streaming the media 
# Handling error conditions
#

This section assumes that the IMedia object is already created. For details about the ways to create an IMedia object, refer to step #1 or #2 of '''IMedia -Setup'''.
The streaming feature is available in the BREW 2.1.3 Patch #9, BREW 3.1.2, and later versions of BREW.

==Setting up a streaming media source==
An IMedia object streams the media data from a concrete implementation of an ISource object.

Perform the following steps to enable media streaming.

===Step 1: Set streaming source and parameters===
Using the IMEDIA_SetMediaDataEx() API, an application can specify the streaming media source information. This API takes the AEEMediaDataEx structure as input.
The streamed media data can be of two types.
 * Formatted data contained in a well defined format that contains header
and associated information describing the encoding specifications of the media and the the location of the data, for example, an .mp3 file or .wav file.
*Raw data where the encoding specifications is provided by the
user separately. For example, an audio codec application or a game engine may first specify the media encoding type and then dynamically generate raw PCM data at various points in time.

====What is an MMD_ISOURCE?====
An MMD_ISOURCE implies streaming. In other words, it means the media data is streamed using an ISource object specified by the application. The ISource object is
* Allocated and owned by the application.
* Kept valid by the application during lifetime of the IMedia object, for example, until the IMedia object is completely released.
* Implemented by an application, if BREW supplied ISource implementations are not used.
* Always kept ready to feed the data when the IMedia object calls ISOURCE_Read()
* Freed after the IMedia object is deleted
*

===Step 1a: Set formatted data as a streaming media source ===
Using the IMEDIA_SetMediaDataEx() API, the application can specify formatted data as a streaming media source in the AEEMediaDataEx structure. See  the steps in the code snippet.
{{{
	//Set the streaming media source as "sample.wav" file saved in an application directory.
	//Setup an ISource referring to "sample.wav" and set the media data using
	//IMEDIA_SetMediaDataEx().
	//
	static void CApp_SetupSource(CMediaOAT * pme)
	{
  
		AEEMediaDataEx md;
		IFileMgr *     pfm;
		ISourceUtil *  psu;
      int            nErr;

		// STEP #1: Create IMedia PCM object. It will be in IDLE state.
  		nErr = ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_MEDIAPCM, (void **)&pme->m_pIMedia);
      if (SUCCESS != nErr)
      {
         // Handle error condition
         return;
      }

		//
		// STEP #2: Create the concrete ISource object.
		// Create an ISource object that is actually an IAStream object, 
  		// which is the IFile object referring to &quot;sample.wav&quot;.  
		//
  
		nErr = ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_FILEMGR, (void**)&pfm))  
      if (SUCCESS != nErr)
      {
         // Handle error condition
         return;
      }
		pme->m_pFile = IFILEMGR_OpenFile(pfm, "sample.wav", _OFM_READ);
      if (!pme->m_pFile)
      {
         // Handle error condition
         return;
      }
  		IFILEMGR_Release(pfm);
  		nErr = ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_SOURCEUTIL, (void**)&psu))
      if (SUCCESS != nErr)
      {
         // Handle error condition
         return;
      }
  		nErr = ISOURCEUTIL_SourceFromAStream(psu, (IAStream *)pme->m_pFile, &pme->m_pISource);
      if (SUCCESS != nErr)
      {
         // Handle error condition
         return;
      }
  		ISOURCEUTIL_Release(psu);

		// STEP #3: Initialize ISource object in AEEMediaDataEx
		
		md.clsData = MMD_ISOURCE;           // pData is ISource
		md.pData = (void *)pme->m_pISource; // ISource object
		md.dwSize = 0; 
		md.dwStructSize = sizeof(md);       // Size of AEEMediaDataEx structure
		md.dwCaps = 0;                      // What capabilities to enable. 0 means all.
		md.bRaw = FALSE;                    // Is this Raw data? Set it to no (FALSE)
		md.dwBufferSize = 0;                // Internal buffer size. 0 means use default.  
		md.pSpec = NULL;                    // Valid only for raw data  
		md.dwSpecSize = 0;                  // Valid only for raw data  

		// STEP #4: Set the media data. IMedia object transitions to READY state.
		nErr = IMEDIA_SetMediaDataEx(pme->m_pIMedia, &md, 1);
      if (SUCCESS != nErr)
      {
         // Handle error condition
         return;
      }
}
}}}

===Step 1b: Set raw data as a streaming source===
Using the IMEDIA_SetMediaDataEx() API, the application can specify the streaming media source and the streaming information in AEEMediaDataEx structure. See the steps in the code snippet.
{{{
//Set the streaming media source as "sample.raw" file saved in the application directory.
//The encoding specifications are: Linear PCM, 16kHz, 16-bit, Unsigned, Stereo.
//Setup an ISource referring to "sample.raw" and set the media data using
//IMEDIA_SetMediaDataEx().
//
static void CApp_SetupSource(CMediaOAT * pme)
{  
	AEEMediaWaveSpec  ws;  
	AEEMediaDataEx md;  
	IFileMgr *     pfm;  
	ISourceUtil *  psu;

	// STEP #1: Create IMedia PCM object. It will be in IDLE state.
	nErr = ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_MEDIAPCM, (void **)&pme->m_pIMedia);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
  
	// STEP #2: Create the concrete ISource object.
	// Create an ISource object that is actually an IAStream object, 
	// which is the IFile object referring to "sample.wav".
  	//
  
	nErr = ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_FILEMGR, (void**)&pfm))
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
  	pme->m_pFile = IFILEMGR_OpenFile(pfm, "sample.wav", _OFM_READ);
   if (!pme->m_pFile)
   {
      // Handle error condition
      return;
   }
  	IFILEMGR_Release(pfm);
  	nErr = ISHELL_CreateInstance(pme->a.m_pIShell, AEECLSID_SOURCEUTIL, (void**)&psu))
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
	nErr = ISOURCEUTIL_SourceFromAStream(psu, (IAStream *)pme->m_pFile, &pme->m_pISource);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
  	ISOURCEUTIL_Release(psu);
	// STEP #3: Specify the encoding information of the raw data based on the media.
	// For raw PCM, use AEEMediaWaveSpec defined in AEEMediaFormats.h
	MEMSET(&ws, (int)0, sizeof(ws));
  	ws.wSize= sizeof(ws);
  	ws.clsMedia= AEECLSID_MEDIAPCM;
 	ws.wChannels= 2;
  	ws.dwSamplesPerSec= 16000;
  	ws.wBitsPerSample= 16;
  	ws.bUnsigned= TRUE;
  
	// STEP #4: Initialize ISource object in AEEMediaDataEx  
	// Set the encoding specifications of the raw media data.
	md.clsData = MMD_ISOURCE;           // pData is ISource
	md.pData = (void *)pme->m_pISource; // ISource object
	md.dwSize = 0; 
  	md.dwStructSize = sizeof(md);       // Size of AEEMediaDataEx structure
  	md.dwCaps = 0;                      // What capabilities to enable. 0 means all.
	md.bRaw = TRUE;                     // Is this Raw data? Set it to yes (TRUE)
	md.dwBufferSize = 0;                // Internal buffer size. 0 means use default.
  	md.pSpec = &ws;                     // Raw media data encoding specifications
	md.dwSpecSize = sizeof(ws);         // Size, in bytes, of the specifications

	// STEP #5: Set the media data. IMedia object transitions to READY state.
	nErr = IMEDIA_SetMediaDataEx(pme->m_pIMedia, &md, 1);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
}
}}}

==Streaming Media==
Follow steps #3 and #4 in section '''Media - Setup''',
Start the streaming and playback.

{{{
   nErr = IMEDIA_Play(pme->pIMedia);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
}}}

This call makes the IMedia object trigger a number of asynchronous ISource read operations via ISOURCE_Read() to fetch the media data while the media is playing. To avoid buffer underrun conditions, the application must always make sure to provide the requested buffers. The IMedia object also sends the same play related asynchronous events mentioned in section "Play Events." 
To stop the streaming and playback use the following code.
{{{
   nErr = IMEDIA_Stop(pme->pIMedia);
   if (SUCCESS != nErr)
   {
      // Handle error condition
      return;
   }
}}}

==Handling Error Conditions==
Following are common error conditions that an application may encounter.
#	Cannot create media: The ISHELL_CreateInstance() failed. A likely cause is that media type is not supported on the device. Check the device specifications to see if the media type is supported. 
#	IMEDIA_SetMediaDataEx() failed. In this case, the IMedia object will stay in the IDLE state. You can set the media source again.
	a.	If this API returned EUNSUPPORTED, make sure that the media streaming is supported on the device for the media type.
	b.	Check if the streaming media data is correctly specified in AEEMediaDataEx structure.
	c.	Make sure you set AEEMediaDataEx::dwStructSize member to the size of the structure itself.
	d.	Make sure that the media object is in the IDLE state. See '''Step 2: Setting up an IMedia object for play'''.
#	ISOURCE_Read() never happened. Check if IMEDIA_Play() is called. If play is called, then check if the device has enough resources to perform streaming.
#
==Summary==
The IMedia object can be initialized to stream media data from the ISource object using the IMEDIA_SetMediaDataEx() API. The data can be formatted data or raw data. In the case of raw data, an application needs to explicitly set the encoding specifications of the media.

===========================================================================*/

